<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Load Leaflet from CDN -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""> </script> 
    <!-- Load the third-party Esri Leaflet plugin, which is used to get ESRI tiles -->
    <script src="https://unpkg.com/esri-leaflet@3.0.10/dist/esri-leaflet.js"></script>
    <script src="https://unpkg.com/esri-leaflet-vector@4.0.1/dist/esri-leaflet-vector.js"></script>
    <!-- Load the third-party Mapbox GL Leaflet plugin, which is used to get Mapbox tiles -->
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel='stylesheet' />
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js'></script>
    <script src="https://unpkg.com/mapbox-gl-leaflet/leaflet-mapbox-gl.js"></script>
    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.7.0.min.js" crossorigin="anonymous"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js" crossorigin="anonymous"></script>
    <!-- Geocoding -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-geosearch@3.11.1/dist/geosearch.css"/>
    <script src="https://unpkg.com/leaflet-geosearch@3.11.1/dist/geosearch.umd.js"></script>
    <!-- Marker clustering -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css">
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <!-- Local --> 
    <style>
/*******/
/* IDs */
/*******/

#legendInsert, #multiselectInsert {
    bottom: 0px;
    position: absolute;
    right: 0px;
}
#modalInsert {
    align-items: center;
    background-color: rgba(0,0,0,0.4);
    display: none;
    /* The modalInsert div needs a height in order for inner divs to be able to use percentage values for max-height */
    height: 100%; /* DO NOT CHANGE THIS */
    justify-content: center;
    position: absolute;
    /*top: calc(var(--headerHeight));*/
    top: 0;
    width: 100%;
    /* z-index is is needed to cover the sideNav */
    z-index: 2;

}
#modalInsert.visible {
    display: flex;
}

/******************/
/* Shared classes */
/******************/

.absolute {
    position: absolute;
}
.horizontalFlex {
    display: flex;
}
button.horizontalFlex {
    /* HACK: hard-code height for buttons in modals */
    min-height: 28.8px;
}
div.horizontalFlex { 
    min-height: var(--tableRowMinHeight);
}
.verticalFlex {
    display: flex;
    flex-direction: column;
}
.centerMainAxisFlex {
    justify-content: center;;
}
.centerCrossAxisFlex {
    align-items: center;
}
.hoverable:hover {
    background-color: seagreen;
    color: white;
}
.halfWidth {
    width: 50%;
}
.fullWidth {
    width: 100%;
}
.indent1 {
    padding: 0 0 0 var(--regularFontSize);
    text-align: left;
}
.indent2 {
    padding: 0 0 0 calc(2 * var(--regularFontSize)); 
    text-align: left;
}

/* TODO use media queries to set max-width based on screen size. Don't create additional classes. 50% max width is fine in 90% of cases */
/**********************************************/
/* Default styling. BE CAREFUL WHEN CHANGING! */
/**********************************************/

div.js-div--modal {
    /* Material design says that the background color doesn't affect brand, so it should be plain white */
    background: #FFFFFF;
    /* Material design uses 4dp rounded corners. 5px looks close enough */
    border-radius: 5px;
    /* Only overflowing modals (e.g. the "Load Feeder" modal) need a height of 100%. Unfortunately, this height must be set to 100% so that
    overflowing modals may constrain themselves. The majority of modals will need to set their height back "initial" */
    height: 100%;
    max-height: 75vh;
    max-width: 75vw;
    /* Don't add padding because it lets stuff scroll above a sticky thead */
    /*padding: 1rem;*/
    overflow: auto;
    width: 100%;
}
div.js-div--modal.fitContent {
    height: initial;
    width: initial;
}
div.js-div--modal.outerModal {
    padding: 1rem;
}
div.js-div--modal.collapsed {
    max-height: 0;
    overflow: hidden;
    /*transition: max-height 10s ease;*/
}
div.js-div--modal.expanded {
    /* This property and the "expanded" class exist to prevent the scrollbar from appearing while the div is expanding */
    overflow: hidden;
    /*transition: max-height .2s;*/
}
div.js-div--modal button {
    background-color: mediumblue;
    border: none;
    border-radius: 5px;
    color: white;
    cursor: pointer;
    max-width: 400px;
    padding: .15rem;
    z-index: 1;
}
div.js-div--modal button:hover {
    background-color: blue;
}
div.js-div--modal button.delete {
    background-color: crimson;
}
div.js-div--modal button.delete:hover {
    background-color: red;
}
div.js-div--modal button.add {
    background-color: seagreen;
}
div.js-div--modal button.add:hover {
    background-color: mediumseagreen;
}
div.js-div--modal button:disabled {
    background-color: gray;
}
div.js-div--modal input {
    border: 1px solid black;
    font-size: var(--regularFontSize);
    margin: 0;
    padding: .2rem;
    width: 100%;
}
div.js-div--modal select {
    background-color: #FFFFFF;
    border: 1px solid black;
    border-radius: 5px;
    font-size: var(--regularFontSize);
    padding: .2rem;
    /* width cannot be 100% for all modals because of big modal like anonymization */
}
div.js-div--modal span {
    font-size: var(--regularFontSize);
}
div.js-div--modal textarea {
    font-size: var(--regularFontSize);
    height: 100%;
    height: calc(100% - 84px);
    width: 100%;
}
div.js-div--modal table.table--modal span {
    width: 100%;
}
div.div--modalBanner {
    border-radius: 5px;
    font-size: 24px;
    padding: 1rem;
    text-align: center;
}
div.div--modalBanner.caution {
    background-color: hsla(50, 100%, 70%, 1);
}
div.div--modalBanner.hidden {
    display: none;
}
div.div--modalTitle span {
    /* This is 43px tall */
    font-size: 26px;
    font-weight: bold;
    padding: var(--regularFontPadding);
}
div.div--modalTitle.caution {
    background-color: hsla(50, 100%, 70%, 1);
}
div.div--modalElementContainer {
    height: 100%;
    /* HACK: I should know how to subtract 100% of the height to get an actual height instead of guessing. This should be 92% default because that
    makes the "Load Feeder" modal take up most of the space without leaving a big white zone at the bottom. The problem is the title takes up space in
    a modal element container, so I can't just use 100%. 92% is actually fine. Use custom CSS for one-offs like the attachments modal. 89% works too.
    */
    max-height: calc(100% - 43px);
    width: 100%;
}
table.table--modal {
    border-collapse: collapse;
    font-size: var(--regularFontSize);
    position: relative;
    table-layout: fixed;
    text-align: left;
    word-wrap: break-word;
}
table.table--modal.centeredTable {
    margin: auto;
}
table.table--modal td div, table.table--modal th div {
    display: flex;
    align-items: center;
    min-height: var(--tableRowMinHeight);
}
table.table--modal td, table.table--modal th {
    padding: 0;
}
table.table--modal td:not(:first-child), table.table--modal th:not(:first-child) {
    padding: 0 0 0 var(--regularFontPadding);
}
table.table--modal thead {
    background: white;
    position: sticky;
    top: 0;
}

/****************************/
/* FeatureEditModal styling */
/****************************/

div.js-div--modal.featureEditModal {
    max-height: 70vh;
}
div.js-div--modal.featureEditModal table.table--modal td:nth-child(2) {
    max-width: 160px;
    width: 160px;
}

/***********************/
/* SearchModal styling */
/***********************/

div.js-div--modal.searchModal {
    border-radius: 0;
    box-shadow: inset -1px 0px darkgray;
    max-height: 20vh;
}
div.js-div--modal.searchModal div.div--modalElementContainer {
    height: initial;
}
div.js-div--modal.searchModal select {
    width: 100%;
}
div.js-div--modal.searchModal table.table--modal td:first-child {
    max-width: 32px;
    width: 32px;
}
div.js-div--modal.searchModal table.table--modal td:nth-child(2) {
    max-width: 50px;
    width: 50px;
}
div.js-div--modal.searchModal table.table--modal td:nth-child(3) {
    max-width: 160px;
    width: 160px;
}
div.js-div--modal.searchModal table.table--modal td:nth-child(4) {
    max-width: 75px;
    width: 75px;
}

/*****************************/
/* Load feeder modal styling */
/*****************************/

div.js-div--modal.loadFeederModal div.div--modalElementContainer div.js-div--modal {
    flex: 1;
}
div.js-div--modal.loadFeederModal table.table--modal td div, div.js-div--modal.loadFeederModal table.table--modal th div {
    display: block;
    min-height: initial;
}
div.js-div--modal.loadFeederModal div.hoverable {
    padding: var(--regularFontPadding);
    word-break: break-word;
}
div.js-div--modal.loadFeederModal div.hoverable > div:first-child {
    font-weight: bold;
}

/*****************************/
/* Color modal styling */
/*****************************/

div.js-div--modal.colorModal table.table--modal button {
    min-width: 145.2px;
}
</style>
<style>

</style>
<style>
* {
    box-sizing: border-box;
    font-family: Helvetica, Arial, Sans-Serif;
}
:root {
    --headerHeight: 50px;
    --regularFontSize: 13px;
    --regularFontPadding: .5rem;
    --sideNavWidth: 485px;
    --sideNavTransitionTime: 0.3s;
    --tableRowMinHeight: 2rem;
}

/*******/
/* IDs */
/*******/

#map {
    height: calc(100vh - var(--headerHeight));
    z-index: 0;
}
#menuInsert {
    display: flex;
    position: absolute;
    right: 10px;
    top: 5px;
    z-index: 1;
}

/************/
/* Elements */
/************/

a {
    text-decoration: none;
    color: #00b11a;
}
body {
    height: 100vh;
    margin: 0;
}
header {
    background: black;
    display: flex;
    height: var(--headerHeight);
    /*justify-content: space-between;*/
    /* If I don't make the header absolutely positioned, I can remove the margin from <main></main>*/
    /*position: fixed;*/
    /*top: 0;*/
    width: 100%;
    z-index: 1;
}
main {
    /* This isn't needed anymore, but keep it in case */
    /*margin: var(--headerHeight) 0 0 0;*/
    /* Is this needed ? */
    height: calc(100% - var(--headerHeight));
}

/***********/
/* Classes */
/***********/

.leaflet-popup-content {
    width: 330px !important;
    font-family: sans-serif;
}
.leaflet-custom-control-button {
    background-color: #FFFFFF;
    border: none;
    border-radius: 4px;
    color: black;
    cursor: pointer;
    padding: .25rem;
}
</style>
<style>
.leaflet-customControlDiv {
    height: 35px;
    width: 35px;
}
</style>
<style>
article.js-article--sideNavArticle {
    /* Set position:relative; so that any absolutely positioned elements within the article don't go out of bounds*/
    position: relative;
    transition: margin-left var(--sideNavTransitionTime);
}
article.js-article--sideNavArticle.compressed {
    margin-left: var(--sideNavWidth);
    transition: margin-left var(--sideNavTransitionTime);
}
nav.js-nav--sideNav {
    background-color: #FFFFFF;
    box-shadow: inset -1px 0px darkgray;
    font-family: sans-serif;
    height: 100%;
    /*overflow-y: auto;*/
    position: fixed;
    transform: translate(calc(var(--sideNavWidth) * -1), 0px);
    transition: transform var(--sideNavTransitionTime);
    width: var(--sideNavWidth);
    z-index: 2;
}
nav.js-nav--sideNav.open {
    transform: translate(0px, 0px);
}
div.js-div--sideNavCover {
    display: none;
    z-index: 1;
}
@media screen and (max-width: 976px) {
    div.js-div--sideNavCover.open {
        background-color: rgba(189, 189, 189, 0.6);
        display: initial;
        height: 100%;
        position: fixed;
        width: 100%;
    }
}
</style>
<style>
/**********************************************/
/* Default styling. BE CAREFUL WHEN CHANGING! */
/**********************************************/
button.js-button--dropdown {
    align-items: center;
    border: 0;
    cursor: pointer;
    display: flex;
    padding: 0;
    width: 100%;
}
div.js-div--dropdown {
    /* Don't set height 100% because I need all three top-level dropdown divs to be up against each other */
    /* Don't set max-height here because it makes FeatureEditModals cover stuff in the side bar */
    /* This is done to make search results not have a weird horizontal bar pop up, but I can't set this here because it screws up the file menu */
    /*overflow-x: hidden;*/
}
div.js-div--dropdown span {
    font-size: var(--regularFontSize);
}
div.js-div--dropdownContent {
    max-height: 0;
    overflow: hidden;
}
div.js-div--dropdownContent.expanded {
    max-height: 100%;
    overflow: auto;
}
svg.js-svg--dropdown {
    transform: rotate(0deg);
    transition: transform 0.25s ease;
}
svg.js-svg--dropdown.rotated {
    transform: rotate(90deg);
    transition: transform 0.25s ease;
}

/********************/
/* Side nav styling */
/********************/

div.js-div--dropdown.sideNav {
    overflow-x: hidden;
}
div.js-div--dropdown.sideNav button.js-button--dropdown {
    background-color: #FFFFFF;
    border-top: 1px solid black;
    justify-content: space-between;
    padding: .5rem 0 .5rem 0;
}
/* This is the search results div */
div.selected > div:nth-child(2) {
    /* HACK: hardcoded height */
    max-height: 69vh;
    overflow: auto;
}
div.selected div.js-div--dropdown.sideNav.searchCategory > button.js-button--dropdown {
    box-shadow: inset -1px 0px darkgray;
}
div.js-div--dropdown.sideNav span > div:first-child {
    font-weight: bold;
}
div.js-div--dropdown.sideNav.searchCategory > button.js-button--dropdown > span {
    padding: 0 0 0 var(--regularFontSize);
    text-align: left;
}
div.js-div--dropdown.sideNav button.horizontalFlex span {
    padding: 0;
}

/****************/
/* Menu styling */
/****************/

div.js-div--dropdown.menu {
    white-space: nowrap;
    width: 85px;
}
div.js-div--dropdown.menu button.js-button--dropdown {
    background-color: transparent;
    color: white;
    justify-content: end;
}
div.js-div--dropdown.menu button.js-button--dropdown.expanded {
    background-color: #FFFFFF;
    border-radius: 5px 5px 0px 0px;
    color: black
}
div.js-div--dropdown.menu button.js-button--dropdown svg.js-svg--dropdown path {
    fill: white;
}
div.js-div--dropdown.menu button.js-button--dropdown.expanded svg.js-svg--dropdown path {
    fill: black;
}
div.js-div--dropdown.menu div.js-div--dropdownContent {
    background-color: #FFFFFF;
    border-radius: 5px 0px 5px 5px;
    float: right;
    overflow-x: visible;
}
div.js-div--dropdown.menu div.js-div--dropdownContent.expanded {
    box-shadow: 0 10px 14px rgba(0,0,0,0.4)
}
div.js-div--dropdown.menu div.js-div--dropdownContent div {
    font-size: var(--regularFontSize);
    padding: 0 .25rem 0 .25rem;
}
</style>
<style>
nav.js-nav--topNav {
    background: black;
    display: flex;
    height: 100%;
}
nav.js-nav--topNav a {
    text-decoration: none;
}
nav.js-nav--topNav button {
    background-color: transparent;
    border: 0;
    /*cursor: pointer;*/
    padding: 14px;
    width: var(--headerHeight);
}
/*nav.js-nav--topNav button:hover {
    background-color: gray;
    transition: background-color 0.2s ease-out;
}*/
nav.js-nav--topNav div {
    align-items: center;
    display: flex;
    /* This padding was added because David removed the hamburger menu */
    padding: 0 0 0 10px;
}
nav.js-nav--topNav span {
    color: white;
    font-size: 26px;
}
nav.js-nav--topNav svg path {
    fill: white;
}
</style>
<style>
/**********************************************/
/* Default styling. BE CAREFUL WHEN CHANGING! */
/**********************************************/
div.div--topTab {
    height: 100%;
}
div.div--topTabTabContainer {
    /*background: hsla(360, 0%, 87%, 1);*/
    /*box-shadow: inset -1px 0px darkgray;*/
    /*display: flex;*/
    /*height: 2rem;*/
    text-align: center;
}
div.div--topTabTabContainer > div {
    /*cursor: pointer;*/
    display: none;
    z-index: 0;
}
div.div--topTabTabContainer > div.selected {
    display: block;
    padding: 14px;
    z-index: 1;
}
div.div--topTabTabContainer > div.selected > button {
    background-color: transparent;
    border: 0;
    color: #757575;
    cursor: pointer;
    height: 24px;
    position: absolute;
    right: 0;
    top: 0;
    width: 24px;
}
div.div--topTabTabContainer > div.selected > span {
    font-weight: bold;
}
div.div--topTabTabContainer > div.selected > span::before {
    background: #FFFFFF; /* This is the color of the selected tab */
}
div.div--topTabTabContainer > div > span {
    font-size: 26px;
    /*margin: 0 10px 0 10px;*/
    /*padding: 0 0 2px 0;*/
    /*position: relative;*/
}
div.div--topTabTabContainer > div > span::before {
    /* This is the color of unselected tabs */
    /*background: hsla(360, 0%, 87%, 1);*/
    /*border: 1px solid black;*/
    /*border-bottom: none;*/
	/*border-radius: 10px 10px 0 0;*/
    /*bottom: -4px;*/
    /*content: '';*/
    /*left: -10px;*/
    /*position: absolute;*/
    /*right: -10px;*/
    /*top: -2px;*/
    /* I don't want curves anymore */
    /*transform: perspective(10px) rotateX(2deg);*/
    /*transform-origin: bottom;*/
    z-index: -1;
}
div.div--topTabContentContainer {
    background: #FFFFFF; /* This is the background of the tab content */
    box-shadow: inset -1px 0px darkgray;
    height: 100%;
    position: relative;
    /*box-shadow: inset 0 1px 0 0 black;*/
    /*box-shadow: 0 10px 10px -5px black;*/
    /* Match Leaflet box shadow */
    /*box-shadow: 0 3px 14px rgba(0,0,0,0.4);*/
}
div.div--topTabContentContainer > div {
    display: none;
}
div.div--topTabContentContainer > div.selected {
   display: block;
   height: 100%;
}

/* Are there topTab styling variations? Not yet */
</style>
<style>
.leaflet-ruler{
    height: 35px;
    width: 35px;
    background-image: url("./protractor.png"); /* <div>Icons made by <a href="http://www.freepik.com" title="Freepik">Freepik</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a> is licensed by <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a></div> */
    background-repeat: no-repeat;
    background-position: center;
  }
  .leaflet-ruler:hover{
    background-image: url("./protractor-colored.png"); /* <div>Icons made by <a href="http://www.freepik.com" title="Freepik">Freepik</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a> is licensed by <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a></div> */
  }
  .leaflet-ruler-clicked{
    height: 35px;
    width: 35px;
    background-repeat: no-repeat;
    background-position: center;
    background-image: url("./protractor-colored.png");
    border-color: chartreuse !important;
  }
  .leaflet-bar{
    background-color: #ffffff;
  }
  .leaflet-control {
    cursor: pointer;
  }
  .result-tooltip{
    background-color: white;
    border-width: medium;
    border-color: #de0000;
    font-size: smaller;
  }
  .moving-tooltip{
    background-color: rgba(255, 255, 255, .7);
    background-clip: padding-box;
    opacity: 0.5;
    border: dotted;
    border-color: red;
    font-size: smaller;
  }
  .plus-length{
    padding-left: 45px;
  }
</style>
<style>
#modalInsert {
    align-items: center;
    background-color: rgba(0,0,0,0.4);
    display: none;
    /* The modalInsert div needs a height in order for inner divs to be able to use percentage values for max-height */
    height: 100%; /* DO NOT CHANGE THIS */
    justify-content: center;
    position: absolute;
    /*top: calc(var(--headerHeight));*/
    top: 0;
    width: 100%;
    /* z-index is is needed to cover the sideNav */
    z-index: 2;

}
#modalInsert.visible {
    display: flex;
}

/* Support for renderReadOnlyModal */
div.leaflet-popup-content div.js-div--modal.featureEditModal {
    border-radius: 0px;
}
table.plainTable td, table.plainTable th {
    border: 0px solid black;
}
div.js-div--modal.featureEditModal table.table--modal.plainTable td:nth-child(2) {
    max-width: initial;
    width: initial;
}
table.table--modal.plainTable td, table.table--modal.plainTable th {
    padding: .25rem;
}


</style>

    <meta charset="utf-8">
    <title>OMF GeoJSON Editor</title>
  </head>
  <body>
    <header>
        <div id="menuInsert"></div>
    </header>
    <main></main>
    <script>
        'use strict';
        const gFeatureCollection = {"type": "FeatureCollection", "features": [{"type": "Feature", "geometry": {"coordinates": [null, null], "type": "Point"}, "properties": {"treeKey": "omd", "links": [], "hiddenLinks": [], "nodes": [], "hiddenNodes": [], "layoutVars": {"theta": "0.8", "gravity": "0.01", "friction": "0.9", "linkStrength": "5", "linkDistance": "5", "charge": "-5"}, "attachments": {"coloringFiles": {"color_by_traditional.csv": {"csv": "bus,max_kw\n611,1\n634,1\n645,1\n646,1\n652,1\n670,1\n675,1\n684,1\n692,1\n", "colorOnLoadColumnIndex": "1"}}}, "syntax": "DSS"}}, {"type": "Feature", "properties": {"treeKey": "1", "treeProps": {"object": "!CMD", "name": "clear"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "2", "treeProps": {"object": "!CMD", "name": "set", "defaultbasefrequency": "60"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "3", "treeProps": {"object": "circuit", "name": "lehigh", "parent": "sourcebus", "basekv": "115", "pu": "1.0001", "phases": "3", "angle": "30", "mvasc3": "20000", "mvasc1": "21000"}}, "geometry": {"coordinates": [-84.07145636372728, 30.285209615827238], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "4", "treeProps": {"object": "vsource", "name": "source", "parent": "sourcebus", "!CONNCODE": ".1.2.3", "!CMD": "edit", "basekv": "115", "pu": "1.00", "r1": "0", "x1": "0.0001", "r0": "0", "x0": "0.0001"}}, "geometry": {"coordinates": [-84.07168932017986, 30.285051188833222], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "5", "treeProps": {"object": "vsource", "name": "secondsource", "parent": "680", "basekv": "4.16", "pu": "1.00", "r1": "0", "x1": "0.0001", "r0": "0", "x0": "0.0001", "!CONNCODE": ".1.2.3"}}, "geometry": {"coordinates": [-84.07529664608523, 30.285051014999134], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "6", "treeProps": {"object": "transformer", "name": "sub", "from": "sourcebus", "to": "650", "phases": "3", "windings": "2", "xhl": "0.008", "conns": "[delta,wye]", "kvs": "[115,4.16]", "kvas": "[5000,5000]", "%rs": "[0.0005,0.0005]", "!FROCODE": ".1.2.3", "!TOCODE": ".1.2.3"}}, "geometry": {"coordinates": [[-84.071493, 30.285013], [-84.071993, 30.285013]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "7", "treeProps": {"object": "transformer", "name": "reg1", "from": "650", "to": "rg60", "phases": "1", "bank": "reg1", "xhl": "0.01", "kvas": "[1666,1666]", "kvs": "[2.4,2.4]", "%loadloss": "0.01", "!FROCODE": ".1", "!TOCODE": ".1"}}, "geometry": {"coordinates": [[-84.071993, 30.285013], [-84.072493, 30.285013]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "8", "treeProps": {"object": "regcontrol", "name": "reg1", "transformer": "reg1", "winding": "2", "vreg": "121", "band": "2", "ptratio": "20", "ctprim": "700", "r": "3", "x": "9"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "9", "treeProps": {"object": "transformer", "name": "reg2", "from": "650", "to": "rg60", "phases": "1", "bank": "reg1", "xhl": "0.01", "kvas": "[1666,1666]", "kvs": "[2.4,2.4]", "%loadloss": "0.01", "!FROCODE": ".2", "!TOCODE": ".2"}}, "geometry": {"coordinates": [[-84.071993, 30.285013], [-84.072493, 30.285013]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "10", "treeProps": {"object": "regcontrol", "name": "reg2", "transformer": "reg2", "winding": "2", "vreg": "121", "band": "2", "ptratio": "20", "ctprim": "700", "r": "3", "x": "9"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "11", "treeProps": {"object": "transformer", "name": "reg3", "from": "650", "to": "rg60", "phases": "1", "bank": "reg1", "xhl": "0.01", "kvas": "[1666,1666]", "kvs": "[2.4,2.4]", "%loadloss": "0.01", "!FROCODE": ".3", "!TOCODE": ".3"}}, "geometry": {"coordinates": [[-84.071993, 30.285013], [-84.072493, 30.285013]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "12", "treeProps": {"object": "regcontrol", "name": "reg3", "transformer": "reg3", "winding": "2", "vreg": "121", "band": "2", "ptratio": "20", "ctprim": "700", "r": "3", "x": "9"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "13", "treeProps": {"object": "transformer", "name": "xfm1", "from": "633", "to": "634", "phases": "3", "windings": "2", "xhl": "2", "conns": "[wye,wye]", "kvs": "[4.16,0.480]", "kvas": "[500,500]", "%rs": "[0.55,0.55]", "xht": "1", "xlt": "1", "!FROCODE": ".1.2.3", "!TOCODE": ".1.2.3"}}, "geometry": {"coordinates": [[-84.072993, 30.286513], [-84.072993, 30.287013]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "14", "treeProps": {"object": "linecode", "name": "mtx601", "nphases": "3", "basefreq": "60", "rmatrix": "[0.3465|0.1560,0.3375|0.1580,0.1535,0.3414]", "xmatrix": "[1.0179|0.5017,1.0478|0.4236,0.3849,1.0348]", "units": "mi"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "15", "treeProps": {"object": "linecode", "name": "mtx602", "nphases": "3", "basefreq": "60", "rmatrix": "[0.7526|0.1580,0.7475|0.1560,0.1535,0.7436]", "xmatrix": "[1.1814|0.4236,1.1983|0.5017,0.3849,1.2112]", "units": "mi"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "16", "treeProps": {"object": "linecode", "name": "mtx603", "nphases": "2", "basefreq": "60", "rmatrix": "[1.3238|0.2066,1.3294]", "xmatrix": "[1.3569|0.4591,1.3471]", "units": "mi"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "17", "treeProps": {"object": "linecode", "name": "mtx604", "nphases": "2", "basefreq": "60", "rmatrix": "[1.3238|0.2066,1.3294]", "xmatrix": "[1.3569|0.4591,1.3471]", "units": "mi"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "18", "treeProps": {"object": "linecode", "name": "mtx605", "nphases": "1", "basefreq": "60", "rmatrix": "[1.3292]", "xmatrix": "[1.3475]", "units": "mi"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "19", "treeProps": {"object": "linecode", "name": "mtx606", "nphases": "3", "units": "mi", "rmatrix": "[0.791721|0.318476,0.781649|0.28345,0.318476,0.791721]", "xmatrix": "[0.438352|0.0276838,0.396697|-0.0184204,0.0276838,0.438352]", "cmatrix": "[383.948|0,383.948|0,0,383.948]"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "20", "treeProps": {"object": "linecode", "name": "mtx607", "nphases": "1", "basefreq": "60", "rmatrix": "[1.3425]", "xmatrix": "[0.5124]", "cmatrix": "[236]", "units": "mi"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "21", "treeProps": {"object": "load", "name": "684_command_center", "parent": "684", "phases": "1", "conn": "wye", "model": "1", "kv": "2.4", "kw": "1155", "kvar": "660", "!CONNCODE": ".3"}}, "geometry": {"coordinates": [-84.07459117221342, 30.284187247572483], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "22", "treeProps": {"object": "load", "name": "634a_data_center", "parent": "634", "phases": "1", "conn": "wye", "model": "1", "kv": "0.277", "kw": "160", "kvar": "110", "!CONNCODE": ".1"}}, "geometry": {"coordinates": [-84.07280122788484, 30.28695622451366], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "23", "treeProps": {"object": "load", "name": "634b_radar", "parent": "634", "phases": "1", "conn": "wye", "model": "1", "kv": "0.277", "kw": "120", "kvar": "90", "!CONNCODE": ".1"}}, "geometry": {"coordinates": [-84.07315784490103, 30.286899747368242], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "24", "treeProps": {"object": "load", "name": "634c_atc_tower", "parent": "634", "phases": "1", "conn": "wye", "model": "1", "kv": "0.277", "kw": "120", "kvar": "90", "!CONNCODE": ".1"}}, "geometry": {"coordinates": [-84.07292253284467, 30.286825825268746], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "25", "treeProps": {"object": "load", "name": "645_hangar", "parent": "645", "phases": "1", "conn": "wye", "model": "1", "kv": "2.4", "kw": "170", "kvar": "125", "!CONNCODE": ".2"}}, "geometry": {"coordinates": [-84.07279648783982, 30.283975811683213], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "26", "treeProps": {"object": "load", "name": "646_office", "parent": "646", "phases": "1", "conn": "wye", "model": "2", "kv": "2.4", "kw": "230", "kvar": "132", "!CONNCODE": ".2"}}, "geometry": {"coordinates": [-84.07312857524731, 30.283160035207743], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "27", "treeProps": {"object": "load", "name": "692_warehouse2", "parent": "692", "phases": "3", "conn": "delta", "model": "5", "kv": "2.4", "kw": "170", "kvar": "151", "!CONNCODE": ".1.2.3"}}, "geometry": {"coordinates": [-84.07468887125547, 30.285553428347498], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "28", "treeProps": {"object": "load", "name": "675a_hospital", "parent": "675", "phases": "3", "conn": "wye", "model": "1", "kv": "2.4", "kw": "485", "kvar": "190", "!CONNCODE": ".1.2.3"}}, "geometry": {"coordinates": [-84.07444315755215, 30.287206689778753], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "29", "treeProps": {"object": "load", "name": "675b_residential1", "parent": "675", "phases": "3", "conn": "wye", "model": "1", "kv": "2.4", "kw": "68", "kvar": "60", "!CONNCODE": ".1.2.3"}}, "geometry": {"coordinates": [-84.0743320892183, 30.286894224075123], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "30", "treeProps": {"object": "load", "name": "675c_residential1", "parent": "675", "phases": "3", "conn": "wye", "model": "1", "kv": "2.4", "kw": "290", "kvar": "212", "!CONNCODE": ".1.2.3"}}, "geometry": {"coordinates": [-84.07450686060581, 30.28681348086907], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "31", "treeProps": {"object": "load", "name": "611_runway", "parent": "611", "phases": "1", "conn": "wye", "model": "5", "kv": "2.4", "kw": "170", "kvar": "80", "!CONNCODE": ".3"}}, "geometry": {"coordinates": [-84.0744395596754, 30.282820271871003], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "32", "treeProps": {"object": "load", "name": "652_residential", "parent": "652", "phases": "1", "conn": "wye", "model": "2", "kv": "2.4", "kw": "128", "kvar": "86", "!CONNCODE": ".3"}}, "geometry": {"coordinates": [-84.07533202049304, 30.28389431723655], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "33", "treeProps": {"object": "load", "name": "670a_residential2", "parent": "670", "phases": "1", "conn": "wye", "model": "1", "kv": "2.4", "kw": "17", "kvar": "10", "!CONNCODE": ".1"}}, "geometry": {"coordinates": [-84.07335606837911, 30.285158772875402], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "34", "treeProps": {"object": "load", "name": "670b_residential2", "parent": "670", "phases": "1", "conn": "wye", "model": "1", "kv": "2.4", "kw": "66", "kvar": "38", "!CONNCODE": ".2"}}, "geometry": {"coordinates": [-84.07333293541078, 30.28489308616728], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "35", "treeProps": {"object": "load", "name": "670c_residential2", "parent": "670", "phases": "1", "conn": "wye", "model": "1", "kv": "2.4", "kw": "117", "kvar": "68", "!CONNCODE": ".3"}}, "geometry": {"coordinates": [-84.07334744308818, 30.284875838834132], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "36", "treeProps": {"object": "generator", "name": "solar_634_existing", "parent": "634", "phases": "1", "kv": "0.277", "kw": "440", "pf": "1", "!CONNCODE": ".1"}}, "geometry": {"coordinates": [-84.07301157757978, 30.287212135314622], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "37", "treeProps": {"object": "storage", "name": "battery_634_existing", "parent": "634", "phases": "1", "kv": "0.277", "kwrated": "81", "kwhstored": "307", "kwhrated": "307", "dispmode": "follow", "%charge": "100", "%discharge": "100", "%effcharge": "96", "%effdischarge": "96", "%idlingkw": "1", "!CONNCODE": ".1"}}, "geometry": {"coordinates": [-84.0727959026309, 30.2869790496378], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "38", "treeProps": {"object": "generator", "name": "solar_675_existing", "parent": "675", "phases": "3", "kv": "2.4", "kw": "800", "pf": "1", "!CONNCODE": ".1.2.3"}}, "geometry": {"coordinates": [-84.07437213996961, 30.286853648649036], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "39", "treeProps": {"object": "generator", "name": "fossil_684_existing", "parent": "684", "phases": "1", "kw": "81", "pf": "1", "kv": "2.4", "xdp": "0.27", "xdpp": "0.2", "h": "2", "!CONNCODE": ".3"}}, "geometry": {"coordinates": [-84.07457466706069, 30.28383043359784], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "40", "treeProps": {"object": "storage", "name": "battery_684_existing", "parent": "684", "phases": "1", "kv": "2.4", "kwrated": "20", "kwhstored": "100", "kwhrated": "100", "dispmode": "follow", "%charge": "100", "%discharge": "100", "%effcharge": "96", "%effdischarge": "96", "%idlingkw": "1", "!CONNCODE": ".3"}}, "geometry": {"coordinates": [-84.07458572720296, 30.283835794848176], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "41", "treeProps": {"object": "generator", "name": "fossil_646_existing", "parent": "646", "phases": "1", "kw": "145", "pf": "1", "kv": "2.4", "xdp": "0.27", "xdpp": "0.2", "h": "2", "!CONNCODE": ".2"}}, "geometry": {"coordinates": [-84.07283260975919, 30.28313247790865], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "42", "treeProps": {"object": "capacitor", "name": "cap1", "parent": "675", "phases": "3", "kvar": "600", "kv": "2.4"}}, "geometry": {"coordinates": [-84.07447442646037, 30.287212135691494], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "43", "treeProps": {"object": "capacitor", "name": "cap2", "parent": "611", "phases": "1", "kvar": "100", "kv": "2.4", "!CONNCODE": ".3"}}, "geometry": {"coordinates": [-84.07429318804863, 30.283004329124235], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "44", "treeProps": {"object": "line", "name": "670671", "from": "670", "to": "671", "!FROCODE": ".1.2.3", "!TOCODE": ".1.2.3", "phases": "3", "linecode": "mtx601", "length": "1333", "units": "ft"}}, "geometry": {"coordinates": [[-84.073493, 30.285013], [-84.074493, 30.285013]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "45", "treeProps": {"object": "line", "name": "645646", "from": "645", "to": "646", "!FROCODE": ".2", "!TOCODE": ".2", "phases": "1", "linecode": "mtx603", "length": "300", "units": "ft"}}, "geometry": {"coordinates": [[-84.072993, 30.284013], [-84.072993, 30.283013]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "46", "treeProps": {"object": "line", "name": "692675", "from": "692", "to": "675", "!FROCODE": ".1.2.3", "!TOCODE": ".1.2.3", "phases": "3", "linecode": "mtx606", "length": "500", "units": "ft"}}, "geometry": {"coordinates": [[-84.074493, 30.285513], [-84.074493, 30.287013]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "47", "treeProps": {"object": "line", "name": "684611", "from": "684", "to": "611", "!FROCODE": ".3", "!TOCODE": ".3", "phases": "1", "linecode": "mtx605", "length": "300", "units": "ft"}}, "geometry": {"coordinates": [[-84.074493, 30.284013], [-84.074493, 30.283013]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "48", "treeProps": {"object": "line", "name": "684652", "from": "684", "to": "652", "!FROCODE": ".3", "!TOCODE": ".3", "phases": "1", "linecode": "mtx607", "length": "800", "units": "ft"}}, "geometry": {"coordinates": [[-84.074493, 30.284013], [-84.075493, 30.284013]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "49", "treeProps": {"object": "line", "name": "671692", "from": "671", "to": "692", "!FROCODE": ".1.2.3", "!TOCODE": ".1.2.3", "phases": "3", "switch": "y", "r1": "1e-4", "r0": "1e-4", "x1": "0.000", "x0": "0.000", "c1": "0.000", "c0": "0.000"}}, "geometry": {"coordinates": [[-84.074493, 30.285013], [-84.074493, 30.285513]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "50", "treeProps": {"object": "line", "name": "632633", "from": "632", "to": "633", "!FROCODE": ".1", "!TOCODE": ".1", "phases": "1", "switch": "y", "linecode": "mtx602", "length": "500", "units": "ft"}}, "geometry": {"coordinates": [[-84.072993, 30.285013], [-84.072993, 30.286513]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "51", "treeProps": {"object": "line", "name": "671684", "from": "671", "to": "684", "!FROCODE": ".3", "!TOCODE": ".3", "phases": "1", "switch": "y", "linecode": "mtx604", "length": "300", "units": "ft"}}, "geometry": {"coordinates": [[-84.074493, 30.285013], [-84.074493, 30.284013]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "52", "treeProps": {"object": "line", "name": "632645", "from": "632", "to": "645", "!FROCODE": ".2", "!TOCODE": ".2", "phases": "1", "switch": "y", "linecode": "mtx603", "length": "500", "units": "ft"}}, "geometry": {"coordinates": [[-84.072993, 30.285013], [-84.072993, 30.284013]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "53", "treeProps": {"object": "line", "name": "632670", "from": "632", "to": "670", "!FROCODE": ".1.2.3", "!TOCODE": ".1.2.3", "phases": "3", "switch": "y", "linecode": "mtx601", "length": "667", "units": "ft"}}, "geometry": {"coordinates": [[-84.072993, 30.285013], [-84.073493, 30.285013]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "54", "treeProps": {"object": "line", "name": "650632", "from": "rg60", "to": "632", "!FROCODE": ".1.2.3", "!TOCODE": ".1.2.3", "phases": "3", "switch": "y", "linecode": "mtx601", "length": "2000", "units": "ft"}}, "geometry": {"coordinates": [[-84.072493, 30.285013], [-84.072993, 30.285013]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "55", "treeProps": {"object": "line", "name": "671680", "from": "671", "to": "680", "!FROCODE": ".1.2.3", "!TOCODE": ".1.2.3", "phases": "3", "switch": "y", "linecode": "mtx601", "length": "1000", "units": "ft"}}, "geometry": {"coordinates": [[-84.074493, 30.285013], [-84.075493, 30.285013]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "57", "treeProps": {"object": "!CMD", "name": "makebuslist"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "58", "treeProps": {"object": "bus", "name": "sourcebus"}}, "geometry": {"coordinates": [-84.071493, 30.285013], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "59", "treeProps": {"object": "bus", "name": "650"}}, "geometry": {"coordinates": [-84.071993, 30.285013], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "60", "treeProps": {"object": "bus", "name": "rg60"}}, "geometry": {"coordinates": [-84.072493, 30.285013], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "61", "treeProps": {"object": "bus", "name": "646"}}, "geometry": {"coordinates": [-84.072993, 30.283013], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "62", "treeProps": {"object": "bus", "name": "645"}}, "geometry": {"coordinates": [-84.072993, 30.284013], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "63", "treeProps": {"object": "bus", "name": "632"}}, "geometry": {"coordinates": [-84.072993, 30.285013], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "64", "treeProps": {"object": "bus", "name": "633"}}, "geometry": {"coordinates": [-84.072993, 30.286513], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "65", "treeProps": {"object": "bus", "name": "634"}}, "geometry": {"coordinates": [-84.072993, 30.287013], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "66", "treeProps": {"object": "bus", "name": "670"}}, "geometry": {"coordinates": [-84.073493, 30.285013], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "67", "treeProps": {"object": "bus", "name": "611"}}, "geometry": {"coordinates": [-84.074493, 30.283013], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "68", "treeProps": {"object": "bus", "name": "684"}}, "geometry": {"coordinates": [-84.074493, 30.284013], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "69", "treeProps": {"object": "bus", "name": "671"}}, "geometry": {"coordinates": [-84.074493, 30.285013], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "70", "treeProps": {"object": "bus", "name": "692"}}, "geometry": {"coordinates": [-84.074493, 30.285513], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "71", "treeProps": {"object": "bus", "name": "675"}}, "geometry": {"coordinates": [-84.074493, 30.287013], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "72", "treeProps": {"object": "bus", "name": "652"}}, "geometry": {"coordinates": [-84.075493, 30.284013], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "73", "treeProps": {"object": "bus", "name": "680"}}, "geometry": {"coordinates": [-84.075493, 30.285013], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "74", "treeProps": {"object": "!CMD", "name": "set", "voltagebases": "[115,4.16,0.48]"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "75", "treeProps": {"object": "!CMD", "name": "calcvoltagebases"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}]};
        const gComponentsCollection = {"type": "FeatureCollection", "features": [{"type": "Feature", "properties": {"treeKey": "component:1", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.01142 ft", "conductor_resistance": "0.88704 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0489686771417213 ft", "outer_diameter": "1.27 in", "neutral_strands": "16.0", "neutral_resistance": "13.86528 ohm/kft", "rating.summer.continuous": "142.0 A", "neutral_diameter": "0.0641 in", "conductor_diameter": "0.362", "shield_gmr": "0.00 ft", "name": "R1_12_47_2_Conc_1_0_AAC"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:2", "componentType": "gridlabd", "treeProps": {"powerC_rating": "30.0 kVA", "name": "R1_12_47_1_3122", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00500 Ohm", "shunt_impedance": "350.040+357.513j", "reactance": "0.00333 Ohm", "power_rating": "30.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:3", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1431", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00200 Ohm", "shunt_impedance": "443.910+433.525j", "reactance": "0.00133 Ohm", "powerA_rating": "75.0 kVA", "power_rating": "75.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:4", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.592167Ohm/km", "name": "oh_1/0_ALQPX", "geometric_mean_radius": "0.347980cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:5", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0373 ft", "conductor_resistance": "0.0263 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.118 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "608 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.108 in", "shield_gmr": "0.00 ft", "name": "DG_750ALTRXLPE15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:6", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.349770Ohm/km", "name": "oh_4/0_ACSR_6/1", "geometric_mean_radius": "0.248920cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:7", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0395 ft", "conductor_resistance": "0.0141 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.175 in", "neutral_strands": "9", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "725 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.165 in", "shield_gmr": "0.00 ft", "name": "DG_1000"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:8", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_2_0CUB7"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:9", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_4_0ALTRXPECN15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:10", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.240036Ohm/km", "name": "oh_3/0_CU", "geometric_mean_radius": "0.427990cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:11", "componentType": "gridlabd", "treeProps": {"powerC_rating": "30.0 kVA", "name": "R1_12_47_2_1463", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00500 Ohm", "shunt_impedance": "350.040+346.288j", "reactance": "0.00333 Ohm", "power_rating": "30.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:12", "componentType": "gridlabd", "treeProps": {"name": "AG_1_0CN25", "conductor_resistance": "0.6070 ohm/kft", "object": "underground_line_conductor", "shield_resistance": "0.0000 Ohm/mile", "neutral_gmr": "0.0021 ft", "outer_diameter": "0.8380 in", "neutral_strands": "25.0000", "neutral_resistance": "14.8722 ohm/kft", "neutral_diameter": "0.0641 in", "conductor_diameter": "0.3680 in", "shield_gmr": "0.0000 ft", "conductor_gmr": "0.0111 ft"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:13", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0175 ft", "conductor_resistance": "0.063 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.5618 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.5518 in", "shield_gmr": "0.00 ft", "name": "DG_4_0CUB7"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:14", "componentType": "gridlabd", "treeProps": {"object": "triplex_node", "name": "triplex_node", "phases": "ABCN", "nominal_voltage": "120"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:15", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "1.010411Ohm/km", "name": "oh_#2_ACSR_6/1", "geometric_mean_radius": "0.127000cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:16", "componentType": "gridlabd", "treeProps": {"glass_type": "2", "auxiliary_system_type": "ELECTRIC", "cooling_COP": "3.2", "hvac_breaker_rating": "1000", "cooling_system_type": "ELECTRIC", "total_thermal_mass_per_floor_area": "2.5", "auxiliary_strategy": "DEADBAND", "air_temperature": "68", "heating_COP": "2.1", "motor_efficiency": "AVERAGE", "heating_system_type": "HEAT_PUMP", "Rwall": "14.3", "glazing_treatment": "3", "Rdoors": "6.3", "glazing_layers": "2", "window_frame": "4", "parent": "null", "floor_area": "820", "object": "house", "number_of_stories": "1", "mass_temperature": "68", "name": "R1_Apartment_1990-2005", "Rfloor": "12.7", "airchange_per_hour": "0.125", "Rroof": "28.7", "ceiling_height": "8.0", "breaker_amps": "1000", "over_sizing_factor": "0.1", "motor_model": "BASIC"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:17", "componentType": "gridlabd", "treeProps": {"phases": "ABC", "object": "meter", "nominal_voltage": "7200", "name": "three_phase_meter", "parent": "null"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:18", "componentType": "gridlabd", "treeProps": {"name": "DG_10_23_9_13_8_kV_YYB", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.018+0.018j", "power_rating": "10 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:19", "componentType": "gridlabd", "treeProps": {"object": "overhead_line", "name": "overhead_line", "phases": "BCN", "from": "NULL", "to": "NULL", "length": "20", "configuration": "NULL"}}, "geometry": {"coordinates": [[0, 0], [0, 0]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "component:20", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_50000_A", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "500 kVA", "power_rating": "500 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:21", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3090", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+301.925j", "reactance": "0.01 Ohm", "powerA_rating": "5 kVA", "power_rating": "5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:22", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "1.572690Ohm/km", "name": "oh_#4_ACSR_6/1", "geometric_mean_radius": "0.133096cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:23", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.081400Ohm/km", "name": "oh_795_AAC", "geometric_mean_radius": "0.999744cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:24", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_650CUPILC3D15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:25", "componentType": "gridlabd", "treeProps": {"powerC_rating": "0.0 kVA", "name": "R1_12_47_1_3734", "primary_voltage": "12500.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "WYE_WYE", "resistance": "0.00333 Ohm", "shunt_impedance": "350.040+352.463j", "reactance": "0.01667 Ohm", "powerB_rating": "30.0 kVA", "powerA_rating": "0.0 kVA", "power_rating": "30.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:26", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_16700_A", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "167 kVA", "power_rating": "167 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:27", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_1000CUXLPEJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:28", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0395 ft", "conductor_resistance": "0.0141 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.175 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "700 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.165 in", "shield_gmr": "0.00 ft", "name": "DG_1000ALTRXLPELCJ25"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:29", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_15000_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "150 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:30", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_22500_A_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "225 kVA", "power_rating": "225 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:31", "componentType": "gridlabd", "treeProps": {"object": "node", "name": "node", "phases": "ABCN", "nominal_voltage": "2401.7771"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:32", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.121789Ohm/km", "name": "oh_DEFAULT", "geometric_mean_radius": "0.883920cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:33", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_2_0ALXLPE15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:34", "componentType": "gridlabd", "treeProps": {"object": "transformer", "name": "transformer", "phases": "ABCN", "from": "NULL", "to": "NULL", "configuration": "NULL"}}, "geometry": {"coordinates": [[0, 0], [0, 0]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "component:35", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "9", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_350"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:36", "componentType": "gridlabd", "treeProps": {"discharge_off_threshold": "7.5 kW", "phases": "AS", "four_quadrant_control_mode": "LOAD_FOLLOWING", "name": "load_following_inv", "parent": "split_phase_meter", "discharge_lockout_time": "60s", "inverter_type": "FOUR_QUADRANT", "object": "inverter", "sense_object": "triptransformer", "max_charge_rate": "0.80 kW", "charge_off_threshold": "7.0 kW", "rated_power": "3000.0", "charge_lockout_time": "60s", "max_discharge_rate": "1.0 kW", "inverter_efficiency": "0.87", "discharge_on_threshold": "9.0 kW", "charge_on_threshold": "5.0 kW"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:37", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3086", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00240 Ohm", "shunt_impedance": "417.835+411.761j", "reactance": "0.00160 Ohm", "powerA_rating": "62.5 kVA", "power_rating": "62.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:38", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2CUPILCJ3D15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:39", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3091", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.01000 Ohm", "shunt_impedance": "318.750+332.068j", "reactance": "0.00667 Ohm", "powerA_rating": "15.0 kVA", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:40", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2CURR15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:41", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.530030Ohm/km", "name": "oh_2/0_ACSR_6/1", "geometric_mean_radius": "0.154940cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:42", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0395 ft", "conductor_resistance": "0.0141 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.175 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "725 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.165 in", "shield_gmr": "0.00 ft", "name": "DG_1000ALTRXLPEJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:43", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.302821Ohm/km", "name": "oh_4/0_WPAL", "geometric_mean_radius": "0.480568cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:44", "componentType": "gridlabd", "treeProps": {"powerC_rating": "0.0 kVA", "name": "R1_12_47_1_3733", "primary_voltage": "12500.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "WYE_WYE", "resistance": "0.00667 Ohm", "shunt_impedance": "318.750+347.082j", "reactance": "0.03333 Ohm", "powerB_rating": "15.0 kVA", "powerA_rating": "0.0 kVA", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:45", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.592167Ohm/km", "name": "oh_1/0_AAAC", "geometric_mean_radius": "0.347980cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:46", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_400CUPILCJ3D15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:47", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.128002Ohm/km", "name": "oh_BUSS_2000_AMP", "geometric_mean_radius": "0.127000cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:48", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.381335Ohm/km", "name": "oh_1/0_CU", "geometric_mean_radius": "0.339598cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:49", "componentType": "gridlabd", "treeProps": {"tank_volume": "50", "parent": "NULL", "tank_setpoint": "133", "object": "waterheater", "name": "waterheater", "thermostat_deadband": "4.3", "heating_element_capacity": "5", "demand": "water6*1", "temperature": "135", "tank_UA": "2.7", "location": "INSIDE"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:50", "componentType": "gridlabd", "treeProps": {"object": "triplex_line", "name": "triplex_line", "phases": "ABS", "from": "NULL", "to": "NULL", "length": "20", "configuration": "NULL"}}, "geometry": {"coordinates": [[0, 0], [0, 0]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "component:51", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1426", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00600 Ohm", "shunt_impedance": "339.610+288.130j", "reactance": "0.00400 Ohm", "powerA_rating": "25.0 kVA", "power_rating": "25.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:52", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.603674Ohm/km", "name": "oh_1/0_3WCS", "geometric_mean_radius": "0.347980cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:53", "componentType": "gridlabd", "treeProps": {"name": "tape_350", "conductor_resistance": "0.294 ohm/mile", "object": "underground_line_conductor", "shield_resistance": "3.1908 Ohm/mile", "neutral_gmr": "0.0214 ft", "outer_diameter": "1.37 in", "neutral_strands": "19", "neutral_resistance": "0.1845 ohm/mile", "neutral_diameter": "0.679 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.0490 ft", "conductor_gmr": "0.0214 ft"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:54", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.114332Ohm/km", "name": "oh_1/0_TPX", "geometric_mean_radius": "0.347980cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:55", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_500CUTRXLPECNJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:56", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.021 ft", "conductor_resistance": "0.063 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.676 in", "neutral_strands": "8", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "461 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.666 in", "shield_gmr": "0.00 ft", "name": "DG_397ACSR30X7"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:57", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3743", "primary_voltage": "12500.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.01 Ohm", "shunt_impedance": "308.320+310.435j", "reactance": "0.05 Ohm", "powerA_rating": "10.0 kVA", "power_rating": "10.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:58", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0105 ft", "conductor_resistance": "0.1189 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.573 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.563 in", "shield_gmr": "0.00 ft", "name": "DG_4_0ALEPRCNJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:59", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_1000", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "10 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:60", "componentType": "gridlabd", "treeProps": {"state_of_charge": "0.5", "name": "batt_defined", "parent": "load_following_inv_pf", "round_trip_efficiency": "0.95", "object": "battery", "battery_type": "LI_ION", "generator_mode": "SUPPLY_DRIVEN", "battery_capacity": "20 kWh", "use_internal_battery_model": "true"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:61", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.932057Ohm/km", "name": "oh_4_CU", "geometric_mean_radius": "0.202184cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:62", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1448", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00400 Ohm", "shunt_impedance": "365.685+356.338j", "reactance": "0.00267 Ohm", "powerB_rating": "37.5 kVA", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:63", "componentType": "gridlabd", "treeProps": {"powerC_rating": "5 kVA", "name": "R1_12_47_2_1452", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+302.457j", "reactance": "0.01 Ohm", "power_rating": "5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:64", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_650CUPILCJ3D15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:65", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_2_0AL15KVCN"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:66", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_10000_A", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "100 kVA", "power_rating": "100 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:67", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1722", "primary_voltage": "12470.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.00667 Ohm", "shunt_impedance": "318.750+275.669j", "reactance": "0.03333 Ohm", "powerB_rating": "15.0 kVA", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:68", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3092", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+322.313j", "reactance": "0.01 Ohm", "powerA_rating": "5.0 kVA", "power_rating": "5.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:69", "componentType": "gridlabd", "treeProps": {"pf_reg_activate_lockout_time": "60", "discharge_lockout_time": "1", "discharge_threshold": "4500 kW", "charge_lockout_time": "1", "max_discharge_rate": "300 kW", "rated_power": "150 kW", "charge_threshold": "4000 kW", "max_charge_rate": "300 kW", "pf_reg_deactivate": "0.95", "group_max_discharge_rate": "1200 kW", "four_quadrant_control_mode": "GROUP_LOAD_FOLLOWING", "group_rated_power": "1200 kW", "parent": "battery_meter_684", "generator_status": "ONLINE", "inverter_type": "FOUR_QUADRANT", "object": "inverter", "sense_object": "Node630", "pf_reg_activate": "0.9", "pf_reg": "INCLUDED", "name": "battery_inverter_684", "generator_mode": "CONSTANT_PQ", "group_max_charge_rate": "1200 kW", "inverter_efficiency": ".95"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:70", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0371 ft", "conductor_resistance": "0.0222 ohm/kft", "object": "underground_line_conductor", "shield_resistance": "0.00 Ohm/mile", "neutral_gmr": "0.0732739718442675 ft", "outer_diameter": "1.87 in", "neutral_strands": "20.0", "neutral_resistance": "0.05 ohm/kft", "rating.summer.continuous": "775.0 A", "neutral_diameter": "0.102", "conductor_diameter": "1.15 in", "shield_gmr": "0.00 ft", "name": "Tape_1000_AAC_1"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:71", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.157828Ohm/km", "name": "oh_397_ACSR_26/7", "geometric_mean_radius": "0.807720cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:72", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "1.528212Ohm/km", "name": "oh_4_WPAL", "geometric_mean_radius": "0.213360cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:73", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0175 ft", "conductor_resistance": "0.063 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.5618 in", "neutral_strands": "8", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.5518 in", "shield_gmr": "0.00 ft", "name": "DG_4_0CUB7SD"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:74", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0175 ft", "conductor_resistance": "0.063 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.5618 in", "neutral_strands": "8", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.5518 in", "shield_gmr": "0.00 ft", "name": "DG_4_0CURRUG"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:75", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1421", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00100 Ohm", "shunt_impedance": "600.360+543.819j", "reactance": "0.00067 Ohm", "powerA_rating": "150.0 kVA", "power_rating": "150.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:76", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_8CUPELC"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:77", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1445", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00300 Ohm", "shunt_impedance": "391.760+407.612j", "reactance": "0.00200 Ohm", "powerB_rating": "50.0 kVA", "power_rating": "50.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:78", "componentType": "gridlabd", "treeProps": {"powerC_rating": "10.0 kVA", "name": "R1_12_47_1_3126", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "308.320+337.156j", "reactance": "0.01 Ohm", "power_rating": "10.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:79", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3737", "primary_voltage": "12500.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.00267 Ohm", "shunt_impedance": "365.685+350.475j", "reactance": "0.01333 Ohm", "powerA_rating": "37.5 kVA", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:80", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.695867Ohm/km", "name": "oh_1/0_WPAL", "geometric_mean_radius": "0.135890cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:81", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.530030Ohm/km", "name": "oh_2/0_ACSR_TW", "geometric_mean_radius": "0.155448cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:82", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "8", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_Default"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:83", "componentType": "gridlabd", "treeProps": {"name": "DG_225_23_9_13_8_kV_YYT", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.009+0.018j", "power_rating": "225 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:84", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3111", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "308.320+342.457j", "reactance": "0.01 Ohm", "powerB_rating": "10.0 kVA", "power_rating": "10.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:85", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0TRXLPELCJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:86", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2ALTRXLPECNJAC15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:87", "componentType": "gridlabd", "treeProps": {"name": "DG_15_23_9_13_8_kV_YY1_120", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120.0 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "impedance": "0.018+0.018j", "power_rating": "15 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:88", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_750ALXLPE35"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:89", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3099", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+273.252j", "reactance": "0.01 Ohm", "powerA_rating": "5.0 kVA", "power_rating": "5.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:90", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3084", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00500 Ohm", "shunt_impedance": "350.040+295.721j", "reactance": "0.00333 Ohm", "powerA_rating": "30.0 kVA", "power_rating": "30.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:91", "componentType": "gridlabd", "treeProps": {"powerC_rating": "5 kVA", "name": "R1_12_47_1_3115", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+344.392j", "reactance": "0.01 Ohm", "power_rating": "5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:92", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0088 ft", "conductor_resistance": "1.38336 ohm/kft", "object": "underground_line_conductor", "shield_resistance": "0.00 Ohm/mile", "neutral_gmr": "0.0348162687755351 ft", "outer_diameter": "1.09 in", "neutral_strands": "6.0", "neutral_resistance": "13.5696 ohm/kft", "rating.summer.continuous": "112.0 A", "neutral_diameter": "0.0641 in", "conductor_diameter": "0.292 in", "shield_gmr": "0.00 ft", "name": "Conc_2_AL_1"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:93", "componentType": "gridlabd", "treeProps": {"name": "DG_37_5_23_9_13_8_kV_YY1_120", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120.0 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "impedance": "0.018+0.018j", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:94", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.113090Ohm/km", "name": "oh_556_ACSR_26/7", "geometric_mean_radius": "0.954024cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:95", "componentType": "gridlabd", "treeProps": {"name": "AG_1_0CN15", "conductor_resistance": "0.6070 ohm/kft", "object": "underground_line_conductor", "shield_resistance": "0.0000 Ohm/mile", "neutral_gmr": "0.0021 ft", "outer_diameter": "0.8930 in", "neutral_strands": "15.0000", "neutral_resistance": "14.8722 ohm/kft", "neutral_diameter": "0.0641 in", "conductor_diameter": "0.3680 in", "shield_gmr": "0.0000 ft", "conductor_gmr": "0.0111 ft"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:96", "componentType": "gridlabd", "treeProps": {"object": "capacitor", "control": "VOLT", "phases": "ABCN", "name": "capacitor", "parent": "675", "capacitor_B": "0.10 mVAr", "capacitor_C": "0.10 mVAr", "capacitor_A": "0.10 mVAr", "time_delay": "300.0", "nominal_voltage": "2401.7771", "voltage_set_high": "2350.0", "voltage_set_low": "2340.0", "switchC": "CLOSED", "control_level": "INDIVIDUAL", "switchA": "CLOSED", "switchB": "CLOSED", "phases_connected": "ABCN", "dwell_time": "0.0", "pt_phase": "ABCN"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:97", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0373 ft", "conductor_resistance": "0.0263 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.118 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.108 in", "shield_gmr": "0.00 ft", "name": "DG_750ALXLPEDWJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:98", "componentType": "gridlabd", "treeProps": {"phases": "AS", "object": "triplex_meter", "nominal_voltage": "240", "name": "split_phase_meter"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:99", "componentType": "gridlabd", "treeProps": {"powerC_rating": "30.0 kVA", "name": "R1_12_47_1_3130", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00500 Ohm", "shunt_impedance": "350.040+348.261j", "reactance": "0.00333 Ohm", "power_rating": "30.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:100", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALXLPECN35"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:101", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.131731Ohm/km", "name": "oh_477_ACSR_26/7", "geometric_mean_radius": "0.883920cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:102", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "1.572497Ohm/km", "name": "oh_UNK_UNK", "geometric_mean_radius": "0.133096cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:103", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_100_A_120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "1 kVA", "power_rating": "1 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:104", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_1000CUPILCJD15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:105", "componentType": "gridlabd", "treeProps": {"object": "underground_line", "name": "NULL", "phases": "ABCN", "from": "NULL", "to": "NULL", "length": "100", "configuration": "NULL"}}, "geometry": {"coordinates": [[0, 0], [0, 0]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "component:106", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "1.522297Ohm/km", "name": "oh_4_DPX", "geometric_mean_radius": "0.213360cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:107", "componentType": "gridlabd", "treeProps": {"powerC_rating": "10.0 kVA", "name": "R1_12_47_1_3124", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "308.320+308.100j", "reactance": "0.01 Ohm", "power_rating": "10.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:108", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_100000_A", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "1000 kVA", "power_rating": "1000 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:109", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1720", "primary_voltage": "12470.000 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.00080 Ohm", "shunt_impedance": "548.210+493.302j", "reactance": "0.00400 Ohm", "powerA_rating": "125.0 kVA", "power_rating": "125.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:110", "componentType": "gridlabd", "treeProps": {"name": "DG_500_23_9_13_8_kV_YYT_0277", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "277.0 V", "connect_type": "WYE_WYE", "impedance": "0.006+0.018j", "power_rating": "500 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:111", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "9", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_2_0"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:112", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3105", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00400 Ohm", "shunt_impedance": "365.685+345.241j", "reactance": "0.00267 Ohm", "powerB_rating": "37.5 kVA", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:113", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_100000_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "1000 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:114", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_6CUPELC5"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:115", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3085", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00400 Ohm", "shunt_impedance": "365.685+397.393j", "reactance": "0.00267 Ohm", "powerA_rating": "37.5 kVA", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:116", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_22500_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "225 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:117", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "9", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:118", "componentType": "gridlabd", "treeProps": {"powerC_rating": "50.0 kVA", "name": "R1_12_47_2_1455", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00300 Ohm", "shunt_impedance": "391.760+334.507j", "reactance": "0.00200 Ohm", "power_rating": "50.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:119", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1443", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00300 Ohm", "shunt_impedance": "391.760+389.189j", "reactance": "0.00200 Ohm", "powerB_rating": "50.0 kVA", "power_rating": "50.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:120", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_11250", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "112.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:121", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_2_0CURR15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:122", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1427", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00500 Ohm", "shunt_impedance": "350.040+272.033j", "reactance": "0.00333 Ohm", "powerA_rating": "30.0 kVA", "power_rating": "30.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:123", "componentType": "gridlabd", "treeProps": {"name": "DG_300_23_9_13_8_kV_YYT", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.009+0.018j", "power_rating": "300 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:124", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0175 ft", "conductor_resistance": "0.063 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.5618 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.5518 in", "shield_gmr": "0.00 ft", "name": "DG_4_0CURR15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:125", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.188275Ohm/km", "name": "oh_4/0_CU_7STR", "geometric_mean_radius": "0.480060cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:126", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_500CUKER15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:127", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.603674Ohm/km", "name": "oh_1/0_4WCS", "geometric_mean_radius": "0.347980cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:128", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_2000CUPILCJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:129", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_6CUPILC10"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:130", "componentType": "gridlabd", "treeProps": {"object": "load", "name": "load", "parent": "NULL", "phases": "ABCN", "voltage_A": "7200+0.0j", "voltage_B": "-3600-6235j", "voltage_C": "-3600+6235j", "constant_power_A": "69300+43000j", "constant_power_B": "69300+43000j", "constant_power_C": "69300+43000j", "nominal_voltage": "7200", "load_class": "R"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:131", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_750ALXLPE15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:132", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1419", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00300 Ohm", "shunt_impedance": "391.760+330.449j", "reactance": "0.00200 Ohm", "powerA_rating": "50.0 kVA", "power_rating": "50.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:133", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_750CUXLPEJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:134", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3107", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00400 Ohm", "shunt_impedance": "365.685+385.602j", "reactance": "0.00267 Ohm", "powerB_rating": "37.5 kVA", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:135", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALTRXLPECN15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:136", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1437", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00400 Ohm", "shunt_impedance": "365.685+356.066j", "reactance": "0.00267 Ohm", "powerB_rating": "37.5 kVA", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:137", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALEPRCNJ35"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:138", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "2.460262Ohm/km", "name": "oh_6_ACSR", "geometric_mean_radius": "0.120142cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:139", "componentType": "gridlabd", "treeProps": {"object": "regulator_configuration", "name": "regulator_configuration", "Control": "MANUAL", "Type": "A", "raise_taps": "16", "band_center": "2401", "tap_pos_A": "1", "tap_pos_B": "1", "time_delay": "30.0", "connect_type": "1", "regulation": "0.10", "CT_phase": "ABC", "lower_taps": "16", "tap_pos_C": "1", "PT_phase": "ABC", "band_width": "50"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:140", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "1.050198Ohm/km", "name": "oh_2_WPAL", "geometric_mean_radius": "0.127508cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:141", "componentType": "gridlabd", "treeProps": {"name": "DG_167_23_9_13_8_kV_YY1", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120.0 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "impedance": "0.009+0.018j", "power_rating": "167 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:142", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_500CUKERD5"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:143", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_500CURRUG"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:144", "componentType": "gridlabd", "treeProps": {"powerC_rating": "50.0 kVA", "name": "R1_12_47_2_1462", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00300 Ohm", "shunt_impedance": "391.760+346.529j", "reactance": "0.00200 Ohm", "power_rating": "50.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:145", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_11250_A", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "112.5 kVA", "power_rating": "112.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:146", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1428", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.01000 Ohm", "shunt_impedance": "318.750+313.920j", "reactance": "0.00667 Ohm", "powerA_rating": "15.0 kVA", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:147", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.175853Ohm/km", "name": "oh_397_AAC_TREEWIRE", "geometric_mean_radius": "0.731520cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:148", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3104", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00500 Ohm", "shunt_impedance": "350.040+368.976j", "reactance": "0.00333 Ohm", "powerB_rating": "30.0 kVA", "power_rating": "30.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:149", "componentType": "gridlabd", "treeProps": {"powerC_rating": "5.0 kVA", "name": "R1_12_47_1_3125", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+300.666j", "reactance": "0.01 Ohm", "power_rating": "5.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:150", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_30000_A_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "300 kVA", "power_rating": "300 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:151", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1420", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00600 Ohm", "shunt_impedance": "339.610+336.934j", "reactance": "0.00400 Ohm", "powerA_rating": "25.0 kVA", "power_rating": "25.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:152", "componentType": "gridlabd", "treeProps": {"powerC_rating": "75.0 kVA", "name": "R1_12_47_1_3730", "primary_voltage": "12500.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.00133 Ohm", "shunt_impedance": "443.910+424.448j", "reactance": "0.00667 Ohm", "power_rating": "75.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:153", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1436", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.01000 Ohm", "shunt_impedance": "318.750+330.288j", "reactance": "0.00667 Ohm", "powerB_rating": "15.0 kVA", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:154", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2CUPILCJD15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:155", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.294592Ohm/km", "name": "oh_4/0_ARV_7STR", "geometric_mean_radius": "0.513080cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:156", "componentType": "gridlabd", "treeProps": {"powerC_rating": "25.0 kVA", "name": "R1_12_47_1_3120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00600 Ohm", "shunt_impedance": "339.610+360.851j", "reactance": "0.00400 Ohm", "power_rating": "25.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:157", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_30000_A", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "300 kVA", "power_rating": "300 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:158", "componentType": "gridlabd", "treeProps": {"name": "DG_25_23_9_13_8_kV_YY1", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.018+0.018j", "power_rating": "25 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:159", "componentType": "gridlabd", "treeProps": {"name": "DG_50_23_9_13_8_kV_YYB", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.009+0.018j", "power_rating": "50 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:160", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_6CURR"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:161", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.133595Ohm/km", "name": "oh_300_CU", "geometric_mean_radius": "0.614172cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:162", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_3750_120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:163", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2ALPECNJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:164", "componentType": "gridlabd", "treeProps": {"powerC_rating": "15.0 kVA", "name": "R1_12_47_2_1459", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.01000 Ohm", "shunt_impedance": "318.750+390.343j", "reactance": "0.00667 Ohm", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:165", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALEPRCNJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:166", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.646847Ohm/km", "name": "oh_1/0_ACSR", "geometric_mean_radius": "0.135890cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:167", "componentType": "gridlabd", "treeProps": {"name": "DG_15_23_9_13_8_kV_YY1", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.018+0.018j", "power_rating": "15 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:168", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1438", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+330.126j", "reactance": "0.01 Ohm", "powerB_rating": "5 kVA", "power_rating": "5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:169", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_4500_A_120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "45 kVA", "power_rating": "45 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:170", "componentType": "gridlabd", "treeProps": {"powerC_rating": "5 kVA", "name": "R1_12_47_2_1453", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+260.525j", "reactance": "0.01 Ohm", "power_rating": "5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:171", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0373 ft", "conductor_resistance": "0.0263 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.118 in", "neutral_strands": "8", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.108 in", "shield_gmr": "0.00 ft", "name": "DG_750ALTRXLPELCJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:172", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2ALRC"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:173", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_16700_A_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "167 kVA", "power_rating": "167 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:174", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_650CU"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:175", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0395 ft", "conductor_resistance": "0.0141 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0 ft", "outer_diameter": "1.175 in", "neutral_strands": "0", "neutral_resistance": "0 ohm/kft", "rating.summer.continuous": "725 A", "neutral_diameter": "0 in", "conductor_diameter": "1.165 in", "shield_gmr": "0.00 ft", "name": "DG_1000ALTRXPELCJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:176", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.234319Ohm/km", "name": "oh_266_ACSR_26/7", "geometric_mean_radius": "0.661416cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:177", "componentType": "gridlabd", "treeProps": {"glass_type": "1", "auxiliary_system_type": "ELECTRIC", "cooling_COP": "2.8", "hvac_breaker_rating": "1000", "cooling_system_type": "ELECTRIC", "total_thermal_mass_per_floor_area": "2.5", "auxiliary_strategy": "DEADBAND", "air_temperature": "68", "heating_COP": "2.4", "motor_efficiency": "AVERAGE", "heating_system_type": "HEAT_PUMP", "Rwall": "10.0", "glazing_treatment": "1", "Rdoors": "3", "glazing_layers": "1", "window_frame": "1", "parent": "null", "floor_area": "2209", "object": "house", "number_of_stories": "1", "mass_temperature": "68", "name": "R1_SingleFamilyHome_Pre-1940", "Rfloor": "10.0", "airchange_per_hour": "0.75", "Rroof": "16.0", "ceiling_height": "8.0", "breaker_amps": "1000", "over_sizing_factor": "0.1", "motor_model": "BASIC"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:178", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2CUPILC315"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:179", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3109", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "308.320+327.432j", "reactance": "0.01 Ohm", "powerB_rating": "10.0 kVA", "power_rating": "10.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:180", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1439", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00600 Ohm", "shunt_impedance": "339.610+372.974j", "reactance": "0.00400 Ohm", "powerB_rating": "25.0 kVA", "power_rating": "25.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:181", "componentType": "gridlabd", "treeProps": {"object": "ZIPload", "name": "ZIPload", "parent": "NULL", "power_fraction": "0.013500", "current_fraction": "0.253400", "impedance_fraction": "0.733200", "base_power": "fan1*0.106899", "impedance_pf": "0.970000", "current_pf": "0.950000", "power_pf": "-1.000000"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:182", "componentType": "gridlabd", "treeProps": {"glass_type": "1", "auxiliary_system_type": "ELECTRIC", "cooling_COP": "3.4", "hvac_breaker_rating": "1000", "cooling_system_type": "ELECTRIC", "total_thermal_mass_per_floor_area": "2.5", "auxiliary_strategy": "DEADBAND", "air_temperature": "68", "heating_COP": "2.8", "motor_efficiency": "AVERAGE", "heating_system_type": "HEAT_PUMP", "Rwall": "17.0", "glazing_treatment": "1", "Rdoors": "3", "glazing_layers": "2", "window_frame": "2", "parent": "null", "floor_area": "2209", "object": "house", "number_of_stories": "1", "mass_temperature": "68", "name": "R1_SingleFamilyHome_1960-1969", "Rfloor": "19.0", "airchange_per_hour": "0.5", "Rroof": "30.0", "ceiling_height": "8.0", "breaker_amps": "1000", "over_sizing_factor": "0.1", "motor_model": "BASIC"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:183", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2ALTRXLPECNJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:184", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.114643Ohm/km", "name": "oh_350_CU", "geometric_mean_radius": "0.652780cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:185", "componentType": "gridlabd", "treeProps": {"pf_reg_activate_lockout_time": "60s", "discharge_off_threshold": "7.5 kW", "phases": "AS", "four_quadrant_control_mode": "LOAD_FOLLOWING", "name": "load_following_inv_pf", "parent": "split_phase_meter", "discharge_lockout_time": "60s", "inverter_type": "FOUR_QUADRANT", "object": "inverter", "sense_object": "triptransformer", "max_charge_rate": "0.80 kW", "charge_off_threshold": "7.0 kW", "pf_reg_activate": "0.7", "rated_power": "3000.0", "pf_reg_deactivate": "0.9", "charge_lockout_time": "60s", "max_discharge_rate": "1.0 kW", "inverter_efficiency": "0.87", "discharge_on_threshold": "9.0 kW", "charge_on_threshold": "5.0 kW"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:186", "componentType": "gridlabd", "treeProps": {"powerC_rating": "25.0 kVA", "name": "R1_12_47_2_1458", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00600 Ohm", "shunt_impedance": "339.610+284.766j", "reactance": "0.00400 Ohm", "power_rating": "25.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:187", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.646910Ohm/km", "name": "oh_1/0_ACSR_6/1", "geometric_mean_radius": "0.137160cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:188", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "1.485077Ohm/km", "name": "oh_6_WPCU", "geometric_mean_radius": "0.160274cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:189", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1425", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+268.429j", "reactance": "0.01 Ohm", "powerA_rating": "5 kVA", "power_rating": "5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:190", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0105 ft", "conductor_resistance": "0.1189 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.573 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.563 in", "shield_gmr": "0.00 ft", "name": "DG_4_0ALXLPECN15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:191", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3097", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "308.320+321.700j", "reactance": "0.01 Ohm", "powerA_rating": "10.0 kVA", "power_rating": "10.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:192", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1418", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00200 Ohm", "shunt_impedance": "443.910+463.922j", "reactance": "0.00133 Ohm", "powerA_rating": "75.0 kVA", "power_rating": "75.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:193", "componentType": "gridlabd", "treeProps": {"name": "tape_2_0", "conductor_resistance": "0.769 ohm/mile", "object": "underground_line_conductor", "shield_resistance": "4.0486 Ohm/mile", "neutral_gmr": "0.01252 ft", "outer_diameter": "1.10 in", "neutral_strands": "7", "neutral_resistance": "0.481 ohm/mile", "neutral_diameter": "0.414 in", "conductor_diameter": "0.414 in", "shield_gmr": "0.0385 ft", "conductor_gmr": "0.0125 ft"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:194", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0373 ft", "conductor_resistance": "0.0263 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.118 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "608 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.108 in", "shield_gmr": "0.00 ft", "name": "DG_750ALXLPEDWJ25"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:195", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2CURRUG"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:196", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.042875Ohm/km", "name": "oh_1000_CU", "geometric_mean_radius": "1.121921cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:197", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_50000_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "500 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:198", "componentType": "gridlabd", "treeProps": {"phases": "AS", "name": "solar_simple", "parent": "pf_inv", "area": "323", "object": "solar", "panel_type": "SINGLE_CRYSTAL_SILICON"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:199", "componentType": "gridlabd", "treeProps": {"name": "DG_30_23_9_13_8_kV_YYT", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.018+0.018j", "power_rating": "30 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:200", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.470378Ohm/km", "name": "oh_1_WPCU", "geometric_mean_radius": "0.309626cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:201", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1447", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00150 Ohm", "shunt_impedance": "496.060+536.117j", "reactance": "0.00100 Ohm", "powerB_rating": "100.0 kVA", "power_rating": "100.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:202", "componentType": "gridlabd", "treeProps": {"name": "DG_75_23_9_13_8_kV_YYT_120", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120.0 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "impedance": "0.009+0.018j", "power_rating": "75 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:203", "componentType": "gridlabd", "treeProps": {"name": "tape_3_0", "conductor_resistance": "0.611 ohm/mile", "object": "underground_line_conductor", "shield_resistance": "3.8816 Ohm/mile", "neutral_gmr": "0.01404 ft", "outer_diameter": "1.16 in", "neutral_strands": "7", "neutral_resistance": "0.382 ohm/mile", "neutral_diameter": "0.464 in", "conductor_diameter": "0.464 in", "shield_gmr": "0.0402 ft", "conductor_gmr": "0.014 ft"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:204", "componentType": "gridlabd", "treeProps": {"powerC_rating": "37.5 kVA", "name": "R1_12_47_2_1457", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00400 Ohm", "shunt_impedance": "365.685+360.013j", "reactance": "0.00267 Ohm", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:205", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_75000", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "750 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:206", "componentType": "gridlabd", "treeProps": {"powerC_rating": "62.5 kVA", "name": "R1_12_47_2_1464", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00240 Ohm", "shunt_impedance": "417.835+346.265j", "reactance": "0.00160 Ohm", "power_rating": "62.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:207", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2ALXLPECN15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:208", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_5000_120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "50 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:209", "componentType": "gridlabd", "treeProps": {"phases": "AS", "rated_power": "4.0 kW", "name": "solar_solpos", "parent": "pf_inv", "area": "29.6296 m^2", "orientation_azimuth": "180.0", "object": "solar", "efficiency": "0.135", "weather": "WA-Yakima", "SOLAR_TILT_MODEL": "SOLPOS", "SOLAR_POWER_MODEL": "FLATPLATE", "tilt_angle": "45.0", "orientation": "FIXED_AXIS"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:210", "componentType": "gridlabd", "treeProps": {"powerC_rating": "5.0 kVA", "name": "R1_12_47_1_3131", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+273.681j", "reactance": "0.01 Ohm", "power_rating": "5.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:211", "componentType": "gridlabd", "treeProps": {"powerC_rating": "50.0 kVA", "name": "R1_12_47_1_3129", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00300 Ohm", "shunt_impedance": "391.760+455.220j", "reactance": "0.00200 Ohm", "power_rating": "50.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:212", "componentType": "gridlabd", "treeProps": {"name": "tape_250", "conductor_resistance": "0.41 ohm/mile", "object": "underground_line_conductor", "shield_resistance": "3.4863 Ohm/mile", "neutral_gmr": "0.01813 ft", "outer_diameter": "1.27 in", "neutral_strands": "19", "neutral_resistance": "0.257 ohm/mile", "neutral_diameter": "0.574 in", "conductor_diameter": "0.567 in", "shield_gmr": "0.0448 ft", "conductor_gmr": "0.0171 ft"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:213", "componentType": "gridlabd", "treeProps": {"name": "DG_300_23_9_13_8_kV_YYT_0277", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "277.0 V", "connect_type": "WYE_WYE", "impedance": "0.009+0.018j", "power_rating": "300 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:214", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "405 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_350ALTRXLPELC15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:215", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALHMWPECN15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:216", "componentType": "gridlabd", "treeProps": {"powerC_rating": "0.0 kVA", "name": "R1_12_47_1_3740", "primary_voltage": "12500.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "WYE_WYE", "resistance": "0.00667 Ohm", "shunt_impedance": "318.750+365.165j", "reactance": "0.03333 Ohm", "powerB_rating": "15.0 kVA", "powerA_rating": "0.0 kVA", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:217", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.065289Ohm/km", "name": "oh_1000_WPAL", "geometric_mean_radius": "1.314961cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:218", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_3750_A_120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "37.5 kVA", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:219", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_16700_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "167 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:220", "componentType": "gridlabd", "treeProps": {"powerC_rating": "10.0 kVA", "name": "R1_12_47_2_1461", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "308.320+244.570j", "reactance": "0.01 Ohm", "power_rating": "10.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:221", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0175 ft", "conductor_resistance": "0.063 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.5618 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.5518 in", "shield_gmr": "0.00 ft", "name": "DG_4_0CUEPRJD15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:222", "componentType": "gridlabd", "treeProps": {"powerC_rating": "15.0 kVA", "name": "R1_12_47_1_3739", "primary_voltage": "12500.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.00667 Ohm", "shunt_impedance": "318.750+321.595j", "reactance": "0.03333 Ohm", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:223", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3093", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00400 Ohm", "shunt_impedance": "365.685+334.443j", "reactance": "0.00267 Ohm", "powerA_rating": "37.5 kVA", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:224", "componentType": "gridlabd", "treeProps": {"name": "substation_transf__conf_3", "primary_voltage": "57735.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "13800.0 V", "connect_type": "DELTA_GWYE", "impedance": "0.051+0.1209j", "power_rating": "20000 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:225", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0105 ft", "conductor_resistance": "0.1189 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.573 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.563 in", "shield_gmr": "0.00 ft", "name": "DG_4_0ALRC"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:226", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.349832Ohm/km", "name": "oh_4/0_ACSR", "geometric_mean_radius": "0.248158cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:227", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_350ALTRXLPELCJ25"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:228", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_2_0CUPILCJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:229", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_8CURR"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:230", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_7500_A", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "75 kVA", "power_rating": "75 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:231", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1429", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00300 Ohm", "shunt_impedance": "391.760+437.312j", "reactance": "0.00200 Ohm", "powerA_rating": "50.0 kVA", "power_rating": "50.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:232", "componentType": "gridlabd", "treeProps": {"object": "volt_var_control", "name": "volt_var_control", "substation_link": "Reg1", "max_vdrop": "50", "low_load_deadband": "30", "d_max": "0.8", "minimum_voltages": "1800", "control_method": "ACTIVE", "capacitor_list": "CAP1,CAP2", "regulator_list": "Reg1", "capacitor_delay": "60.0", "d_min": "0.1", "regulator_delay": "60.0", "desired_voltages": "2200", "maximum_voltages": "3500", "desired_pf": "0.99", "high_load_deadband": "30", "voltage_measurements": "652"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:233", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0105 ft", "conductor_resistance": "0.1189 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.573 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.563 in", "shield_gmr": "0.00 ft", "name": "DG_4_0ALTRXLPE15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:234", "componentType": "gridlabd", "treeProps": {"name": "DG_75_23_9_13_8_kV_YY1", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.009+0.018j", "power_rating": "75 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:235", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_2_0CUB7SD"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:236", "componentType": "gridlabd", "treeProps": {"name": "DG_150_23_9_13_8_kV_YYT_120", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120.0 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "impedance": "0.009+0.018j", "power_rating": "150 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:237", "componentType": "gridlabd", "treeProps": {"name": "AG_2CN15", "conductor_resistance": "0.9450 ohm/kft", "object": "underground_line_conductor", "shield_resistance": "0.0000 Ohm/mile", "neutral_gmr": "0.0021 ft", "outer_diameter": "0.7330 in", "neutral_strands": "15.0000", "neutral_resistance": "14.8722 ohm/kft", "neutral_diameter": "0.0641 in", "conductor_diameter": "0.2580 in", "shield_gmr": "0.0000 ft", "conductor_gmr": "0.0084 ft"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:238", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALTRXLPELCJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:239", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_2_0CUPILC3"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:240", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.377172Ohm/km", "name": "oh_1/0_CU_7STR", "geometric_mean_radius": "0.340360cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:241", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0105 ft", "conductor_resistance": "0.1189 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.573 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.563 in", "shield_gmr": "0.00 ft", "name": "DG_4_0ALXLPEDWJ25"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:242", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0105 ft", "conductor_resistance": "0.1189 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.573 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.563 in", "shield_gmr": "0.00 ft", "name": "DG_4_0AL15KVUG"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:243", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "2.430120Ohm/km", "name": "oh_6_WPAL", "geometric_mean_radius": "0.120142cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:244", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_400CURRUG"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:245", "componentType": "gridlabd", "treeProps": {"name": "DG_75_23_9_13_8_kV_YYB", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.009+0.018j", "power_rating": "75 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:246", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "221 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0TRXLPELCJ25"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:247", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1432", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.01000 Ohm", "shunt_impedance": "318.750+285.385j", "reactance": "0.00667 Ohm", "powerA_rating": "15.0 kVA", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:248", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.748877Ohm/km", "name": "oh_3_CU", "geometric_mean_radius": "0.227076cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:249", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1719", "primary_voltage": "12470.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.00200 Ohm", "shunt_impedance": "391.760+389.126j", "reactance": "0.01000 Ohm", "powerA_rating": "50.0 kVA", "power_rating": "50.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:250", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_750CUXLPE15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:251", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_4500", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "45 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:252", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.206726Ohm/km", "name": "oh_1/0_CU_TWISTED", "geometric_mean_radius": "0.474980cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:253", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3742", "primary_voltage": "12500.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.00400 Ohm", "shunt_impedance": "339.610+335.709j", "reactance": "0.02000 Ohm", "powerA_rating": "25.0 kVA", "power_rating": "25.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:254", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_2_0CUPILC3D15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:255", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.159692Ohm/km", "name": "oh_397_ACSR_TW", "geometric_mean_radius": "0.731520cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:256", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_5000_A", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "50 kVA", "power_rating": "50 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:257", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "2.386250Ohm/km", "name": "oh_8_CU", "geometric_mean_radius": "0.127000cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:258", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0395 ft", "conductor_resistance": "0.0141 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.175 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "725 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.165 in", "shield_gmr": "0.00 ft", "name": "DG_1000AL15KVUG"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:259", "componentType": "gridlabd", "treeProps": {"object": "triplex_line_conductor", "name": "triplex_line_conductor", "geometric_mean_radius": "0.01111", "resistance": "0.97"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:260", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0371 ft", "conductor_resistance": "0.0222 ohm/kft", "object": "underground_line_conductor", "shield_resistance": "0.00 Ohm/mile", "neutral_gmr": "0.0732739718442675 ft", "outer_diameter": "1.87 in", "neutral_strands": "20.0", "neutral_resistance": "0.05 ohm/kft", "rating.summer.continuous": "775.0 A", "neutral_diameter": "0.102 in", "conductor_diameter": "1.15 in", "shield_gmr": "0.00 ft", "name": "R1_12_47_2_Tape_1000_AAC"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:261", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0395 ft", "conductor_resistance": "0.0141 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.175 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "700 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.165 in", "shield_gmr": "0.00 ft", "name": "DG_1000ALXLPEDWJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:262", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_1_0CURR15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:263", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_7500_A_120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "75 kVA", "power_rating": "75 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:264", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0105 ft", "conductor_resistance": "0.1189 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.573 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.563 in", "shield_gmr": "0.00 ft", "name": "DG_4_0AL15KVCNJ"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:265", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3098", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00300 Ohm", "shunt_impedance": "391.760+382.759j", "reactance": "0.00200 Ohm", "powerA_rating": "50.0 kVA", "power_rating": "50.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:266", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.092 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_400CUTRXLPEJ"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:267", "componentType": "gridlabd", "treeProps": {"object": "evcharger_det", "parent": "XXX", "name": "YYY", "variation_mean": "300.0", "variation_std_dev": "100.0", "variation_trip_mean": "300.0", "variation_trip_std_dev": "100.0", "mileage_classification": "33.0", "work_charging_available": "false", "travel_distance": "15.0", "arrival_at_work": "900", "duration_at_work": "9 h", "arrival_at_home": "1800", "duration_at_home": "14 h", "mileage_efficiency": "3.846", "maximum_charge_rate": "1700", "charging_efficiency": "0.90"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:268", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0373 ft", "conductor_resistance": "0.0263 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.118 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "608 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.108 in", "shield_gmr": "0.00 ft", "name": "DG_750ALTRXLPE3AC15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:269", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_350ALTRXLPELCJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:270", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.933983Ohm/km", "name": "oh_#4_CU_1STR", "geometric_mean_radius": "0.202184cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:271", "componentType": "gridlabd", "treeProps": {"glass_type": "2", "auxiliary_system_type": "ELECTRIC", "cooling_COP": "4.0", "hvac_breaker_rating": "1000", "cooling_system_type": "ELECTRIC", "total_thermal_mass_per_floor_area": "2.5", "auxiliary_strategy": "DEADBAND", "air_temperature": "68", "heating_COP": "3.0", "motor_efficiency": "AVERAGE", "heating_system_type": "HEAT_PUMP", "Rwall": "28.0", "glazing_treatment": "2", "Rdoors": "11", "glazing_layers": "3", "window_frame": "4", "parent": "null", "floor_area": "2209", "object": "house", "number_of_stories": "1", "mass_temperature": "68", "name": "R1_SingleFamilyHome_1990-2005", "Rfloor": "30.0", "airchange_per_hour": "0.25", "Rroof": "48.0", "ceiling_height": "8.0", "breaker_amps": "1000", "over_sizing_factor": "0.1", "motor_model": "BASIC"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:272", "componentType": "gridlabd", "treeProps": {"name": "DG_45_23_9_13_8_kV_YYT", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.018+0.018j", "power_rating": "45 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:273", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_1000_120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "10 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:274", "componentType": "gridlabd", "treeProps": {"glass_type": "2", "auxiliary_system_type": "ELECTRIC", "cooling_COP": "3.8", "hvac_breaker_rating": "1000", "cooling_system_type": "ELECTRIC", "total_thermal_mass_per_floor_area": "2.5", "auxiliary_strategy": "DEADBAND", "air_temperature": "68", "heating_COP": "3.0", "motor_efficiency": "AVERAGE", "heating_system_type": "HEAT_PUMP", "Rwall": "22.0", "glazing_treatment": "1", "Rdoors": "5", "glazing_layers": "2", "window_frame": "2", "parent": "null", "floor_area": "2209", "object": "house", "number_of_stories": "1", "mass_temperature": "68", "name": "R1_SingleFamilyHome_1980-1989", "Rfloor": "22.0", "airchange_per_hour": "0.25", "Rroof": "36.0", "ceiling_height": "8.0", "breaker_amps": "1000", "over_sizing_factor": "0.1", "motor_model": "BASIC"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:275", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_750CUTRXLPELCJ25"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:276", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALEPRCNJ25"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:277", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_500ALTRXLPEJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:278", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_1500_A", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "15 kVA", "power_rating": "15 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:279", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_5000_A_120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "50 kVA", "power_rating": "50 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:280", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "8", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_750CUEPRJD15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:281", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2CUKER35"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:282", "componentType": "gridlabd", "treeProps": {"name": "DG_150_23_9_13_8_kV_YY1", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120.0 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "impedance": "0.009+0.018j", "power_rating": "150 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:283", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.188275Ohm/km", "name": "oh_4/0_WPCU", "geometric_mean_radius": "0.480060cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:284", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3731", "primary_voltage": "12500.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.00200 Ohm", "shunt_impedance": "391.760+425.397j", "reactance": "0.01000 Ohm", "powerA_rating": "50.0 kVA", "power_rating": "50.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:285", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_750CUTRXLPEJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:286", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALTRXLPECNJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:287", "componentType": "gridlabd", "treeProps": {"name": "tape_1_0", "conductor_resistance": "0.97 ohm/mile", "object": "underground_line_conductor", "shield_resistance": "4.2786 Ohm/mile", "neutral_gmr": "0.01113 ft", "outer_diameter": "1.06 in", "neutral_strands": "7", "neutral_resistance": "0.607 ohm/mile", "neutral_diameter": "0.368 in", "conductor_diameter": "0.368 in", "shield_gmr": "0.0365 ft", "conductor_gmr": "0.0111 ft"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:288", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1451", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "308.320+313.794j", "reactance": "0.01 Ohm", "powerB_rating": "10.0 kVA", "power_rating": "10.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:289", "componentType": "gridlabd", "treeProps": {"name": "DG_25_23_9_13_8_kV_YY1_120", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120.0 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "impedance": "0.018+0.018j", "power_rating": "25 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:290", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_2500_120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "25 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:291", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALEPRCN35"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:292", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1442", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.01000 Ohm", "shunt_impedance": "318.750+375.529j", "reactance": "0.00667 Ohm", "powerB_rating": "15.0 kVA", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:293", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3106", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.01000 Ohm", "shunt_impedance": "318.750+381.753j", "reactance": "0.00667 Ohm", "powerB_rating": "15.0 kVA", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:294", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3101", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.01000 Ohm", "shunt_impedance": "318.750+334.621j", "reactance": "0.00667 Ohm", "powerB_rating": "15.0 kVA", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:295", "componentType": "gridlabd", "treeProps": {"name": "DG_100_23_9_13_8_kV_YY1", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.009+0.018j", "power_rating": "100 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:296", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALTRXLPELCJAC15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:297", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.939016Ohm/km", "name": "oh_#2_ARV_7STR", "geometric_mean_radius": "0.287020cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:298", "componentType": "gridlabd", "treeProps": {"Q1": "0.7", "phases": "ABC", "four_quadrant_control_mode": "VOLT_VAR", "name": "volt_var_inv", "parent": "three_phase_meter", "V1": "0.90", "generator_status": "ONLINE", "inverter_type": "FOUR_QUADRANT", "object": "inverter", "V3": "1.05", "generator_mode": "SUPPLY_DRIVEN", "V2": "0.95", "rated_power": "70 kVA", "V4": "1.10", "Q2": "0.0", "volt_var_control_lockout": "60s", "V_base": "7200", "inverter_efficiency": "0.95", "Q3": "0.0", "Q4": "-0.8"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:299", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_2500_A", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "25 kVA", "power_rating": "25 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:300", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_15000_A", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "150 kVA", "power_rating": "150 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:301", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0105 ft", "conductor_resistance": "0.1189 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.573 in", "neutral_strands": "9", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.563 in", "shield_gmr": "0.00 ft", "name": "DG_4_0"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:302", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_650CUPILCJD15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:303", "componentType": "gridlabd", "treeProps": {"c_2": "-0.00003587", "phases": "AS", "rated_power": "3000", "name": "pf_inv_generic_multipoint", "parent": "split_phase_meter", "c_0": "-0.00001009", "use_multipoint_efficiency": "true", "inverter_type": "FOUR_QUADRANT", "power_factor": "0.95", "object": "inverter", "inverter_manufacturer": "NONE", "minimum_dc_power": "27.9", "maximum_dc_voltage": "277", "c_1": "-0.00001367", "maximum_dc_power": "3000", "c_3": "-0.00342100", "four_quadrant_control_mode": "CONSTANT_PF", "inverter_efficiency": "0.99"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:304", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_15000_A_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "150 kVA", "power_rating": "150 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:305", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.679780Ohm/km", "name": "oh_101_ACSR", "geometric_mean_radius": "0.016256cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:306", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_2_0AL15KVUG"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:307", "componentType": "gridlabd", "treeProps": {"name": "DG_500_23_9_13_8_kV_YYT_0240", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.0168+0.0504j", "power_rating": "500 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:308", "componentType": "gridlabd", "treeProps": {"name": "DG_50_23_9_13_8_kV_YY1", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.009+0.018j", "power_rating": "50 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:309", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.599002Ohm/km", "name": "oh_#2_CU_7STR", "geometric_mean_radius": "0.269240cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:310", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "8.463073Ohm/km", "name": "oh_14_CU", "geometric_mean_radius": "0.129885cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:311", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_100_120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "1 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:312", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1440", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "308.320+304.884j", "reactance": "0.01 Ohm", "powerB_rating": "10.0 kVA", "power_rating": "10.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:313", "componentType": "gridlabd", "treeProps": {"phases": "ABCN", "name": "windturb1", "parent": "rect1", "Gen_status": "ONLINE", "Turbine_Model": "BERGEY_10kW", "object": "windturb_dg", "Gen_mode": "CONSTANTP"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:314", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0177 ft", "conductor_resistance": "0.433488 ohm/kft", "object": "underground_line_conductor", "shield_resistance": "0.00 Ohm/mile", "neutral_gmr": "0.0485380344339232 ft", "outer_diameter": "1.32 in", "neutral_strands": "11.0", "neutral_resistance": "13.5696 ohm/kft", "rating.summer.continuous": "214.0 A", "neutral_diameter": "0.0641 in", "conductor_diameter": "0.528 in", "shield_gmr": "0.00 ft", "name": "Conc_4_0_AAC_2"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:315", "componentType": "gridlabd", "treeProps": {"name": "DG_75_23_9_13_8_kV_YYT", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.009+0.018j", "power_rating": "75 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:316", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALTRXPECNJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:317", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.587196Ohm/km", "name": "oh_2_CU", "geometric_mean_radius": "0.254762cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:318", "componentType": "gridlabd", "treeProps": {"phases": "ABCN", "name": "rect1", "parent": "simple_inverter", "object": "rectifier", "rectifier_type": "SIX_PULSE", "generator_mode": "SUPPLY_DRIVEN"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:319", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_250CURR15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:320", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3102", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00600 Ohm", "shunt_impedance": "339.610+418.251j", "reactance": "0.00400 Ohm", "powerB_rating": "25.0 kVA", "power_rating": "25.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:321", "componentType": "gridlabd", "treeProps": {"name": "DG_1500_23_9_13_8_kV_YYT_0277", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "277.0 V", "connect_type": "WYE_WYE", "impedance": "0.006+0.018j", "power_rating": "1500 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:322", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.146954Ohm/km", "name": "oh_500_KCM_WPAL", "geometric_mean_radius": "0.989330cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:323", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.932057Ohm/km", "name": "oh_4_WPCU", "geometric_mean_radius": "0.202184cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:324", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_2500", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "25 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:325", "componentType": "gridlabd", "treeProps": {"powerC_rating": "30.0 kVA", "name": "R1_12_47_1_3741", "primary_voltage": "12500.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.00333 Ohm", "shunt_impedance": "350.040+357.722j", "reactance": "0.01667 Ohm", "power_rating": "30.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:326", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.603674Ohm/km", "name": "oh_1/0_3W_CS", "geometric_mean_radius": "0.347980cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:327", "componentType": "gridlabd", "treeProps": {"object": "line_spacing", "name": "NULL", "distance_AN": "4.472136", "distance_CN": "4.472136", "distance_BC": "4.472136", "distance_AB": "4.472136", "distance_AC": "8.000000", "distance_BN": "4.000000"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:328", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.295773Ohm/km", "name": "oh_4/0_AAAC", "geometric_mean_radius": "0.480568cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:329", "componentType": "gridlabd", "treeProps": {"powerC_rating": "37.5 kVA", "name": "R1_12_47_1_3119", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00400 Ohm", "shunt_impedance": "365.685+295.469j", "reactance": "0.00267 Ohm", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:330", "componentType": "gridlabd", "treeProps": {"name": "DG_1000_23_9_13_8_kV_YYT_0277", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "277.0 V", "connect_type": "WYE_WYE", "impedance": "0.006+0.018j", "power_rating": "1000 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:331", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_500ALXLPE15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:332", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2ALHMWPECN25"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:333", "componentType": "gridlabd", "treeProps": {"object": "triplex_load", "name": "S1808-19-003_A", "nominal_voltage": "120", "phases": "AS", "base_power_12": "3000", "impedance_fraction_12": "0.5", "impedance_pf_12": "0.9", "current_fraction_12": "0.0", "current_pf_12": "0.9", "power_fraction_12": "0.5", "power_pf_12": "0.9", "parent": "NULL"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:334", "componentType": "gridlabd", "treeProps": {"object": "line_configuration", "name": "NULL", "spacing": "NULL", "conductor_A": "NULL", "conductor_C": "NULL", "conductor_B": "NULL", "conductor_N": "NULL"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:335", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3112", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+292.361j", "reactance": "0.01 Ohm", "powerB_rating": "5.0 kVA", "power_rating": "5.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:336", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_100_A", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "1 kVA", "power_rating": "1 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:337", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.159692Ohm/km", "name": "oh_250_CU_12STR", "geometric_mean_radius": "0.579120cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:338", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_15000", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "150 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:339", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0373 ft", "conductor_resistance": "0.0263 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.118 in", "neutral_strands": "9", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.108 in", "shield_gmr": "0.00 ft", "name": "DG_750"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:340", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_1500", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "15 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:341", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3087", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00600 Ohm", "shunt_impedance": "339.610+326.493j", "reactance": "0.00400 Ohm", "powerA_rating": "25.0 kVA", "power_rating": "25.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:342", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_16700", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "167 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:343", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "1.010163Ohm/km", "name": "oh_2_ACSR_TW", "geometric_mean_radius": "0.153545cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:344", "componentType": "gridlabd", "treeProps": {"name": "DG_15_23_9_13_8_kV_YYB", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.018+0.018j", "power_rating": "15 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:345", "componentType": "gridlabd", "treeProps": {"name": "DG_50_23_9_13_8_kV_YY1_120", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120.0 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "impedance": "0.009+0.018j", "power_rating": "50 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:346", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.134216Ohm/km", "name": "oh_477_ACSR", "geometric_mean_radius": "0.762000cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:347", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1424", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "308.320+273.632j", "reactance": "0.01 Ohm", "powerA_rating": "10.0 kVA", "power_rating": "10.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:348", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "2.460629Ohm/km", "name": "oh_6_AM", "geometric_mean_radius": "0.120142cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:349", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.583989Ohm/km", "name": "oh_2_TPX", "geometric_mean_radius": "0.213360cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:350", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_100", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "1 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:351", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2ALXLPECN35"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:352", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2ALPECN15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:353", "componentType": "gridlabd", "treeProps": {"name": "DG_5_23_9_13_8_kV_YY1", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120.0 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "impedance": "0.018+0.018j", "power_rating": "5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:354", "componentType": "gridlabd", "treeProps": {"name": "DG_150_23_9_13_8_kV_YYT", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.009+0.018j", "power_rating": "150 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:355", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_2_0CUPILCD35"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:356", "componentType": "gridlabd", "treeProps": {"object": "switch", "name": "NULL", "phases": "ABCN", "from": "NULL", "to": "NULL", "status": "CLOSED"}}, "geometry": {"coordinates": [[0, 0], [0, 0]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "component:357", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_400CUPILCD15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:358", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.159692Ohm/km", "name": "oh_397_ACSR", "geometric_mean_radius": "0.731520cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:359", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1430", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00120 Ohm", "shunt_impedance": "548.210+538.236j", "reactance": "0.00080 Ohm", "powerA_rating": "125.0 kVA", "power_rating": "125.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:360", "componentType": "gridlabd", "treeProps": {"phases": "AS", "rated_power": "4.0 kW", "name": "solar_fixed", "parent": "pf_inv", "area": "29.6296 m^2", "orientation_azimuth": "25.0", "object": "solar", "efficiency": "0.135", "latitude_angle_fix": "true", "orientation": "FIXED_AXIS"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:361", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.590800Ohm/km", "name": "oh_1/0_ARV_7STR", "geometric_mean_radius": "0.361696cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:362", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_1500_120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "15 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:363", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALXLPECN15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:364", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.159692Ohm/km", "name": "oh_397_ACSR_18/1", "geometric_mean_radius": "0.731520cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:365", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0395 ft", "conductor_resistance": "0.0141 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.175 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "700 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.165 in", "shield_gmr": "0.00 ft", "name": "DG_1000ALXLPEDWJ25"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:366", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.062323Ohm/km", "name": "oh_600_CU", "geometric_mean_radius": "0.838200cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:367", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_500CURR15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:368", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_2_0ALXLPECN15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:369", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_7500_120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "75 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:370", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_394AAACB19"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:371", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.188275Ohm/km", "name": "oh_336_ACSR", "geometric_mean_radius": "0.701040cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:372", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "221 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALTRXLPECNJ35"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:373", "componentType": "gridlabd", "treeProps": {"name": "DG_50_23_9_13_8_kV_YYB_120", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120.0 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "impedance": "0.009+0.018j", "power_rating": "100 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:374", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2CUKER15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:375", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.301837Ohm/km", "name": "oh_4/0_ALQPX", "geometric_mean_radius": "0.480568cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:376", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1721", "primary_voltage": "12470.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.00267 Ohm", "shunt_impedance": "365.685+345.365j", "reactance": "0.01333 Ohm", "powerA_rating": "37.5 kVA", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:377", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "1.190490Ohm/km", "name": "oh_5_CU", "geometric_mean_radius": "0.179832cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:378", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_75000_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "750 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:379", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "221 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALXLPECN25"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:380", "componentType": "gridlabd", "treeProps": {"powerC_rating": "15.0 kVA", "name": "R1_12_47_2_1456", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.01000 Ohm", "shunt_impedance": "318.750+279.088j", "reactance": "0.00667 Ohm", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:381", "componentType": "gridlabd", "treeProps": {"powerC_rating": "25.0 kVA", "name": "R1_12_47_1_3117", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00600 Ohm", "shunt_impedance": "339.610+331.380j", "reactance": "0.00400 Ohm", "power_rating": "25.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:382", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_2_0CUPILCD15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:383", "componentType": "gridlabd", "treeProps": {"name": "AG_750CUEPR_4RUNS", "conductor_resistance": "0.0947 ohm/kft", "object": "underground_line_conductor", "shield_resistance": "0.0000 Ohm/mile", "neutral_gmr": "0.0033 ft", "outer_diameter": "1.4830 in", "neutral_strands": "25.0000", "neutral_resistance": "5.9026 ohm/kft", "neutral_diameter": "0.1019 in", "conductor_diameter": "0.629 in", "shield_gmr": "0.0000 ft", "conductor_gmr": "0.0308 ft"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:384", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.236121Ohm/km", "name": "oh_266_ARV_19STR", "geometric_mean_radius": "0.607314cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:385", "componentType": "gridlabd", "treeProps": {"phases": "A", "object": "meter", "nominal_voltage": "7200", "name": "single_phase_meter", "parent": "null"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:386", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.381335Ohm/km", "name": "oh_1/0_WPCU", "geometric_mean_radius": "0.339598cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:387", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_75000_A_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "750 kVA", "power_rating": "750 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:388", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.530030Ohm/km", "name": "oh_2/0_ACSR", "geometric_mean_radius": "0.155448cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:389", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3096", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00300 Ohm", "shunt_impedance": "391.760+332.488j", "reactance": "0.00200 Ohm", "powerA_rating": "50.0 kVA", "power_rating": "50.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:390", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_650CUPIJ"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:391", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3103", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00600 Ohm", "shunt_impedance": "339.610+312.651j", "reactance": "0.00400 Ohm", "powerB_rating": "25.0 kVA", "power_rating": "25.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:392", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2CUPILCJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:393", "componentType": "gridlabd", "treeProps": {"name": "tape_500", "conductor_resistance": "0.206 ohm/mile", "object": "underground_line_conductor", "shield_resistance": "2.8963 Ohm/mile", "neutral_gmr": "0.026 ft", "outer_diameter": "1.49 in", "neutral_strands": "37", "neutral_resistance": "0.1303 ohm/mile", "neutral_diameter": "0.814 in", "conductor_diameter": "0.813 in", "shield_gmr": "0.0540 ft", "conductor_gmr": "0.026 ft"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:394", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.658790Ohm/km", "name": "oh_1/0_ACSR_AZUSA", "geometric_mean_radius": "0.135890cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:395", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1423", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00240 Ohm", "shunt_impedance": "417.835+429.640j", "reactance": "0.00160 Ohm", "powerA_rating": "62.5 kVA", "power_rating": "62.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:396", "componentType": "gridlabd", "treeProps": {"name": "batt_simple", "parent": "load_following_inv_pf", "object": "battery", "battery_type": "LI_ION", "generator_mode": "SUPPLY_DRIVEN", "rfb_size": "HOUSEHOLD", "use_internal_battery_model": "true"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:397", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1422", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+278.442j", "reactance": "0.01 Ohm", "powerA_rating": "5 kVA", "power_rating": "5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:398", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3110", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00300 Ohm", "shunt_impedance": "391.760+391.541j", "reactance": "0.00200 Ohm", "powerB_rating": "50.0 kVA", "power_rating": "50.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:399", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "1.485077Ohm/km", "name": "oh_6_CU", "geometric_mean_radius": "0.160274cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:400", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_350CURR15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:401", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3114", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+305.231j", "reactance": "0.01 Ohm", "powerB_rating": "5 kVA", "power_rating": "5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:402", "componentType": "gridlabd", "treeProps": {"name": "DG_25_23_9_13_8_kV_YYB", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.018+0.018j", "power_rating": "25 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:403", "componentType": "gridlabd", "treeProps": {"powerC_rating": "15.0 kVA", "name": "R1_12_47_1_3121", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.01000 Ohm", "shunt_impedance": "318.750+342.751j", "reactance": "0.00667 Ohm", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:404", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_19FOUG"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:405", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "221 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALHMWPECN25"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:406", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1726", "primary_voltage": "12470.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.00400 Ohm", "shunt_impedance": "339.610+381.628j", "reactance": "0.02000 Ohm", "powerA_rating": "25.0 kVA", "power_rating": "25.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:407", "componentType": "gridlabd", "treeProps": {"glass_type": "1", "auxiliary_system_type": "ELECTRIC", "cooling_COP": "3.6", "hvac_breaker_rating": "1000", "cooling_system_type": "ELECTRIC", "total_thermal_mass_per_floor_area": "2.5", "auxiliary_strategy": "DEADBAND", "air_temperature": "68", "heating_COP": "3.0", "motor_efficiency": "AVERAGE", "heating_system_type": "HEAT_PUMP", "Rwall": "19.0", "glazing_treatment": "1", "Rdoors": "3", "glazing_layers": "2", "window_frame": "2", "parent": "null", "floor_area": "2209", "object": "house", "number_of_stories": "1", "mass_temperature": "68", "name": "R1_SingleFamilyHome_1970-1979", "Rfloor": "20.0", "airchange_per_hour": "0.5", "Rroof": "34.0", "ceiling_height": "8.0", "breaker_amps": "1000", "over_sizing_factor": "0.1", "motor_model": "BASIC"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:408", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_50000_A_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "500 kVA", "power_rating": "500 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:409", "componentType": "gridlabd", "treeProps": {"powerC_rating": "62.5 kVA", "name": "R1_12_47_1_3118", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00240 Ohm", "shunt_impedance": "417.835+459.820j", "reactance": "0.00160 Ohm", "power_rating": "62.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:410", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_75000_A", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "750 kVA", "power_rating": "750 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:411", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "221 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALTRXLPECNJAC35"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:412", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0175 ft", "conductor_resistance": "0.063 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.5618 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.5518 in", "shield_gmr": "0.00 ft", "name": "DG_400CUB19"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:413", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1417", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00400 Ohm", "shunt_impedance": "365.685+340.474j", "reactance": "0.00267 Ohm", "powerA_rating": "37.5 kVA", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:414", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_3750", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:415", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.190575Ohm/km", "name": "oh_4/0_CU", "geometric_mean_radius": "0.507238cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:416", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_336AACHC19"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:417", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2CUPECN15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:418", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2ALTRXLPE15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:419", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1434", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00080 Ohm", "shunt_impedance": "678.585+661.660j", "reactance": "0.00053 Ohm", "powerA_rating": "187.5 kVA", "power_rating": "187.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:420", "componentType": "gridlabd", "treeProps": {"name": "DG_100_23_9_13_8_kV_YY1_120", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120.0 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "impedance": "0.009+0.018j", "power_rating": "100 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:421", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_2ALTRXPECN15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:422", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.03592 ft", "conductor_resistance": "0.057024 ohm/kft", "object": "underground_line_conductor", "shield_resistance": "0.00 Ohm/mile", "neutral_gmr": "0.0897563211395267 ft", "outer_diameter": "2.291 in", "neutral_strands": "20.0", "neutral_resistance": "3.44784 ohm/kft", "rating.summer.continuous": "662.0 A", "neutral_diameter": "0.1285 in", "conductor_diameter": "1.117 in", "shield_gmr": "0.00 ft", "name": "Conc_1000_CU_2"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:423", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1435", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00600 Ohm", "shunt_impedance": "339.610+383.556j", "reactance": "0.00400 Ohm", "powerB_rating": "25.0 kVA", "power_rating": "25.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:424", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.679780Ohm/km", "name": "oh_101_ACSR_12/7", "geometric_mean_radius": "0.016256cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:425", "componentType": "gridlabd", "treeProps": {"powerC_rating": "30.0 kVA", "name": "R1_12_47_2_1460", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00500 Ohm", "shunt_impedance": "350.040+375.918j", "reactance": "0.00333 Ohm", "power_rating": "30.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:426", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_350ALXLPEDWJ25"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:427", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0175 ft", "conductor_resistance": "0.063 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.5618 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.5518 in", "shield_gmr": "0.00 ft", "name": "DG_4_0CUBS"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:428", "componentType": "gridlabd", "treeProps": {"powerC_rating": "5 kVA", "name": "R1_12_47_1_3116", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+262.244j", "reactance": "0.01 Ohm", "power_rating": "5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:429", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3744", "primary_voltage": "12500.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.00400 Ohm", "shunt_impedance": "339.610+365.132j", "reactance": "0.02000 Ohm", "powerA_rating": "25.0 kVA", "power_rating": "25.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:430", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2CUPILCD15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:431", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "1.010163Ohm/km", "name": "oh_2_ACSR", "geometric_mean_radius": "0.127508cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:432", "componentType": "gridlabd", "treeProps": {"powerC_rating": "15.0 kVA", "name": "R1_12_47_1_3123", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.01000 Ohm", "shunt_impedance": "318.750+294.199j", "reactance": "0.00667 Ohm", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:433", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.301837Ohm/km", "name": "oh_4/0_TPX", "geometric_mean_radius": "0.480568cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:434", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.298880Ohm/km", "name": "oh_2/0_CU_7STR", "geometric_mean_radius": "0.381000cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:435", "componentType": "gridlabd", "treeProps": {"powerC_rating": "1000.0 kVA", "name": "GC_12_47_1", "primary_voltage": "12470.000 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "WYE_WYE", "resistance": "0.00003 Ohm", "shunt_impedance": "6545.460+6655.949j", "reactance": "0.00017 Ohm", "powerB_rating": "1000.0 kVA", "powerA_rating": "1000.0 kVA", "power_rating": "3000.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:436", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1723", "primary_voltage": "12470.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.00200 Ohm", "shunt_impedance": "391.760+406.028j", "reactance": "0.01000 Ohm", "powerB_rating": "50.0 kVA", "power_rating": "50.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:437", "componentType": "gridlabd", "treeProps": {"powerC_rating": "50.0 kVA", "name": "R1_12_47_1_3736", "primary_voltage": "12500.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "WYE_WYE", "resistance": "0.00067 Ohm", "shunt_impedance": "600.360+500.361j", "reactance": "0.00333 Ohm", "powerB_rating": "50.0 kVA", "powerA_rating": "50.0 kVA", "power_rating": "150.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:438", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "1.485083Ohm/km", "name": "oh_#6_CU_1STR", "geometric_mean_radius": "0.160274cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:439", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.298879Ohm/km", "name": "oh_2/0_CU", "geometric_mean_radius": "0.381254cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:440", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_10000_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "100 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:441", "componentType": "gridlabd", "treeProps": {"name": "AG_UNK", "conductor_resistance": "0.0947 ohm/kft", "object": "underground_line_conductor", "shield_resistance": "0.0000 Ohm/mile", "neutral_gmr": "0.0033 ft", "outer_diameter": "1.4830 in", "neutral_strands": "25.0000", "neutral_resistance": "5.9026 ohm/kft", "neutral_diameter": "0.1019 in", "conductor_diameter": "0.9630 in", "shield_gmr": "0.0000 ft", "conductor_gmr": "0.0308 ft"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:442", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.396435Ohm/km", "name": "oh_3/0_ACSR", "geometric_mean_radius": "0.182880cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:443", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_300CUKER5"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:444", "componentType": "gridlabd", "treeProps": {"name": "DG_1_23_9_13_8_kV_YY1", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120.0 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "impedance": "0.009+0.018j", "power_rating": "1 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:445", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "221 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALTRXLPELCJ25"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:446", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.114332Ohm/km", "name": "oh_1/0_QPX", "geometric_mean_radius": "0.347980cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:447", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0373 ft", "conductor_resistance": "0.0263 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.118 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "608 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.108 in", "shield_gmr": "0.00 ft", "name": "DG_750ALTRXLPEJ3AC15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:448", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_500CUPILCD25"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:449", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3095", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "308.320+393.061j", "reactance": "0.01 Ohm", "powerA_rating": "10.0 kVA", "power_rating": "10.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:450", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.01142 ft", "conductor_resistance": "0.88704 ohm/kft", "object": "underground_line_conductor", "shield_resistance": "0.00 Ohm/mile", "neutral_gmr": "0.0489686771417213 ft", "outer_diameter": "1.27 in", "neutral_strands": "16.0", "neutral_resistance": "13.86528 ohm/kft", "rating.summer.continuous": "142.0 A", "neutral_diameter": "0.0641", "conductor_diameter": "0.362 in", "shield_gmr": "0.00 ft", "name": "Conc_1_0_AAC_2"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:451", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "1.522297Ohm/km", "name": "oh_4_TPX", "geometric_mean_radius": "0.213360cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:452", "componentType": "gridlabd", "treeProps": {"glass_type": "1", "auxiliary_system_type": "ELECTRIC", "cooling_COP": "2.8", "hvac_breaker_rating": "1000", "cooling_system_type": "ELECTRIC", "total_thermal_mass_per_floor_area": "2.5", "auxiliary_strategy": "DEADBAND", "air_temperature": "68", "heating_COP": "1.9", "motor_efficiency": "AVERAGE", "heating_system_type": "HEAT_PUMP", "Rwall": "9.2", "glazing_treatment": "1", "Rdoors": "2.2", "glazing_layers": "1", "window_frame": "1", "parent": "null", "floor_area": "1054", "object": "house", "number_of_stories": "1", "mass_temperature": "68", "name": "R1_MobileHome_1960-1989", "Rfloor": "11.7", "airchange_per_hour": "0.75", "Rroof": "13.4", "ceiling_height": "8.0", "breaker_amps": "1000", "over_sizing_factor": "0.1", "motor_model": "BASIC"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:453", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_1000_A", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "10 kVA", "power_rating": "10 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:454", "componentType": "gridlabd", "treeProps": {"name": "DG_10_23_9_13_8_kV_YY1", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.018+0.018j", "power_rating": "10 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:455", "componentType": "gridlabd", "treeProps": {"phases": "AS", "rated_power": "3000", "name": "pf_inv", "parent": "split_phase_meter", "inverter_type": "FOUR_QUADRANT", "power_factor": "0.95", "object": "inverter", "four_quadrant_control_mode": "CONSTANT_PF", "inverter_efficiency": "0.87"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:456", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.234257Ohm/km", "name": "oh_266_ACSR", "geometric_mean_radius": "0.661416cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:457", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.470378Ohm/km", "name": "oh_1_CU", "geometric_mean_radius": "0.309626cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:458", "componentType": "gridlabd", "treeProps": {"powerC_rating": "0.0 kVA", "name": "R1_12_47_2_1724", "primary_voltage": "12470.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "WYE_WYE", "resistance": "0.00333 Ohm", "shunt_impedance": "350.040+334.211j", "reactance": "0.01667 Ohm", "powerB_rating": "15.0 kVA", "powerA_rating": "15.0 kVA", "power_rating": "30.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:459", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_750CUKER15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:460", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.295773Ohm/km", "name": "oh_4/0_AAC", "geometric_mean_radius": "0.314757cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:461", "componentType": "gridlabd", "treeProps": {"glass_type": "2", "auxiliary_system_type": "ELECTRIC", "cooling_COP": "3.5", "hvac_breaker_rating": "1000", "cooling_system_type": "ELECTRIC", "total_thermal_mass_per_floor_area": "2.5", "auxiliary_strategy": "DEADBAND", "air_temperature": "68", "heating_COP": "2.2", "motor_efficiency": "AVERAGE", "heating_system_type": "HEAT_PUMP", "Rwall": "11.7", "glazing_treatment": "1", "Rdoors": "3", "glazing_layers": "2", "window_frame": "2", "parent": "null", "floor_area": "1054", "object": "house", "number_of_stories": "1", "mass_temperature": "68", "name": "R1_MobileHome_1990-2005", "Rfloor": "18.1", "airchange_per_hour": "0.75", "Rroof": "24.1", "ceiling_height": "8.0", "breaker_amps": "1000", "over_sizing_factor": "0.1", "motor_model": "BASIC"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:462", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3089", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+274.164j", "reactance": "0.01 Ohm", "powerA_rating": "5 kVA", "power_rating": "5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:463", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_1000CUTRXLPELCJ25"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:464", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_10000", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "100 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:465", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_1000_A_120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "10 kVA", "power_rating": "10 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:466", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.298879Ohm/km", "name": "oh_2/0_WPCU", "geometric_mean_radius": "0.381254cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:467", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "8", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_Unknown"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:468", "componentType": "gridlabd", "treeProps": {"powerC_rating": "25.0 kVA", "name": "R1_12_47_2_1454", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00600 Ohm", "shunt_impedance": "339.610+299.781j", "reactance": "0.00400 Ohm", "power_rating": "25.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:469", "componentType": "gridlabd", "treeProps": {"name": "DG_2500_23_9_13_8_kV_YYT_0277", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "277.0 V", "connect_type": "WYE_WYE", "impedance": "0.006+0.018j", "power_rating": "2500 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:470", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.470378Ohm/km", "name": "oh_3#1_CU", "geometric_mean_radius": "0.309626cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:471", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0395 ft", "conductor_resistance": "0.0141 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.175 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "725 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.165 in", "shield_gmr": "0.00 ft", "name": "DG_1000ALTRXLPELCJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:472", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_5000", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "50 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:473", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_1_0"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:474", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1446", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+308.368j", "reactance": "0.01 Ohm", "powerB_rating": "5 kVA", "power_rating": "5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:475", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.530030Ohm/km", "name": "oh_2/0_WPAL", "geometric_mean_radius": "0.155448cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:476", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_2_0CUPILCJ3D15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:477", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2ALHMWPECN15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:478", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_400CUPILCJD15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:479", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "1.572497Ohm/km", "name": "oh_4_ACSR", "geometric_mean_radius": "0.133096cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:480", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.301837Ohm/km", "name": "oh_4/0_QPX", "geometric_mean_radius": "0.480568cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:481", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3083", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00600 Ohm", "shunt_impedance": "339.610+287.181j", "reactance": "0.00400 Ohm", "powerA_rating": "25.0 kVA", "power_rating": "25.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:482", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_350ALXLPEDWJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:483", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_4CUPECN15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:484", "componentType": "gridlabd", "treeProps": {"phases": "AS", "rated_power": "3000", "name": "pf_inv_manufacturer_multipoint", "parent": "split_phase_meter", "use_multipoint_efficiency": "true", "inverter_type": "FOUR_QUADRANT", "power_factor": "0.95", "object": "inverter", "inverter_manufacturer": "SMA", "four_quadrant_control_mode": "CONSTANT_PF", "inverter_efficiency": "0.87"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:485", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.080778Ohm/km", "name": "oh_500_CU", "geometric_mean_radius": "0.792734cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:486", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_50000", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "500 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:487", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_30000_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "300 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:488", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_22500_A", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "225 kVA", "power_rating": "225 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:489", "componentType": "gridlabd", "treeProps": {"object": "regulator", "name": "reg", "phases": "ABCN", "from": "XXXXX", "to": "YYYYY", "configuration": "ZZZZ"}}, "geometry": {"coordinates": [[0, 0], [0, 0]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "component:490", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.603674Ohm/km", "name": "oh_1/0_4W_CS", "geometric_mean_radius": "0.347980cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:491", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.159692Ohm/km", "name": "oh_250_CU", "geometric_mean_radius": "0.551688cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:492", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3100", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.015 Ohm", "shunt_impedance": "297.890+273.106j", "reactance": "0.01 Ohm", "powerB_rating": "5.0 kVA", "power_rating": "5.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:493", "componentType": "gridlabd", "treeProps": {"glass_type": "1", "auxiliary_system_type": "ELECTRIC", "cooling_COP": "2.8", "hvac_breaker_rating": "1000", "cooling_system_type": "ELECTRIC", "total_thermal_mass_per_floor_area": "2.5", "auxiliary_strategy": "DEADBAND", "air_temperature": "68", "heating_COP": "1.9", "motor_efficiency": "AVERAGE", "heating_system_type": "HEAT_PUMP", "Rwall": "11.7", "glazing_treatment": "1", "Rdoors": "2.2", "glazing_layers": "1", "window_frame": "1", "parent": "null", "floor_area": "820", "object": "house", "number_of_stories": "1", "mass_temperature": "68", "name": "R1_Apartment_Pre-1960", "Rfloor": "9.4", "airchange_per_hour": "0.75", "Rroof": "13.4", "ceiling_height": "8.0", "breaker_amps": "1000", "over_sizing_factor": "0.1", "motor_model": "BASIC"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:494", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.062992Ohm/km", "name": "oh_777_CU", "geometric_mean_radius": "0.987552cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:495", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_650CUTRXLPEJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:496", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.295773Ohm/km", "name": "oh_4/0_AAC_TW", "geometric_mean_radius": "0.314757cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:497", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_11250_A_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "112.5 kVA", "power_rating": "112.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:498", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0373 ft", "conductor_resistance": "0.0263 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.118 in", "neutral_strands": "8", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "608 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.108 in", "shield_gmr": "0.00 ft", "name": "DG_750ALTRXLPELCJ25"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:499", "componentType": "gridlabd", "treeProps": {"object": "fuse", "name": "NULL", "phases": "ABCN", "from": "NULL", "to": "NULL", "status": "CLOSED", "current_limit": "50000"}}, "geometry": {"coordinates": [[0, 0], [0, 0]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "component:500", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_750CUPILCJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:501", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.055302Ohm/km", "name": "oh_750_CU", "geometric_mean_radius": "0.971804cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:502", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1449", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00075 Ohm", "shunt_impedance": "704.660+755.051j", "reactance": "0.00050 Ohm", "powerB_rating": "200.0 kVA", "power_rating": "200.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:503", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0395 ft", "conductor_resistance": "0.0141 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.175 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "700 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.165 in", "shield_gmr": "0.00 ft", "name": "DG_1_0ALTRXLPELCJ35"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:504", "componentType": "gridlabd", "treeProps": {"state_of_charge": "0.5", "name": "batt_additional", "parent": "load_following_inv_pf", "round_trip_efficiency": "0.95", "object": "battery", "reserve_state_of_charge": "0.1", "battery_type": "LI_ION", "generator_mode": "SUPPLY_DRIVEN", "rated_power": "2 kW", "battery_capacity": "20 kWh", "use_internal_battery_model": "true"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:505", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.592167Ohm/km", "name": "oh_1/0_AAC", "geometric_mean_radius": "0.366596cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:506", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0071 ft", "conductor_resistance": "0.2169 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.408 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "235 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.398 in", "shield_gmr": "0.00 ft", "name": "DG_Default_Neutral"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:507", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0105 ft", "conductor_resistance": "0.1189 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.573 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.563 in", "shield_gmr": "0.00 ft", "name": "DG_4_0ALWP7"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:508", "componentType": "gridlabd", "treeProps": {"name": "DG_750_23_9_13_8_kV_YYT_0277", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "277.0 V", "connect_type": "WYE_WYE", "impedance": "0.006+0.018j", "power_rating": "750 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:509", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0105 ft", "conductor_resistance": "0.1189 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.573 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.563 in", "shield_gmr": "0.00 ft", "name": "DG_4_0CUPILCJD15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:510", "componentType": "gridlabd", "treeProps": {"powerC_rating": "100.0 kVA", "name": "R1_12_47_2_1717", "primary_voltage": "12470.000 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "WYE_WYE", "resistance": "0.00033 Ohm", "shunt_impedance": "913.260+1012.897j", "reactance": "0.00167 Ohm", "powerB_rating": "100.0 kVA", "powerA_rating": "100.0 kVA", "power_rating": "300.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:511", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0215 ft", "conductor_resistance": "0.0605 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.689 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "421 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.679 in", "shield_gmr": "0.00 ft", "name": "DG_650CUPI"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:512", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0373 ft", "conductor_resistance": "0.0263 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.118 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "608 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.108 in", "shield_gmr": "0.00 ft", "name": "DG_750CUTRXLPEJD35"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:513", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.469197Ohm/km", "name": "oh_2/0_ARV_7STR", "geometric_mean_radius": "0.406400cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:514", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3113", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00300 Ohm", "shunt_impedance": "391.760+347.827j", "reactance": "0.00200 Ohm", "powerB_rating": "50.0 kVA", "power_rating": "50.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:515", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.086371Ohm/km", "name": "oh_750_AAC", "geometric_mean_radius": "0.972640cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:516", "componentType": "gridlabd", "treeProps": {"object": "triplex_line_configuration", "name": "triplex_line_configuration", "diameter": "0.368", "conductor_1": "tlc", "conductor_2": "tlc", "conductor_N": "tlc", "insulation_thickness": "0.08"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:517", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_100000", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "1000 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:518", "componentType": "gridlabd", "treeProps": {"object": "recorder", "property": "measured_power,voltage_12.real,voltage_12.imag", "interval": "1", "limit": "0", "file": "meterRecorder_XXX.csv", "parent": "XXXX", "name": "meter_recorder"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:519", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.944298Ohm/km", "name": "oh_2_AAAC", "geometric_mean_radius": "0.269240cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:520", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.081027Ohm/km", "name": "oh_500_CU_19STR", "geometric_mean_radius": "0.779780cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:521", "componentType": "gridlabd", "treeProps": {"powerC_rating": "37.5 kVA", "name": "R1_12_47_1_3128", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00400 Ohm", "shunt_impedance": "365.685+352.878j", "reactance": "0.00267 Ohm", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:522", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_22500", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "225 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:523", "componentType": "gridlabd", "treeProps": {"glass_type": "1", "auxiliary_system_type": "ELECTRIC", "cooling_COP": "3.2", "hvac_breaker_rating": "1000", "cooling_system_type": "ELECTRIC", "total_thermal_mass_per_floor_area": "2.5", "auxiliary_strategy": "DEADBAND", "air_temperature": "68", "heating_COP": "2.6", "motor_efficiency": "AVERAGE", "heating_system_type": "HEAT_PUMP", "Rwall": "14.0", "glazing_treatment": "1", "Rdoors": "3", "glazing_layers": "2", "window_frame": "1", "parent": "null", "floor_area": "2209", "object": "house", "number_of_stories": "1", "mass_temperature": "68", "name": "R1_SingleFamilyHome_1950-1959", "Rfloor": "16.0", "airchange_per_hour": "0.5", "Rroof": "19.0", "ceiling_height": "8.0", "breaker_amps": "1000", "over_sizing_factor": "0.1", "motor_model": "BASIC"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:524", "componentType": "gridlabd", "treeProps": {"powerC_rating": "50.0 kVA", "name": "R1_12_47_2_1718", "primary_voltage": "12470.000 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "WYE_WYE", "resistance": "0.00067 Ohm", "shunt_impedance": "600.360+590.521j", "reactance": "0.00333 Ohm", "powerB_rating": "50.0 kVA", "powerA_rating": "50.0 kVA", "power_rating": "150.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:525", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1725", "primary_voltage": "12470.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.00667 Ohm", "shunt_impedance": "318.750+343.720j", "reactance": "0.03333 Ohm", "powerA_rating": "15.0 kVA", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:526", "componentType": "gridlabd", "treeProps": {"powerC_rating": "37.5 kVA", "name": "R1_12_47_1_3732", "primary_voltage": "12500.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.00267 Ohm", "shunt_impedance": "365.685+372.824j", "reactance": "0.01333 Ohm", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:527", "componentType": "gridlabd", "treeProps": {"name": "AG_750CN15", "conductor_resistance": "0.0947 ohm/kft", "object": "underground_line_conductor", "shield_resistance": "0.0000 Ohm/mile", "neutral_gmr": "0.0033 ft", "outer_diameter": "1.4830 in", "neutral_strands": "25.0000", "neutral_resistance": "5.9026 ohm/kft", "neutral_diameter": "0.1019 in", "conductor_diameter": "0.963 in", "shield_gmr": "0.0000 ft", "conductor_gmr": "0.0308 ft"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:528", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.587196Ohm/km", "name": "oh_2_WPCU", "geometric_mean_radius": "0.254762cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:529", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_3750_A", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "37.5 kVA", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:530", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_4500_120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "45 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:531", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0105 ft", "conductor_resistance": "0.1189 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.573 in", "neutral_strands": "8", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.563 in", "shield_gmr": "0.00 ft", "name": "DG_CUSTOMER_WIRE"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:532", "componentType": "gridlabd", "treeProps": {"phases": "ABCN", "name": "windturb2", "parent": "three_phase_meter", "Gen_status": "ONLINE", "Turbine_Model": "GE_25MW", "object": "windturb_dg", "Gen_mode": "CONSTANTP", "Gen_type": "SYNCHRONOUS"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:533", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0077 ft", "conductor_resistance": "0.1765 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.457 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "245 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.447 in", "shield_gmr": "0.00 ft", "name": "DG_2_0ALHMWPECN15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:534", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0105 ft", "conductor_resistance": "0.1189 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.573 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.563 in", "shield_gmr": "0.00 ft", "name": "DG_4_0ALXLPEDWJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:535", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_500CUPILCD15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:536", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_1500_A_120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "15 kVA", "power_rating": "15 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:537", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0371 ft", "conductor_resistance": "0.091872 ohm/kft", "object": "underground_line_conductor", "shield_resistance": "0.00 Ohm/mile", "neutral_gmr": "0.0842565914341201 ft", "outer_diameter": "2.15 in", "neutral_strands": "20.0", "neutral_resistance": "5.3856 ohm/kft", "rating.summer.continuous": "488.0 A", "neutral_diameter": "0.1019 in", "conductor_diameter": "1.152 in", "shield_gmr": "0.00 ft", "name": "Conc_1000_AAC_1"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:538", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.074813Ohm/km", "name": "oh_1000_KCM_WPAL", "geometric_mean_radius": "1.314961cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:539", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_7500", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "75 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:540", "componentType": "gridlabd", "treeProps": {"name": "DG_2000_23_9_13_8_kV_YYT_0277", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "277.0 V", "connect_type": "WYE_WYE", "impedance": "0.0168+0.0504j", "power_rating": "2000 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:541", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_10000_A_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "100 kVA", "power_rating": "100 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:542", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0325 ft", "conductor_resistance": "0.0183 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "1.102 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "630 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "1.092 in", "shield_gmr": "0.00 ft", "name": "DG_400CUPILC3D15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:543", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_100000_A_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "1000 kVA", "power_rating": "1000 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:544", "componentType": "gridlabd", "treeProps": {"glass_type": "1", "auxiliary_system_type": "ELECTRIC", "cooling_COP": "3.0", "hvac_breaker_rating": "1000", "cooling_system_type": "ELECTRIC", "total_thermal_mass_per_floor_area": "2.5", "auxiliary_strategy": "DEADBAND", "air_temperature": "68", "heating_COP": "2.0", "motor_efficiency": "AVERAGE", "heating_system_type": "HEAT_PUMP", "Rwall": "11.7", "glazing_treatment": "2", "Rdoors": "2.7", "glazing_layers": "2", "window_frame": "2", "parent": "null", "floor_area": "820", "object": "house", "number_of_stories": "1", "mass_temperature": "68", "name": "R1_Apartment_1960-1989", "Rfloor": "12.7", "airchange_per_hour": "0.25", "Rroof": "20.3", "ceiling_height": "8.0", "breaker_amps": "1000", "over_sizing_factor": "0.1", "motor_model": "BASIC"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:545", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.134216Ohm/km", "name": "oh_477_AAAC", "geometric_mean_radius": "0.762000cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:546", "componentType": "gridlabd", "treeProps": {"powerC_rating": "0.0 kVA", "name": "R1_12_47_1_3735", "primary_voltage": "12500.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "WYE_WYE", "resistance": "0.00400 Ohm", "shunt_impedance": "339.610+424.065j", "reactance": "0.02000 Ohm", "powerB_rating": "25.0 kVA", "powerA_rating": "0.0 kVA", "power_rating": "25.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:547", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.188275Ohm/km", "name": "oh_336_AAC", "geometric_mean_radius": "0.671264cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:548", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "1.485077Ohm/km", "name": "oh_6_WPCU_SEC", "geometric_mean_radius": "0.160274cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:549", "componentType": "gridlabd", "treeProps": {"rated_power": "25000", "phases": "ABC", "object": "inverter", "name": "simple_inverter", "parent": "three_phase_meter"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:550", "componentType": "gridlabd", "treeProps": {"powerC_rating": "50.0 kVA", "name": "R1_12_47_1_3127", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00300 Ohm", "shunt_impedance": "391.760+417.754j", "reactance": "0.00200 Ohm", "power_rating": "50.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:551", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0105 ft", "conductor_resistance": "0.1189 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.573 in", "neutral_strands": "8", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "320 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.563 in", "shield_gmr": "0.00 ft", "name": "DG_4_0ALTRXLPECNJ15"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:552", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.134216Ohm/km", "name": "oh_477_AAC", "geometric_mean_radius": "0.519069cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:553", "componentType": "gridlabd", "treeProps": {"name": "AG_750CUXLP", "conductor_resistance": "0.0947 ohm/kft", "object": "underground_line_conductor", "shield_resistance": "2.704 Ohm/mile", "neutral_gmr": "0 ft", "outer_diameter": "2.5 in", "neutral_strands": "0", "neutral_resistance": "0 ohm/kft", "neutral_diameter": "0 in", "conductor_diameter": "1.059 in", "shield_gmr": "0.07808 ft", "conductor_gmr": "0.0308 ft"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:554", "componentType": "gridlabd", "treeProps": {"phases": "AS", "rated_power": "4.0 kW", "name": "solar_shading", "parent": "pf_inv", "area": "29.6296 m^2", "orientation_azimuth": "180.0", "object": "solar", "efficiency": "0.135", "weather": "WA-Yakima", "SOLAR_TILT_MODEL": "SOLPOS", "SOLAR_POWER_MODEL": "FLATPLATE", "tilt_angle": "45.0", "shading_factor": "0.8", "orientation": "FIXED_AXIS"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:555", "componentType": "gridlabd", "treeProps": {"name": "DG_37_5_23_9_13_8_kV_YYB", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.018+0.018j", "power_rating": "37.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:556", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3108", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00500 Ohm", "shunt_impedance": "350.040+345.213j", "reactance": "0.00333 Ohm", "powerB_rating": "30.0 kVA", "power_rating": "30.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:557", "componentType": "gridlabd", "treeProps": {"name": "substation_transf__conf", "primary_voltage": "57735.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "13800.0 V", "connect_type": "DELTA_GWYE", "impedance": "0.051+0.1230j", "power_rating": "20000 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:558", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1450", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00133 Ohm", "shunt_impedance": "522.135+576.886j", "reactance": "0.00089 Ohm", "powerB_rating": "112.5 kVA", "power_rating": "112.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:559", "componentType": "gridlabd", "treeProps": {"powerC_rating": "62.5 kVA", "name": "R1_12_47_1_3738", "primary_voltage": "12500.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "SINGLE_PHASE", "resistance": "0.00160 Ohm", "shunt_impedance": "417.835+414.316j", "reactance": "0.00800 Ohm", "power_rating": "62.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:560", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "1.497318Ohm/km", "name": "oh_4_AAAC", "geometric_mean_radius": "0.213360cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:561", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1441", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00500 Ohm", "shunt_impedance": "350.040+395.403j", "reactance": "0.00333 Ohm", "powerB_rating": "30.0 kVA", "power_rating": "30.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:562", "componentType": "gridlabd", "treeProps": {"name": "AG_1000CUEPR", "conductor_resistance": "0.088 ohm/kft", "object": "underground_line_conductor", "shield_resistance": "0.0000 Ohm/mile", "neutral_gmr": "0.0037 ft", "outer_diameter": "1.6600 in", "neutral_strands": "26.0000", "neutral_resistance": "4.6758 ohm/kft", "neutral_diameter": "0.1144 in", "conductor_diameter": "1.117 in", "shield_gmr": "0.0000 ft", "conductor_gmr": "0.0393 ft"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:563", "componentType": "gridlabd", "treeProps": {"name": "DG_225_23_9_13_8_kV_YYT_120", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120.0 V", "connect_type": "WYE_WYE", "impedance": "0.009+0.018j", "power_rating": "225 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:564", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1433", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00500 Ohm", "shunt_impedance": "350.040+405.462j", "reactance": "0.00333 Ohm", "powerA_rating": "30.0 kVA", "power_rating": "30.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:565", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3088", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.01000 Ohm", "shunt_impedance": "318.750+360.704j", "reactance": "0.00667 Ohm", "powerA_rating": "15.0 kVA", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:566", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.646847Ohm/km", "name": "oh_1/0_ACSR_TW", "geometric_mean_radius": "0.204544cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:567", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_30000", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "300 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:568", "componentType": "gridlabd", "treeProps": {"powerC_rating": "15.0 kVA", "name": "R1_12_47_2_1716", "primary_voltage": "12470.000 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "480 V", "connect_type": "WYE_WYE", "resistance": "0.00667 Ohm", "shunt_impedance": "318.750+304.091j", "reactance": "0.03333 Ohm", "powerB_rating": "0.0 kVA", "powerA_rating": "0.0 kVA", "power_rating": "15.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:569", "componentType": "gridlabd", "treeProps": {"glass_type": "1", "auxiliary_system_type": "ELECTRIC", "cooling_COP": "3.0", "hvac_breaker_rating": "1000", "cooling_system_type": "ELECTRIC", "total_thermal_mass_per_floor_area": "2.5", "auxiliary_strategy": "DEADBAND", "air_temperature": "68", "heating_COP": "2.5", "motor_efficiency": "AVERAGE", "heating_system_type": "HEAT_PUMP", "Rwall": "11.0", "glazing_treatment": "1", "Rdoors": "3", "glazing_layers": "2", "window_frame": "1", "parent": "null", "floor_area": "2209", "object": "house", "number_of_stories": "1", "mass_temperature": "68", "name": "R1_SingleFamilyHome_1940-1949", "Rfloor": "12.0", "airchange_per_hour": "0.75", "Rroof": "19.0", "ceiling_height": "8.0", "breaker_amps": "1000", "over_sizing_factor": "0.1", "motor_model": "BASIC"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:570", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.100662Ohm/km", "name": "oh_400_CU", "geometric_mean_radius": "0.697738cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:571", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.146954Ohm/km", "name": "oh_500_WPAL", "geometric_mean_radius": "0.989330cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:572", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_2_1444", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00200 Ohm", "shunt_impedance": "443.910+432.560j", "reactance": "0.00133 Ohm", "powerB_rating": "75.0 kVA", "power_rating": "75.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:573", "componentType": "gridlabd", "treeProps": {"conductor_gmr": "0.0046 ft", "conductor_resistance": "0.332 ohm/kft", "object": "underground_line_conductor", "neutral_gmr": "0.0132 ft", "outer_diameter": "0.326 in", "neutral_strands": "7", "neutral_resistance": "2.3057 ohm/kft", "rating.summer.continuous": "165 A", "neutral_diameter": "0.0254 in", "conductor_diameter": "0.316 in", "shield_gmr": "0.00 ft", "name": "DG_2CUB7SD"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:574", "componentType": "gridlabd", "treeProps": {"name": "DG_10_23_9_13_8_kV_YY1_120", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120.0 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "impedance": "0.018+0.018j", "power_rating": "10 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:575", "componentType": "gridlabd", "treeProps": {"name": "DG_75_23_9_13_8_kV_YY1_120", "primary_voltage": "13800.0 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120.0 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "impedance": "0.009+0.018j", "power_rating": "75 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:576", "componentType": "gridlabd", "treeProps": {"object": "overhead_line_conductor", "resistance": "0.186411Ohm/km", "name": "oh_336_ACSR_26/7", "geometric_mean_radius": "0.743712cm"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:577", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_4500_A", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "208 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "45 kVA", "power_rating": "45 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:578", "componentType": "gridlabd", "treeProps": {"name": "R1_12_47_1_3094", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "resistance": "0.00500 Ohm", "shunt_impedance": "350.040+362.548j", "reactance": "0.00333 Ohm", "powerA_rating": "30.0 kVA", "power_rating": "30.0 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:579", "componentType": "gridlabd", "treeProps": {"name": "DG_500_23_9_13_8_kV_YYT", "primary_voltage": "13800.0 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "240.0 V", "connect_type": "WYE_WYE", "impedance": "0.0168+0.0504j", "power_rating": "500 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:580", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_nonTP_11250_120", "primary_voltage": "7200 V", "install_type": "PADMOUNT", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.011 Ohm", "connect_type": "WYE_WYE", "reactance": "0.02 Ohm", "power_rating": "112.5 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:581", "componentType": "gridlabd", "treeProps": {"name": "tape_4_0", "conductor_resistance": "0.484 ohm/mile", "object": "underground_line_conductor", "shield_resistance": "3.6914 Ohm/mile", "neutral_gmr": "0.01579 ft", "outer_diameter": "1.21 in", "neutral_strands": "7", "neutral_resistance": "0.303 ohm/mile", "neutral_diameter": "0.522 in", "conductor_diameter": "0.522 in", "shield_gmr": "0.0423 ft", "conductor_gmr": "0.0158 ft"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:582", "componentType": "gridlabd", "treeProps": {"name": "transformer_configuration_2500_A_120", "primary_voltage": "7200 V", "install_type": "POLETOP", "object": "transformer_configuration", "secondary_voltage": "120 V", "resistance": "0.00600 Ohm", "connect_type": "SINGLE_PHASE_CENTER_TAPPED", "reactance": "0.00400 Ohm", "powerA_rating": "25 kVA", "power_rating": "25 kVA"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:583", "componentType": "opendss", "treeProps": {"object": "generator", "name": "NULL", "parent": "NULL", "phases": "3", "kv": "0.48", "pf": "1", "conn": "wye", "kw": "750", "kvar": "0", "xdp": "0.15", "h": "1.5", "d": "1.0", "!CONNCODE": ".1.2.3"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:584", "componentType": "opendss", "treeProps": {"object": "regcontrol", "name": "NULL", "parent": "NULL", "!CONNCODE": ".1", "transformer": "sub_regulator_a", "winding": "2", "vreg": "123.00000", "r": "0.00000", "x": "0.00000", "band": "2", "ptratio": "66.395279", "vlimit": "129.00000"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:585", "componentType": "opendss", "treeProps": {"object": "transformer", "name": "NULL", "from": "NULL", "to": "NULL", "phases": "1", "bank": "reg1", "windings": "2", "xhl": "0.0100000", "conns": "[wye,wye]", "kvs": "[7.9677,7.9677]", "kvas": "[3500,3500]", "%rs": "[0.00100000,0.00100000", "numtaps": "32", "maxtap": "1.1000", "mintap": "0.9000]"}}, "geometry": {"coordinates": [[0, 0], [0, 0]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "component:586", "componentType": "opendss", "treeProps": {"object": "line", "name": "NULL", "from": "NULL", "to": "NULL", "!FROCODE": ".1.2.3", "!TOCODE": ".1.2.3", "phases": "3", "length": "2967", "units": "ft", "linecode": "ug_3p_type1"}}, "geometry": {"coordinates": [[0, 0], [0, 0]], "type": "LineString"}}, {"type": "Feature", "properties": {"treeKey": "component:587", "componentType": "opendss", "treeProps": {"object": "capacitor", "name": "NULL", "parent": "NULL", "phases": "3", "kv": "13.80000", "kvar": "50.00000000", "enabled": "yes", "!CONNCODE": ".1.2.3"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:588", "componentType": "opendss", "treeProps": {"object": "load", "name": "NULL", "parent": "NULL", "phases": "3", "conn": "wye", "kv": "13.8", "kw": "15.290000000000001", "kvar": "3.832035216364534", "!CONNCODE": ".1.2.3.0"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:589", "componentType": "opendss", "treeProps": {"object": "linecode", "name": "NULL", "nphases": "3", "units": "mi", "rmatrix": "(0.615927|0.170927,0.615927|0.170927,0.170927,0.615927)", "xmatrix": "(1.209389|0.433188,1.209389|0.433188,0.433188,1.209389)"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:590", "componentType": "opendss", "treeProps": {"object": "loadshape", "name": "NULL", "mult": "(0,0,0,0,0,0,0,0.084654201,0.4084613,0.676864065,0.859273011,0.976124644,1,0.934483244,0.778657014,0.531155984,0.209112825,0,0,0,0,0,0,0)"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:591", "componentType": "opendss", "treeProps": {"object": "vsource.source", "name": "NULL", "bus1": "eq_source_bus.1.2.3", "phases": "3", "angle": "0.00000", "pu": "1.00000", "basekv": "69.00000", "r1": "4.54263687", "x1": "10.52743053", "r0": "7.36552668", "x0": "24.50463867"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:592", "componentType": "opendss", "treeProps": {"object": "pvsystem", "name": "NULL", "parent": "NULL", "phases": "3", "kv": "13.8", "conn": "wye", "pmpp": "110", "kva": "100", "pf": "1", "balanced": "true", "limitcurrent": "true", "vminpu": "0.9090909", "daily": "pvscaling1", "!CONNCODE": ".1.2.3"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:593", "componentType": "opendss", "treeProps": {"object": "bus", "name": "NULL"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:594", "componentType": "opendss", "treeProps": {"object": "storage", "name": "NULL", "parent": "NULL", "phases": "3", "kv": "13.8", "kwhstored": "200", "kwhrated": "200", "kva": "100", "kvar": "100", "%charge": "100", "%discharge": "100", "%effcharge": "100", "%effdischarge": "100", "%idlingkw": "1", "%r": "0", "%x": "50", "!CONNCODE": ".1.2.3"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:595", "componentType": "opendss", "treeProps": {"object": "relay", "name": "NULL", "monitoredobj": "line.cb_101"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:596", "componentType": "opendss", "treeProps": {"object": "energymeter", "name": "NULL", "element": "transformer.sub_xfmr"}}, "geometry": {"coordinates": [0, 0], "type": "Point"}}, {"type": "Feature", "properties": {"treeKey": "component:597", "componentType": "opendss", "treeProps": {"object": "!CMD", "name": "clear"}}, "geometry": {"coordinates": [null, null], "type": "Point"}}]};
        const gThisOwner = "null";
        const gThisModelName = "null";
        const gThisFeederName = "null";
        const gThisFeederNum = null;
        const gPublicFeeders = null;
        const gUserFeeders = null;
        const gCurrentUser = "null";
        const gShowFileMenu = false;
        const gIsOnline = false;
    </script>
    <script>
"use strict";

/*
 * @returns {Modal}
 */
function getLoadingModal() {
    const modal = new Modal();
    modal.showProgress(true, 'Loading Map...');
    modal.addStyleClasses(['outerModal', 'fitContent'], 'divElement');
    return modal;
}

/**
 * @param {Feature} - an ObservableInterface instance
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {Modal}
 */
function _getAnonymizationModal(observable, controller) {
    if (!(observable instanceof Feature)) {
        throw TypeError('"observable" argument must be instanceof Feature.');
    }
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    // - namesAndLabelsSelect
    const namesAndLabelsSelect = document.createElement('select');
    namesAndLabelsSelect.name = 'anonymizeNameOption';
    let option = document.createElement('option');    
    option.text = 'No Change';
    option.value = 'noChange';
    namesAndLabelsSelect.add(option);
    option = document.createElement('option');
    option.text = 'Pseudonymize';
    option.value = 'pseudonymize';
    namesAndLabelsSelect.add(option);
    option = document.createElement('option');
    option.text = 'Randomize';
    option.value = 'randomize';
    namesAndLabelsSelect.add(option);
    const namesAndLabelsSelectDiv = _getHorizontalFlexDiv();
    namesAndLabelsSelectDiv.classList.add('centerCrossAxisFlex');
    namesAndLabelsSelectDiv.classList.add('indent1');
    namesAndLabelsSelectDiv.appendChild(namesAndLabelsSelect);
    const namesAndLabelsHeading = document.createElement('span');
    namesAndLabelsHeading.textContent = 'Names and Labels';
    const namesAndLabelsHeadingDiv = _getHorizontalFlexDiv();
    namesAndLabelsHeadingDiv.classList.add('centerCrossAxisFlex');
    namesAndLabelsHeadingDiv.appendChild(namesAndLabelsHeading);
    // - locationsSelect
    const locationsSelect = document.createElement('select');
    locationsSelect.name = 'anonymizeLocationOption';
    option = document.createElement('option');
    option.text = 'No Change';
    option.value = 'noChange';
    locationsSelect.add(option);
    option = document.createElement('option');
    option.text = 'Randomize';
    option.value = 'randomize';
    locationsSelect.add(option);
    option = document.createElement('option');
    option.text = 'Force Layout';
    option.value = 'forceLayout';
    locationsSelect.add(option);
    option = document.createElement('option');
    option.text = 'Translate';
    option.value = 'translation';
    locationsSelect.add(option);
    const locationsSelectDiv = _getHorizontalFlexDiv();
    locationsSelectDiv.classList.add('centerCrossAxisFlex');
    locationsSelectDiv.classList.add('indent1');
    locationsSelectDiv.appendChild(locationsSelect);
    const locationsHeading = document.createElement('span');
    locationsHeading.textContent = 'Locations';
    const locationsHeadingDiv = _getHorizontalFlexDiv();
    locationsHeadingDiv.classList.add('centerCrossAxisFlex');
    locationsHeadingDiv.appendChild(locationsHeading);
    // - Locations inputs
    //  - Coordinates input
    const coordinatesInput = document.createElement('input');
    coordinatesInput.name = 'new_center_coords';
    coordinatesInput.placeholder = 'lat°, lon°';
    coordinatesInput.pattern = '\\(?(-?\\d+(\\.\\d+)?),\\s*(-?\\d+(\\.\\d+)?)\\)?';
    //  - Horizontal translation input
    const horizontalTranslationInput = document.createElement('input');
    horizontalTranslationInput.name = 'translateRight';
    horizontalTranslationInput.placeholder = '(+/-)meters';
    horizontalTranslationInput.pattern = '[\\-+]?\\d+';
    //  - Vertical translation input
    const verticalTranslationInput = document.createElement('input');
    verticalTranslationInput.name = 'translateUp'
    verticalTranslationInput.placeholder = '(+/-)meters';
    verticalTranslationInput.pattern = '[\\-+]?\\d+';
    //  - Rotation input
    const rotationInput = document.createElement('input');
    rotationInput.name = 'rotate';
    rotationInput.placeholder = '(+/-)angle°';
    rotationInput.pattern = '[\\-+]?\\d+(\\.\\d+)?'
    //  - Scale input
    const scaleInput = document.createElement('input');
    scaleInput.name = 'scale';
    scaleInput.value = '.01';
    scaleInput.pattern = '(\\d+)?(\\.\\d+)?';
    const scaleTipDiv = document.createElement('div');
    const scaleTipSpan = document.createElement('span');
    scaleTipSpan.textContent = 'Estimates: 0.001 = street-density, 0.01 = neighborhood-density, 0.1 = city-density, 1 = state-density';
    scaleTipDiv.appendChild(scaleTipSpan);
    // - Electrical properties
    const electricalPropertiesHeading = document.createElement('span');
    electricalPropertiesHeading.textContent = 'Electrical Properties';
    const electricalPropertiesHeadingDiv = _getHorizontalFlexDiv();
    electricalPropertiesHeadingDiv.appendChild(electricalPropertiesHeading);
    electricalPropertiesHeadingDiv.classList.add('centerCrossAxisFlex');
    // - conductorCheckbox
    const conductorCheckbox = document.createElement('input');
    conductorCheckbox.id = 'modifyLengthSize';
    conductorCheckbox.type = 'checkbox';
    conductorCheckbox.name = 'modifyLengthSize';
    const conductorLabel = document.createElement('label');    
    conductorLabel.htmlFor = 'modifyLengthSize';
    conductorLabel.innerText = 'Modify Conductor Length and Cable Size';
    // - smoothAMICheckbox
    const smoothAMICheckbox = document.createElement('input');
    smoothAMICheckbox.id = 'smoothLoadGen';
    smoothAMICheckbox.type = 'checkbox';
    smoothAMICheckbox.name = 'smoothLoadGen';
    const smoothAMILabel = document.createElement('label');    
    smoothAMILabel.htmlFor = 'smoothLoadGen';
    smoothAMILabel.innerText = 'Smooth AMI Loadshapes';
    // - shuffleLoadsCheckbox
    const shuffleLoadsCheckbox = document.createElement('input');
    shuffleLoadsCheckbox.id = 'shuffleLoadGen';
    shuffleLoadsCheckbox.type = 'checkbox';
    shuffleLoadsCheckbox.name = 'shuffleLoadGen';
    const shuffleLoadsLabel = document.createElement('label');    
    shuffleLoadsLabel.htmlFor = 'shuffleLoadGen';
    shuffleLoadsLabel.innerText = ' Shuffle Loads and Generators';
    const shuffleLoadsInput = document.createElement('input');
    shuffleLoadsInput.name = 'shufflePerc';
    shuffleLoadsInput.placeholder = '(1-100)'
    shuffleLoadsInput.pattern = '(\\d+)?(\\.\\d+)?';
    // - addNoiseCheckbox
    const addNoiseCheckbox = document.createElement('input');
    addNoiseCheckbox.id = 'addNoise';
    addNoiseCheckbox.type = 'checkbox';
    addNoiseCheckbox.name = 'addNoise';
    const addNoiseLabel = document.createElement('label');    
    addNoiseLabel.htmlFor = 'addNoise';
    addNoiseLabel.innerText = 'Add Noise';
    const addNoiseInput = document.createElement('input');
    addNoiseInput.name = 'noisePerc';
    addNoiseInput.placeholder = '(1-100)'
    addNoiseInput.pattern = '(\\d+)?(\\.\\d+)?';
    // - Submit button
    const submitButton = _getSubmitButton();
    const submitDiv = _getSubmitDiv(submitButton);
    // - Event listeners
    // - namesAndLabelsSelect
    namesAndLabelsSelect.addEventListener('change', function() {
        observable.setProperty(this.name, this.value, 'formProps');
    });
    // - locationsSelect
    locationsSelect.addEventListener('change', function() {
        observable.setProperty(this.name, this.value, 'formProps');
        const translateModal = this.parentElement.nextElementSibling;
        if (this.value === 'translation') {
            translateModal.classList.remove('collapsed');
            if (!translateModal.classList.contains('expanded')) {
                translateModal.classList.add('expanded');
            }
        } else {
            translateModal.classList.remove('expanded');
            if (!translateModal.classList.contains('collapsed')) {
                translateModal.classList.add('collapsed');
            }
        }
        const scaleModal = this.parentElement.nextElementSibling.nextElementSibling;
        if (this.value === 'forceLayout') {
            scaleModal.classList.remove('collapsed');
            if (!scaleModal.classList.contains('expanded')) {
                scaleModal.classList.add('expanded');
            }
        } else {
            scaleModal.classList.remove('expanded');
            if (!scaleModal.classList.contains('collapsed')) {
                scaleModal.classList.add('collapsed');
            }
        }
    });
    // - Locations inputs
    coordinatesInput.addEventListener('change', function() {
        const value = this.value.trim();
        observable.setProperty(this.name, value, 'formProps');
    });
    horizontalTranslationInput.addEventListener('change', function() {
        const value = this.value.trim();
        observable.setProperty(this.name, value, 'formProps');
    });
    verticalTranslationInput.addEventListener('change', function() {
        const value = this.value.trim();
        observable.setProperty(this.name, value, 'formProps');
    });
    rotationInput.addEventListener('change', function() {
        const value = this.value.trim();
        observable.setProperty(this.name, value, 'formProps');
    });
    scaleInput.addEventListener('change', function() {
        const value = this.value.trim();
        observable.setProperty(this.name, value, 'formProps');
    });
    // - conductorCheckbox
    conductorCheckbox.addEventListener('change', function() {
        let value = '';
        if (this.checked) {
            value = 'modifyLengthSize';
        }
        observable.setProperty(this.name, value, 'formProps');
    });
    // - smoothAMICheckbox
    smoothAMICheckbox.addEventListener('change', function() {
        let value = '';
        if (this.checked) {
            value = 'smoothLoadGen';
        }
        observable.setProperty(this.name, value, 'formProps');
    });
    // - shuffleLoadsCheckbox
    shuffleLoadsCheckbox.addEventListener('change', function() {
        let value = '';
        if (this.checked) {
            value = 'shuffleLoadGen';
        } else {
            shuffleLoadsInput.setCustomValidity('');
            shuffleLoadsInput.value = '';
        }
        observable.setProperty(this.name, value, 'formProps');
        let parentElement = this.parentElement;
        while (!parentElement.classList.contains('js-div--modal')) {
            parentElement = parentElement.parentElement;
        }
        if (this.checked) {
            parentElement.nextSibling.classList.remove('collapsed');
            parentElement.nextSibling.classList.add('expanded');
        } else {
            if (!parentElement.nextSibling.classList.contains('collapsed')) {
                parentElement.nextSibling.classList.add('collapsed');
            }
        }
    });
    shuffleLoadsInput.addEventListener('change', function() {
        this.setCustomValidity('');
        const value = +this.value.trim();
        if (isNaN(value)) {
            this.setCustomValidity('Please enter a valid integer or float.');
            this.reportValidity();
        } else if (value <= 0 || value > 100 || this.validity.patternMismatch) {
            this.setCustomValidity('Please enter a valid integer or float greater than 0 and less than or equal to 100.');
            this.reportValidity();
        } else if (this.validity.valid) {
            observable.setProperty(this.name, value, 'formProps');
        }
    });
    // - addNoiseCheckbox
    addNoiseCheckbox.addEventListener('change', function() {
        let value = '';
        if (this.checked) {
            value = 'addNoise';
        } else {
            addNoiseInput.setCustomValidity('');
            addNoiseInput.value = '';
        }
        observable.setProperty(this.name, value, 'formProps');
        let parentElement = this.parentElement;
        while (!parentElement.classList.contains('js-div--modal')) {
            parentElement = parentElement.parentElement;
        }
        if (this.checked) {
            parentElement.nextSibling.classList.remove('collapsed');
            parentElement.nextSibling.classList.add('expanded');
        } else {
            if (!parentElement.nextSibling.classList.contains('collapsed')) {
                parentElement.nextSibling.classList.add('collapsed');
            }
        }
    });
    addNoiseInput.addEventListener('change', function() {
        this.setCustomValidity('');
        const value = +this.value.trim();
        if (isNaN(value)) {
            this.setCustomValidity('Please enter a valid integer or float.');
            this.reportValidity();
        } else if (value <= 0 || value > 100 || this.validity.patternMismatch) {
            this.setCustomValidity('Please enter a valid integer or float greater than 0 and less than or equal to 100.');
            this.reportValidity();
        } else if (this.validity.valid) {
            observable.setProperty(this.name, value, 'formProps');
        }
    });
    // - Modal
    const mainModal = new Modal();
    mainModal.addStyleClasses(['outerModal', 'fitContent'], 'divElement');
    const modalInsert = document.getElementById('modalInsert');
    submitButton.addEventListener('click', async function() {
        if (coordinatesInput.checkValidity() && horizontalTranslationInput.checkValidity() && verticalTranslationInput.checkValidity() && rotationInput.checkValidity() && scaleInput.checkValidity() && shuffleLoadsInput.checkValidity() && addNoiseInput.checkValidity()) {
            modalInsert.removeEventListener('click', hideModalInsert);
            const saveFeature = _getSaveFeature();
            saveFeature.setProperty('feederObjectJson', JSON.stringify(controller.observableGraph.getObservableExportData()), 'formProps');
            const saveModal = _getSaveModal(controller);
            modalInsert.replaceChildren(saveModal.divElement);
            await controller.submitFeature(saveFeature, saveModal, null, false);
            modalInsert.removeEventListener('click', hideModalInsert);
            document.getElementById('modalInsert').classList.add('visible');
            modalInsert.replaceChildren(mainModal.divElement);
            mainModal.showProgress(true, 'Anonymization working...', ['caution']);
            controller.submitFeature(observable, mainModal, submitButton);
        } else {
            coordinatesInput.reportValidity();
            horizontalTranslationInput.reportValidity();
            verticalTranslationInput.reportValidity();
            rotationInput.reportValidity();
            scaleInput.reportValidity();
            shuffleLoadsInput.reportValidity();
            addNoiseInput.reportValidity();
        }
    });
    mainModal.setTitle('Anonymization');
    mainModal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'titleElement');
    mainModal.insertElement(namesAndLabelsHeadingDiv);
    mainModal.insertElement(namesAndLabelsSelectDiv);
    mainModal.insertElement(locationsHeadingDiv);
    mainModal.insertElement(locationsSelectDiv);
    const translateModal = new Modal();
    translateModal.insertTBodyRow(['Shift center to', coordinatesInput, 'coordinates within the contiguous/non-contiguous USA']);
    translateModal.insertTBodyRow(['Translate', horizontalTranslationInput, 'meters rightwards']);
    translateModal.insertTBodyRow(['Translate', verticalTranslationInput, 'meters upwards']);
    translateModal.insertTBodyRow(['Rotate', rotationInput, 'degrees counterclockwise']);
    translateModal.addStyleClasses(['collapsed', 'indent2'], 'divElement');
    mainModal.insertElement(translateModal.divElement);
    const scaleModal = new Modal();
    scaleModal.insertTBodyRow(['Force layout with following scale factor', scaleInput]);
    scaleModal.insertElement(scaleTipDiv);
    scaleModal.addStyleClasses(['collapsed', 'indent2'], 'divElement');
    mainModal.insertElement(scaleModal.divElement);
    const electricalPropertiesHeadingModal = new Modal();
    electricalPropertiesHeadingModal.insertElement(electricalPropertiesHeadingDiv);
    mainModal.insertElement(electricalPropertiesHeadingModal.divElement);
    const electricalPropertiesModal = new Modal();
    electricalPropertiesModal.insertTBodyRow([conductorCheckbox, conductorLabel]);
    electricalPropertiesModal.insertTBodyRow([smoothAMICheckbox, smoothAMILabel]);
    electricalPropertiesModal.insertTBodyRow([shuffleLoadsCheckbox, shuffleLoadsLabel]);
    electricalPropertiesModal.addStyleClasses(['indent1'], 'divElement');
    mainModal.insertElement(electricalPropertiesModal.divElement);
    const shuffleLoadsInputModal = new Modal();
    shuffleLoadsInputModal.insertTBodyRow(['Shuffle', shuffleLoadsInput, 'percent']);
    shuffleLoadsInputModal.addStyleClasses(['collapsed', 'indent2'], 'divElement');
    mainModal.insertElement(shuffleLoadsInputModal.divElement);
    const addNoiseCheckboxModal = new Modal();
    addNoiseCheckboxModal.insertTBodyRow([addNoiseCheckbox, addNoiseLabel])
    addNoiseCheckboxModal.addStyleClasses(['indent1'], 'divElement');
    mainModal.insertElement(addNoiseCheckboxModal.divElement);
    const addNoiseInputModal = new Modal();
    addNoiseInputModal.insertTBodyRow(['Add', addNoiseInput, 'percent noise']);
    addNoiseInputModal.addStyleClasses(['collapsed', 'indent2'], 'divElement');
    mainModal.insertElement(addNoiseInputModal.divElement);
    const submitDivModal = new Modal();
    submitDivModal.insertElement(submitDiv);
    submitDivModal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'containerElement');
    mainModal.insertElement(submitDivModal.divElement);
    return mainModal;
}

/**
 * @param {FeatureController} controller - a FeatureController instance
 * @returns {HTMLDivElement}
 */
function getAnonymizationDiv(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const feature = new Feature({
        geometry: { 'coordinates': [null, null], 'type': 'Point' },
        properties: {
            treeKey: 'modal:anonymization',
            urlProps: {
                fileExistsUrl: {
                    method: 'GET',
                    url: `/uniqObjName/Feeder/${gThisOwner}/${gThisFeederName}/${gThisModelName}`
                },
                pollUrl: {
                    method: 'GET',
                    url: `/checkConversion/${gThisModelName}/${gThisOwner}`
                },
                submitUrl: {
                    method: 'POST',
                    url: `/anonymize/${gThisOwner}/${gThisFeederName}`
                }
            },
            formProps: {
                modelName: gThisModelName,
                anonymizeNameOption: 'noChange',
                anonymizeLocationOption: 'noChange',
                new_center_coords: '',
                translateRight: '',
                translateUp: '',
                rotate: '',
                // - In Python, bool('') returns a False bool. FormData objects can only send strings
                modifyLengthSize: '',       // 'modifyLengthSize',
                smoothLoadGen: '',          // 'smoothLoadGen',
                shuffleLoadGen: '',         // 'shuffleLoadGen',
                shufflePerc: '',
                addNoise: '',               // 'addNoise'
                noisePerc: '',
                scale: '.01' 
            },
        },
        type: 'Feature'
    });
    const modal = _getAnonymizationModal(feature, controller);
    const modalInsert = document.getElementById('modalInsert');
    const div = _getMenuDiv('Anonymization...');
    div.addEventListener('click', function() {
        modalInsert.replaceChildren(modal.divElement);
        modalInsert.classList.add('visible');
    });
    return div;
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {Modal}
 */
function _getSaveModal(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const modal = new Modal();
    modal.showProgress(true, 'Saving...');
    modal.addStyleClasses(['outerModal', 'fitContent'], 'divElement');
    return modal;
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {HTMLDivElement}
 */
function getSaveDiv(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const saveFeature = _getSaveFeature();
    const modal = _getSaveModal(controller);
    const div = _getMenuDiv('Save');
    div.id = 'saveDiv';
    const modalInsert = document.getElementById('modalInsert');
    div.addEventListener('click', function() {
        modalInsert.removeEventListener('click', hideModalInsert);
        modalInsert.replaceChildren(modal.divElement);
        modalInsert.classList.add('visible');
        // - I only export features that were originally in the OMD (i.e. those features with numeric tree keys)
        saveFeature.setProperty('feederObjectJson', JSON.stringify(controller.observableGraph.getObservableExportData()), 'formProps')
        controller.submitFeature(saveFeature, modal, null, false); 
    });
    return div;
}

/**
 * @returns {Feature}
 */
function _getSaveFeature() {
    return new Feature({
        geometry: { 'coordinates': [null, null], 'type': 'Point' },
        properties: {
            treeKey: 'modal:save',
            urlProps: {
                submitUrl: {
                    method: 'POST',
                    url: `/saveFeeder/${gThisOwner}/${gThisModelName}/${gThisFeederName}/${gThisFeederNum}`
                }
            },
            // - I need to read all of the data every time the save button is clicked, so set "feederObjectJson" in the event handler function
            formProps: {},
        },
        type: 'Feature'
    });
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {Modal}
 */
function _getRawDataModal(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const modal = new Modal();
    modal.showProgress(true, 'Opening a window with JSON in it that you can save as a .json file...');
    modal.addStyleClasses(['outerModal', 'fitContent'], 'divElement');
    return modal;
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {HTMLDivElement}
 */
function getRawDataDiv(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const modal = _getRawDataModal(controller);
    const div = _getMenuDiv('View raw data');
    const modalInsert = document.getElementById('modalInsert');
    div.addEventListener('click', function() {
        modalInsert.replaceChildren(modal.divElement);
        modalInsert.classList.add('visible');
        const json = JSON.stringify(controller.observableGraph.getObservableExportData());
        const win = window.open();
        win.document.write(json);
    });
    return div;
}

/**
 * @param {Feature} observable
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {Modal}
 */
function _getRenameModal(observable, controller) {
    if (!(observable instanceof Feature)) {
        throw TypeError('The "observable" argument must be instanceof Feature.');
    }
    if (!(controller instanceof FeatureController)) {
        throw TypeError('The "controller" argument must be instanceof FeatureController.');
    }
    // - Input
    const input = _getNameInput(observable, function(newName) {
        const fileExistsUrl = {
            method: 'GET',
            url: `/uniqObjName/Feeder/${gThisOwner}/${newName}/${gThisModelName}`
        }
        observable.setProperty('fileExistsUrl', fileExistsUrl, 'urlProps');
        const submitUrl = {
            method: 'GET',
            url: `/renameFeeder/${gThisOwner}/${gThisModelName}/${gThisFeederName}/${newName}/${gThisFeederNum}`
        }
        observable.setProperty('submitUrl', submitUrl, 'urlProps');
    });
    // - Submit div
    const submitButton = _getSubmitButton();
    const submitDiv = _getSubmitDiv(submitButton);
    // - Modal
    const renameModal = new Modal();
    renameModal.addStyleClasses(['outerModal', 'fitContent'], 'divElement');
    const modalInsert = document.getElementById('modalInsert');
    submitButton.addEventListener('click', async function() {
        if (input.checkValidity()) {
            modalInsert.removeEventListener('click', hideModalInsert);
            const saveFeature = _getSaveFeature();
            saveFeature.setProperty('feederObjectJson', JSON.stringify(controller.observableGraph.getObservableExportData()), 'formProps')
            const saveModal = _getSaveModal(controller);
            modalInsert.replaceChildren(saveModal.divElement);
            await controller.submitFeature(saveFeature, saveModal, null, false);
            modalInsert.removeEventListener('click', hideModalInsert);
            document.getElementById('modalInsert').classList.add('visible');
            modalInsert.replaceChildren(renameModal.divElement);
            renameModal.showProgress(true, 'Renaming feeder...', ['caution']);
            controller.submitFeature(observable, renameModal, submitButton);
        } else {
            input.reportValidity();
        }
    });
    renameModal.setTitle('Rename Feeder');
    renameModal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'titleElement');
    renameModal.insertTBodyRow(['New feeder name:', input]);
    renameModal.addStyleClasses(['centeredTable'], 'tableElement');
    renameModal.insertElement(submitDiv);
    renameModal.addStyleClasses(['verticalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'containerElement');
    return renameModal;
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {HTMLDivElement}
 */
function getRenameDiv(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const feature = new Feature({
        geometry: { 'coordinates': [null, null], 'type': 'Point' },
        properties: {
            treeKey: 'modal:rename',
            urlProps: {
                fileExistsUrl: {
                    method: 'GET',
                    url: `/uniqObjName/Feeder/${gThisOwner}/Default Name/${gThisModelName}`
                },
                submitUrl: {
                    method: 'GET',
                    url: `/renameFeeder/${gThisOwner}/${gThisModelName}/${gThisFeederName}/Default Name/${gThisFeederNum}`
                }
            }
        },
        type: 'Feature'
    });
    const modal = _getRenameModal(feature, controller);
    const div = _getMenuDiv('Rename...');
    const modalInsert = document.getElementById('modalInsert');
    div.addEventListener('click', function() {
        modalInsert.replaceChildren(modal.divElement);
        modalInsert.classList.add('visible');
    });
    return div;
}

/**
 * @param {Feature} observable
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {Modal}
 */
function _getLoadFeederModal(observable, controller) {
    if (!(observable instanceof Feature)) {
        throw TypeError('"observable" argument must be instanceof Feature.');
    }
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    // - Create list of public feeders
    let publicFeeders = [];
    if (gPublicFeeders !== null) {
        publicFeeders = [...gPublicFeeders];
        publicFeeders.sort((a, b) => a.name.localeCompare(b.name, 'en', {numeric: true}));
    }
    const publicFeedersModal = new Modal();
    const modalInsert = document.getElementById('modalInsert');
    publicFeeders.map(obj => {
        const outerDiv = document.createElement('div');
        const nameDiv = document.createElement('div');
        nameDiv.textContent = obj.name;
        outerDiv.appendChild(nameDiv);
        const modelDiv = document.createElement('div');
        modelDiv.textContent = `from "${obj.model}"`;
        outerDiv.appendChild(modelDiv);
        outerDiv.addEventListener('click', function() {
            modalInsert.removeEventListener('click', hideModalInsert);
            observable.setProperty('fileExistsUrl', {
                method: 'GET', 
                url: `/uniqObjName/Feeder/public/${obj.name}/${obj.model}`
            }, 'urlProps');
            observable.setProperty('submitUrl', {
                method: 'POST',
                url: `/loadFeeder/${obj.name}/${obj.model}/${gThisModelName}/${gThisFeederNum}/public/${gThisOwner}`,
            }, 'urlProps');
            controller.submitFeature(observable, publicFeedersModal); 
        });
        outerDiv.classList.add('hoverable');
        return outerDiv;
    }).forEach(div => publicFeedersModal.insertTBodyRow([div]));
    publicFeedersModal.setTitle('Public Feeders');
    publicFeedersModal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'titleElement');
    publicFeedersModal.addStyleClasses(['fullWidth'], 'tableElement');
    // - Create list of user feeders
    let userFeeders = [];
    if (gUserFeeders !== null) {
        userFeeders = [...gUserFeeders];
        userFeeders.sort((a, b) => a.name.localeCompare(b.name, 'en', {numeric: true}));
    }
    const userFeedersModal = new Modal();
    userFeeders.map(obj => {
        const outerDiv = document.createElement('div');
        const nameDiv = document.createElement('div');
        nameDiv.textContent = obj.name;
        outerDiv.appendChild(nameDiv);
        const modelDiv = document.createElement('div');
        modelDiv.textContent = `from "${obj.model}"`;
        outerDiv.appendChild(modelDiv);
        outerDiv.addEventListener('click', function() {
            modalInsert.removeEventListener('click', hideModalInsert);
            observable.setProperty('fileExistsUrl', {
                method: 'GET',
                // - Let's say I'm an admin viewing some user's file. gCurrentUser = "admin" and gThisOwner = "test". userFeeders is all of the
                //   admin's feeders. Therefore, to see if the admin's feeders exist in order to load them, I need /uniqObjName to check the current
                //   user's feeders, NOT the owner's feeders. Usually, gThisOwner === gCurrentUser, but this one special case is why this url is
                //   different
                url: `/uniqObjName/Feeder/${gCurrentUser}/${obj.name}/${obj.model}`
            }, 'urlProps');
            observable.setProperty('submitUrl', {
                method: 'POST',
                url: `/loadFeeder/${obj.name}/${obj.model}/${gThisModelName}/${gThisFeederNum}/${gCurrentUser}/${gThisOwner}`,
            }, 'urlProps');
            controller.submitFeature(observable, userFeedersModal); 
        });
        outerDiv.classList.add('hoverable');
        return outerDiv;
    }).forEach(div => userFeedersModal.insertTBodyRow([div]));
    userFeedersModal.setTitle('User Feeders');
    userFeedersModal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'titleElement');
    userFeedersModal.addStyleClasses(['fullWidth'], 'tableElement');
    // - Main modal
    const mainModal = new Modal();
    mainModal.addStyleClasses(['outerModal', 'loadFeederModal'], 'divElement');
    mainModal.setTitle('Load Feeder');
    mainModal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'titleElement');
    mainModal.insertElement(publicFeedersModal.divElement);
    mainModal.insertElement(userFeedersModal.divElement);
    mainModal.addStyleClasses(['horizontalFlex'], 'containerElement');
    return mainModal;
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {HTMLDivElement}
 */
function getLoadFeederDiv(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const feature = new Feature({
        geometry: { 'coordinates': [null, null], 'type': 'Point' },
        properties: {
            treeKey: 'modal:loadFeeder',
            urlProps: {},
            formProps: {
                referrer: 'distribution'
            }
        },
        'type': 'Feature'
    });
    const modal = _getLoadFeederModal(feature, controller);
    const div = _getMenuDiv('Load from model...');
    const modalInsert = document.getElementById('modalInsert');
    div.addEventListener('click', function() {
        modalInsert.replaceChildren(modal.divElement);
        modalInsert.classList.add('visible');
    });
    return div;
}

/**
 * @param {Feature} observable
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {Modal}
 */
function _getBlankFeederModal(observable, controller) {
    if (!(observable instanceof Feature)) {
        throw TypeError('"observable" argument must be instanceof Feature.');
    }
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    // - Input
    const input = _getNameInput(observable, function(newName) {
        observable.setProperty('feederNameNew', newName, 'formProps');
    });
    // - Submit div
    const submitButton = _getSubmitButton();
    const submitDiv = _getSubmitDiv(submitButton);
    // - Modal
    const modal = new Modal();
    modal.addStyleClasses(['outerModal', 'fitContent'], 'divElement');
    const modalInsert = document.getElementById('modalInsert');
    submitButton.addEventListener('click', function() {
        if (input.checkValidity()) {
            modalInsert.removeEventListener('click', hideModalInsert);
            modal.showProgress(true, 'Creating new blank feeder...', ['caution']);
            controller.submitFeature(observable, modal, submitButton);
        } else {
            input.reportValidity();
        }
    });
    modal.setTitle('New Blank Feeder');
    modal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'titleElement');
    modal.insertTBodyRow(['Blank feeder name', input]);
    modal.addStyleClasses(['centeredTable'], 'tableElement');
    modal.insertElement(submitDiv);
    modal.addStyleClasses(['verticalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'containerElement');
    return modal;
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {HTMLDivElement}
 */
function getBlankFeederDiv(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const feature = new Feature({
        geometry: { 'coordinates': [null, null], 'type': 'Point' },
        properties: {
            treeKey: 'modal:blankFeeder',
            urlProps: {
                submitUrl: {
                    method: 'POST',
                    url: `/newBlankFeeder/${gThisOwner}`
                }
            },
            formProps: {
                modelName: gThisModelName,
                feederNameNew: 'Default Name',
                feederNum: gThisFeederNum,
                referrer: 'distribution'
            }
        },
        type: 'Feature'
    });
    const modal = _getBlankFeederModal(feature, controller);
    const div = _getMenuDiv('New blank feeder...');
    const modalInsert = document.getElementById('modalInsert');
    div.addEventListener('click', function() {
        modalInsert.replaceChildren(modal.divElement);
        modalInsert.classList.add('visible');
    });
    return div;
}

/**
 * @param {Feature} observable
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {Modal}
 */
function _getWindmilModal(observable, controller) {
    if (!(observable instanceof Feature)) {
        throw TypeError('"observable" argument must be instanceof Feature.');
    }
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    // - Name input
    const nameInput = _getNameInput(observable, function(newName) {
        observable.setProperty('feederNameM', newName, 'formProps');
        const fileExistsUrl = {
            method: 'GET',
            url: `/uniqObjName/Feeder/${gThisOwner}/${newName}/${gThisModelName}`
        }
        observable.setProperty('fileExistsUrl', fileExistsUrl, 'urlProps');
    });
    nameInput.id = 'milsoftNameInput';
    const nameLabel = document.createElement('label');
    nameLabel.htmlFor = 'milsoftNameInput';
    nameLabel.innerText = 'Name';
    // - .std file input
    const stdInput = document.createElement('input');
    stdInput.type = 'file';
    stdInput.accept = '.std';
    stdInput.required = true;
    stdInput.id = 'milsoftStdInput';
    const stdLabel = document.createElement('label');
    stdLabel.htmlFor = 'milsoftStdInput';
    stdLabel.innerHTML = 'Data File (.std)';
    // .seq file input
    const seqInput = document.createElement('input');
    seqInput.type = 'file';
    seqInput.accept = '.seq';
    seqInput.required = true;
    seqInput.id = 'milsoftSeqInput';
    const seqLabel = document.createElement('label');
    seqLabel.htmlFor = 'milsoftSeqInput';
    seqLabel.innerText = 'Equipment File (.seq)';
    // - Submit div
    const submitButton = _getSubmitButton('Import');
    const submitDiv = _getSubmitDiv(submitButton);
    // - Event listeners
    stdInput.addEventListener('change', function() {
        const stdFile = this.files[0];
        observable.setProperty('stdFile', stdFile, 'formProps');
    });
    seqInput.addEventListener('change', function() {
        const seqFile = this.files[0];
        observable.setProperty('seqFile', seqFile, 'formProps');
    });
    // - Modal
    const modal = new Modal();
    modal.addStyleClasses(['outerModal', 'fitContent'], 'divElement');
    const modalInsert = document.getElementById('modalInsert');
    submitButton.addEventListener('click', function() {
        if (nameInput.checkValidity() && stdInput.checkValidity() && seqInput.checkValidity()) {
            modalInsert.removeEventListener('click', hideModalInsert);
            modal.showProgress(true, 'Importing file...', ['caution']);
            controller.submitFeature(observable, modal, submitButton);
        } else {
            nameInput.reportValidity();
            stdInput.reportValidity();
            seqInput.reportValidity();
        }
    });
    modal.setTitle('Milsoft Conversion');
    modal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'titleElement');
    modal.insertTBodyRow([nameLabel, nameInput]);
    modal.insertTBodyRow([stdLabel, stdInput]);
    modal.insertTBodyRow([seqLabel, seqInput]);
    modal.insertElement(submitDiv);
    modal.addStyleClasses(['verticalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'containerElement');
    return modal;
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {HTMLDivElement}
 */
function getWindmilDiv(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const feature = new Feature({
        geometry: { 'coordinates': [null, null], 'type': 'Point' },
        properties: {
            treeKey: 'modal:windmil',
            urlProps: {
                fileExistsUrl: {
                    method: 'GET',
                    url: `/uniqObjName/Feeder/${gThisOwner}/Default Name/${gThisModelName}`
                },
                pollUrl: {
                    method: 'GET',
                    url: `/checkConversion/${gThisModelName}/${gThisOwner}`
                },
                submitUrl: {
                    method: 'POST',
                    url: `/milsoftImport/${gThisOwner}`                    
                }
            },
            formProps: {
                modelName: gThisModelName,
                feederNameM: 'Default Name',
                feederNum: gThisFeederNum,
                stdFile: '',
                seqFile: ''
            }
        },
        type: 'Feature'
    });
    const modal = _getWindmilModal(feature, controller);
    const div = _getMenuDiv('Windmil conversion...');
    const modalInsert = document.getElementById('modalInsert');
    div.addEventListener('click', function() {
        modalInsert.replaceChildren(modal.divElement);
        modalInsert.classList.add('visible');
    });
    return div;
}

/**
 * @param {Feature} observable
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {Modal}
 */
function _getGridlabdModal(observable, controller) {
    if (!(observable instanceof Feature)) {
        throw TypeError('"observable" argument must be instanceof Feature.');
    }
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    // - Name input
    const nameInput = _getNameInput(observable, function(newName) {
        observable.setProperty('feederNameG', newName, 'formProps');
        const fileExistsUrl = {
            method: 'GET',
            url: `/uniqObjName/Feeder/${gThisOwner}/${newName}/${gThisModelName}`
        }
        observable.setProperty('fileExistsUrl', fileExistsUrl, 'urlProps');
    });
    nameInput.id = 'gridlabdNameInput';
    const nameLabel = document.createElement('label');
    nameLabel.htmlFor = 'gridlabdNameInput';
    nameLabel.innerText = 'Name';
    // - .glm file input
    const glmInput = document.createElement('input');
    glmInput.type = 'file';
    glmInput.accept = '.glm';
    glmInput.required = true;
    glmInput.id = 'glmInput';
    const glmLabel = document.createElement('label');
    glmLabel.htmlFor = 'glmInput';
    glmLabel.innerHTML = 'Data File (.glm)';
    // - Submit div
    const submitButton = _getSubmitButton('Import');
    const submitDiv = _getSubmitDiv(submitButton);
    // - Event listeners
    glmInput.addEventListener('change', function() {
        const glmFile = this.files[0];
        observable.setProperty('glmFile', glmFile, 'formProps');
    });
    // - Modal
    const modal = new Modal();
    modal.addStyleClasses(['outerModal', 'fitContent'], 'divElement');
    const modalInsert = document.getElementById('modalInsert');
    submitButton.addEventListener('click', function() {
        if (nameInput.checkValidity() && glmInput.checkValidity()) {
            modalInsert.removeEventListener('click', hideModalInsert);
            modal.showProgress(true, 'Importing file...', ['caution']);
            controller.submitFeature(observable, modal, submitButton);
        } else {
            nameInput.reportValidity();
            glmInput.reportValidity();
        }
    });
    modal.setTitle('GridLABD-D Conversion');
    modal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'titleElement');
    modal.insertTBodyRow([nameLabel, nameInput]);
    modal.insertTBodyRow([glmLabel, glmInput]);
    modal.insertElement(submitDiv);
    modal.addStyleClasses(['verticalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'containerElement');
    return modal;
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {HTMLDivElement}
 */
function getGridlabdDiv(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const feature = new Feature({
        geometry: { 'coordinates': [null, null], 'type': 'Point' },
        properties: {
            treeKey: 'modal:gridlabd',
            urlProps: {
                fileExistsUrl: {
                    method: 'GET',
                    url: `/uniqObjName/Feeder/${gThisOwner}/Default Name/${gThisModelName}`
                },
                pollUrl: {
                    method: 'GET',
                    url: `/checkConversion/${gThisModelName}/${gThisOwner}`
                },
                submitUrl: {
                    method: 'POST',
                    url: `/gridlabdImport/${gThisOwner}`
                }
            },
            formProps: {
                modelName: gThisModelName,
                feederNameG: 'Default Name',
                feederNum: gThisFeederNum,
                glmFile: ''
            }
        },
        type: 'Feature'
    });
    const modal = _getGridlabdModal(feature, controller);
    const div = _getMenuDiv('GridLAB-D conversion...');
    const modalInsert = document.getElementById('modalInsert');
    div.addEventListener('click', function() {
        modalInsert.replaceChildren(modal.divElement);
        modalInsert.classList.add('visible');
    });
    return div;
}
/**
 * @param {Feature} observable
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {Modal}
 */
function _getCymdistModal(observable, controller) {
    if (!(observable instanceof Feature)) {
        throw TypeError('"observable" argument must be instanceof Feature.');
    }
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    // - Name input
    const nameInput = _getNameInput(observable, function(newName) {
        observable.setProperty('feederNameC', newName, 'formProps');
        const fileExistsUrl = {
            method: 'GET',
            url: `/uniqObjName/Feeder/${gThisOwner}/${newName}/${gThisModelName}`
        }
        observable.setProperty('fileExistsUrl', fileExistsUrl, 'urlProps');
    });
    nameInput.id = 'cymdistNameInput';
    const nameLabel = document.createElement('label');
    nameLabel.htmlFor = 'cymdistNameInput';
    nameLabel.innerText = 'Name';
    // - .mdb file input
    const mdbInput = document.createElement('input');
    mdbInput.type = 'file';
    mdbInput.accept = '.mdb';
    mdbInput.required = true;
    mdbInput.id = 'mdbInput';
    const mdbLabel = document.createElement('label');
    mdbLabel.htmlFor = 'mdbInput';
    mdbLabel.innerHTML = 'Network File (.mdb)';
    // - Submit div
    const submitButton = _getSubmitButton('Import');
    const submitDiv = _getSubmitDiv(submitButton);
    // - Event listeners
    mdbInput.addEventListener('change', function() {
        const mdbFile = this.files[0];
        observable.setProperty('mdbNetFile', mdbFile, 'formProps');
    });
    // - Modal
    const modal = new Modal();
    modal.addStyleClasses(['outerModal', 'fitContent'], 'divElement');
    const modalInsert = document.getElementById('modalInsert');
    submitButton.addEventListener('click', function() {
        if (nameInput.checkValidity() && mdbInput.checkValidity()) {
            modalInsert.removeEventListener('click', hideModalInsert);
            modal.showProgress(true, 'Importing file...', ['caution']);
            controller.submitFeature(observable, modal, submitButton);
        } else {
            nameInput.reportValidity();
            mdbInput.reportValidity();
        }
    });
    modal.setTitle('Cyme Conversion');
    modal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'titleElement');
    modal.insertTBodyRow([nameLabel, nameInput]);
    modal.insertTBodyRow([mdbLabel, mdbInput]);
    modal.insertElement(submitDiv);
    modal.addStyleClasses(['verticalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'containerElement');
    return modal;
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {HTMLDivElement}
 */
function getCymdistDiv(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const feature = new Feature({
        geometry: { 'coordinates': [null, null], 'type': 'Point' },
        properties: {
            treeKey: 'modal:cymdist',
            urlProps: {
                fileExistsUrl: {
                    method: 'GET',
                    url: `/uniqObjName/Feeder/${gThisOwner}/Default Name/${gThisModelName}`
                },
                pollUrl: {
                    method: 'GET',
                    url: `/checkConversion/${gThisModelName}/${gThisOwner}`
                },
                submitUrl: {
                    method: 'POST',
                    url: `/cymeImport/${gThisOwner}`
                }
            },
            formProps: {
                modelName: gThisModelName,
                feederNum: gThisFeederNum,
                feederNameC: 'Default Name',
                mdbNetFile: ''
            }
        },
        type: 'Feature'
    });
    const modal = _getCymdistModal(feature, controller);
    const div = _getMenuDiv('CYMDIST conversion...');
    const modalInsert = document.getElementById('modalInsert');
    div.addEventListener('click', function() {
        modalInsert.replaceChildren(modal.divElement);
        modalInsert.classList.add('visible');
    });
    return div;
}

/**
 * @param {Feature} observable
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {Modal}
 */
function _getOpendssModal(observable, controller) {
    if (!(observable instanceof Feature)) {
        throw TypeError('"observable" argument must be instanceof Feature.');
    }
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    // - Name input
    const nameInput = _getNameInput(observable, function(newName) {
        observable.setProperty('feederNameOpendss', newName, 'formProps');
        const fileExistsUrl = {
            method: 'GET',
            url: `/uniqObjName/Feeder/${gThisOwner}/${newName}/${gThisModelName}`
        }
        observable.setProperty('fileExistsUrl', fileExistsUrl, 'urlProps');
    });
    nameInput.id = 'opendssNameInput';
    const nameLabel = document.createElement('label');
    nameLabel.htmlFor = 'opendssNameInput';
    nameLabel.innerText = 'Name';
    // - .dss file input
    const dssInput = document.createElement('input');
    dssInput.type = 'file';
    dssInput.accept = '.dss';
    dssInput.required = true;
    dssInput.id = 'dssInput';
    const dssLabel = document.createElement('label');
    dssLabel.htmlFor = 'dssInput';
    dssLabel.innerHTML = 'Data File (.dss)';
    // - Submit div
    const submitButton = _getSubmitButton('Import');
    const submitDiv = _getSubmitDiv(submitButton);
    // - Event listeners 
    dssInput.addEventListener('change', function() {
        const dssFile = this.files[0];
        observable.setProperty('dssFile', dssFile, 'formProps');
    });
    // - Modal
    const modal = new Modal();
    modal.addStyleClasses(['outerModal', 'fitContent'], 'divElement');
    const modalInsert = document.getElementById('modalInsert');
    submitButton.addEventListener('click', function() {
        if (nameInput.checkValidity() && dssInput.checkValidity()) {
            modalInsert.removeEventListener('click', hideModalInsert);
            modal.showProgress(true, 'Importing .dss file...', ['caution']);
            controller.submitFeature(observable, modal, submitButton);
        } else {
            nameInput.reportValidity();
            dssInput.reportValidity();
        }
    });
    modal.setTitle('OpenDSS Conversion');
    modal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'titleElement');
    modal.insertTBodyRow([nameLabel, nameInput]);
    modal.insertTBodyRow([dssLabel, dssInput]);
    modal.insertElement(submitDiv);
    modal.addStyleClasses(['verticalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'containerElement');
    return modal;
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {HTMLDivElement}
 */
function getOpendssDiv(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const feature = new Feature({
        geometry: { 'coordinates': [null, null], 'type': 'Point' },
        properties: {
            treeKey: 'modal:opendss',
            urlProps: {
                fileExistsUrl: {
                    method: 'GET',
                    url: `/uniqObjName/Feeder/${gThisOwner}/Default Name/${gThisModelName}`
                },
                pollUrl: {
                    method: 'GET',
                    url: `/checkConversion/${gThisModelName}/${gThisOwner}`
                },
                submitUrl: {
                    method: 'POST',
                    url: `/opendssImport/${gThisOwner}`
                }
            },
            formProps: {
                modelName: gThisModelName,
                feederNameOpendss: 'Default Name',
                feederNum: gThisFeederNum,
                dssFile: ''
            }
        },
        type: 'Feature'
    });
    const modal = _getOpendssModal(feature, controller);
    const div = _getMenuDiv('OpenDSS conversion...');
    const modalInsert = document.getElementById('modalInsert');
    div.addEventListener('click', function() {
        modalInsert.replaceChildren(modal.divElement);
        modalInsert.classList.add('visible');
    });
    return div;
}

/**
 * @param {Feature} observable
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {Modal}
 */
function _getAmiModal(observable, controller) {
    if (!(observable instanceof Feature)) {
        throw TypeError('"observable" argument must be instanceof Feature.');
    }
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    // - csv file input
    const amiInput = document.createElement('input');
    amiInput.type = 'file';
    amiInput.accept = '.csv';
    amiInput.required = true;
    amiInput.id = 'amiInput'; 
    const amiLabel = document.createElement('label');
    amiLabel.htmlFor = 'amiInput';
    amiLabel.innerHTML = 'File containing AMI load data (.csv)';
    // - Format help anchor
    const anchor = document.createElement('a');
    anchor.href = 'https://github.com/dpinney/omf/wiki/Tools-~-gridEdit#ami-load-modeling';
    anchor.textContent = 'Format Help';
    anchor.target = '_blank';
    // - Note div
    const noteDiv = _getHorizontalFlexDiv();
    noteDiv.classList.add('centerCrossAxisFlex');
    noteDiv.style.alignSelf = 'start';
    const span = document.createElement('span');
    span.textContent = 'Note: model "Simulation Start Data" should lie within the AMI profile\'s dates';
    noteDiv.appendChild(span);
    // - Submit div
    const submitButton = _getSubmitButton('Import');
    const submitDiv = _getSubmitDiv(submitButton);
    // - Event listeners
    amiInput.addEventListener('change', function() {
        const amiFile = this.files[0];
        observable.setProperty('amiFile', amiFile, 'formProps');
    });
    // - Modal
    const modal = new Modal();
    modal.addStyleClasses(['outerModal', 'fitContent'], 'divElement');
    const modalInsert = document.getElementById('modalInsert');
    submitButton.addEventListener('click', function() {
        if (amiInput.checkValidity()) {
            modalInsert.removeEventListener('click', hideModalInsert);
            modal.showProgress(true, 'Importing file...', ['caution']);
            controller.submitFeature(observable, modal, submitButton);
        } else {
            amiInput.reportValidity();
        }
    });
    modal.setTitle('AMI Profiles');
    modal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'titleElement');
    modal.insertTBodyRow([anchor]);
    modal.insertTBodyRow([amiLabel, amiInput]);
    modal.insertElement(noteDiv);
    modal.insertElement(submitDiv);
    modal.addStyleClasses(['verticalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'containerElement');
    return modal;
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {HTMLDivElement}
 */
function getAmiDiv(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const feature = new Feature({
        geometry: { 'coordinates': [null, null], 'type': 'Point' },
        properties: {
            treeKey: 'modal:ami',
            urlProps: {
                fileExistsUrl: {
                    method: 'GET',
                    url: `/uniqObjName/Feeder/${gThisOwner}/${gThisFeederName}/${gThisModelName}`
                },
                pollUrl: {
                    method: 'GET',
                    url: `/checkConversion/${gThisModelName}/${gThisOwner}`
                },
                submitUrl: {
                    method: 'POST',
                    url: `/loadModelingAmi/${gThisOwner}/${gThisFeederName}`
                }
            },
            formProps: {
                modelName: gThisModelName,
                amiFile: ''
            }
        },
        type: 'Feature'
    });
    const modal = _getAmiModal(feature, controller);
    const div = _getMenuDiv('Add AMI profiles...');
    const modalInsert = document.getElementById('modalInsert');
    div.addEventListener('click', function() {
        modalInsert.replaceChildren(modal.divElement);
        modalInsert.classList.add('visible');
    });
    return div;
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {Modal}
 */
function _getAttachmentsModal(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const mainModal = new Modal();
    mainModal.addStyleClasses(['outerModal'], 'divElement');
    mainModal.setTitle('Attachments');
    mainModal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'titleElement');
    const omdFeature = controller.observableGraph.getObservable('omd');
    const attachments = omdFeature.getProperty('attachments', 'meta');
    const textAreaModals = [];
    for (const [key, val] of Object.entries(attachments)) {
        if (typeof val === 'string') {
            const modal = _getTextAreaModal(key, key, val, attachments, omdFeature);
            textAreaModals.push({
                object: attachments,
                propertyKey: key,
                textArea: modal.divElement.querySelector('textarea'),
                feature: omdFeature,
                text: val
            });
            mainModal.insertElement(modal.divElement);
        } else if (typeof val === 'object') {
            const nestedObjects = _getNestedObjects(val);
            nestedObjects.forEach(obj => {
                for (const [innerKey, text] of Object.entries(obj.object)) {
                    if (typeof text === 'string') {
                        const innerModal = _getTextAreaModal(`${obj.namespace} ${innerKey}`, innerKey, text, obj.object, omdFeature);
                        textAreaModals.push({
                            object: obj.object,
                            propertyKey: innerKey,
                            textArea: innerModal.divElement.querySelector('textarea'),
                            feature: omdFeature,
                            text: text
                        });
                        mainModal.insertElement(innerModal.divElement);
                    }
                }
            });
        }
    }
    const saveButtonModal = new Modal();
    saveButtonModal.addStyleClasses(['fitContent'], 'divElement');
    saveButtonModal.divElement.style.padding = '16px 0px 0px 0px';
    const saveButton = _getSubmitButton('Save');
    saveButton.addEventListener('click', function() {
        textAreaModals.forEach(obj => {
            obj.object[obj.propertyKey] = obj.textArea.value;
            obj.feature.updatePropertyOfObservers('', '', '');
            obj.text = obj.textArea.value;
        });
    });
    const saveDiv = _getSubmitDiv(saveButton);
    saveButtonModal.insertElement(saveDiv);
    const resetButton = _getSubmitButton('Reset to last save');
    resetButton.classList.add('delete');
    resetButton.addEventListener('click', function() {
        textAreaModals.forEach(obj => {
            obj.textArea.value = obj.text;
        });
    });
    const resetDiv = _getSubmitDiv(resetButton);
    saveButtonModal.insertElement(resetDiv);
    saveButtonModal.addStyleClasses(['verticalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'containerElement');
    const nestedModals = mainModal.divElement.querySelectorAll('div.js-div--modal');
    if (nestedModals.length > 0) {
        const lastNestedModal = nestedModals.item(nestedModals.length - 1)
        lastNestedModal.querySelector('div.div--modalElementContainer').append(saveButtonModal.divElement);
    }
    return mainModal;
}

/**
 * @param {Object} obj - the object that contains nested objects that I want to be able to access and modify
 * @param {string} [namespace=''] - a string that indicates where in the top-level object the nested object exists
 * @returns {Array} an array of actual objects in the top-level object
 */
function _getNestedObjects(obj, namespace='') {
    const objects = [];
    for (const [k, v] of Object.entries(obj)) {
        // - I don't care if nulls and arrays are returned. Maybe I'll care about them eventually
        if (typeof v === 'object' && v !== null) {
            let objNamespace;
            if (namespace === '') {
                objNamespace = k;
            } else {
                objNamespace = `${namespace}|${k}`;
            }
            objects.push({
                namespace: objNamespace,
                object: v
            });
            objects.push(..._getNestedObjects(v, k));
        }
    }
    return objects;
}

/**
 * - David wanted "save" and "cancel" buttons, so not all of these parameters are used anymore. Instead, these parameters are used to understand what
 *   the "save" and "cancel" buttons do
 * @param {string} title
 * @param {string} propertyKey
 * @param {string} text
 * @param {Object} object - the object that contains the key and value that created the text area
 * @param {Feature} feature - the Feature that will have updatePropertyOfObservers() called on it (i.e. the "omd" feature)
 * @returns {Modal}
 */
function _getTextAreaModal(title, propertyKey, text, object, feature) {
    if (typeof title !== 'string') {
        throw TypeError('"title" argument must be typeof string.');
    }
    if (typeof propertyKey !== 'string') {
        throw TypeError('"propertyKey" argument must be typeof string.');
    }
    if (typeof text !== 'string') {
        throw TypeError('"text" argument must be typeof string.');
    }
    if (typeof object !== 'object') {
        throw TypeError('"object" argument must be typeof object.');
    }
    const modal = new Modal();
    const attachmentTitleDiv = _getHorizontalFlexDiv();
    attachmentTitleDiv.classList.add('centerCrossAxisFlex');
    const span = document.createElement('span');
    span.textContent = title;
    attachmentTitleDiv.appendChild(span);
    modal.insertElement(attachmentTitleDiv);
    modal.addStyleClasses(['horizontalFlex', 'centerCrossAxisFlex'], 'titleElement');
    const textArea = document.createElement('textarea');
    textArea.value = text;
    //textArea.addEventListener('change', function() {
    //    object[propertyKey] = textArea.value;
    //    feature.updatePropertyOfObservers('', '', '');
    //});
    modal.insertElement(textArea);
    return modal;
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {HTMLDivElement}
 */
function getAttachmentsDiv(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const div = _getMenuDiv('Attachments...');
    const modalInsert = document.getElementById('modalInsert');
    div.addEventListener('click', function() {
        const modal = _getAttachmentsModal(controller);
        modalInsert.replaceChildren(modal.divElement);
        modalInsert.classList.add('visible');
    });
    return div;
}

/**
 * @param {Feature} observable
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {Modal}
 */
function _getClimateModal(observable, controller) {
    if (!(observable instanceof Feature)) {
        throw TypeError('"observable" argument must be instanceof Feature.');
    }
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    // - Climate import select
    const climateImportSelect = document.createElement('select');
    climateImportSelect.name = 'climateImportOption';
    let option = document.createElement('option');
    option.text = 'USCRN import';
    option.value = 'USCRNImport';
    climateImportSelect.add(option);
    option = document.createElement('option');
    option.text = 'tmy import';
    option.value = 'tmyImport';
    climateImportSelect.add(option);
    // - USCRN year select
    const uscrnYearSelect = document.createElement('select');
    uscrnYearSelect.id = 'uscrnYearSelect';
    uscrnYearSelect.name = 'uscrnYear';
    [2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019].forEach(year => {
        const option = document.createElement('option');
        option.text = year;
        option.value = year;
        uscrnYearSelect.add(option);
    });
    // - USCRN station select
    const uscrnStationSelect = document.createElement('select');
    uscrnStationSelect.name = 'uscrnStation';
    ["AK_Bethel_87_WNW", "AK_Cordova_14_ESE", "AK_Deadhorse_3_S", "AK_Denali_27_N", "AK_Fairbanks_11_NE", "AK_Glennallen_64_N", "AK_Gustavus_2_NE",
	"AK_Ivotuk_1_NNE", "AK_Kenai_29_ENE", "AK_King_Salmon_42_SE", "AK_Metlakatla_6_S", "AK_Port_Alsworth_1_SW", "AK_Red_Dog_Mine_3_SSW", "AK_Ruby_44_ESE",
    "AK_Sand_Point_1_ENE", "AK_Selawik_28_E", "AK_Sitka_1_NE", "AK_St._Paul_4_NE", "AK_Tok_70_SE", "AK_Toolik_Lake_5_ENE", "AK_Utqiagvik_formerly_Barrow_4_ENE",
    "AK_Yakutat_3_SSE", "AL_Brewton_3_NNE", "AL_Clanton_2_NE", "AL_Courtland_2_WSW", "AL_Cullman_3_ENE", "AL_Fairhope_3_NE", "AL_Gadsden_19_N", "AL_Gainesville_2_NE",
	"AL_Greensboro_2_WNW", "AL_Highland_Home_2_S", "AL_Muscle_Shoals_2_N", "AL_Northport_2_S", "AL_Russellville_4_SSE", "AL_Scottsboro_2_NE", "AL_Selma_6_SSE",
	"AL_Selma_13_WNW", "AL_Talladega_10_NNE", "AL_Thomasville_2_S", "AL_Troy_2_W", "AL_Valley_Head_1_SSW", "AR_Batesville_8_WNW", "AZ_Elgin_5_S", "AZ_Tucson_11_W",
	"AZ_Williams_35_NNW", "AZ_Yuma_27_ENE", "CA_Bodega_6_WSW", "CA_Fallbrook_5_NE", "CA_Merced_23_WSW", "CA_Redding_12_WNW", "CA_Santa_Barbara_11_W", "CA_Stovepipe_Wells_1_SW",
	"CA_Yosemite_Village_12_W", "CO_Boulder_14_W", "CO_Cortez_8_SE", "CO_Dinosaur_2_E", "CO_La_Junta_17_WSW", "CO_Montrose_11_ENE", "CO_Nunn_7_NNE", "FL_Everglades_City_5_NE",
	"FL_Sebring_23_SSE", "FL_Titusville_7_E", "GA_Brunswick_23_S", "GA_Newton_8_W", "GA_Newton_11_SW", "GA_Watkinsville_5_SSE", "HI_Hilo_5_S", "HI_Mauna_Loa_5_NNE",
	"IA_Des_Moines_17_E", "ID_Arco_17_SW", "ID_Murphy_10_W", "IL_Champaign_9_SW", "IL_Shabbona_5_NNE", "IN_Bedford_5_WNW", "KS_Manhattan_6_SSW", "KS_Oakley_19_SSW",
	"KY_Bowling_Green_21_NNE", "KY_Versailles_3_NNW", "LA_Lafayette_13_SE", "LA_Monroe_26_N", "ME_Limestone_4_NNW", "ME_Old_Town_2_W", "MI_Chatham_1_SE", "MI_Gaylord_9_SSW",
	"MN_Goodridge_12_NNW", "MN_Sandstone_6_W", "MO_Chillicothe_22_ENE", "MO_Joplin_24_N", "MO_Salem_10_W", "MS_Holly_Springs_4_N", "MS_Newton_5_ENE", "MT_Dillon_18_WSW",
	"MT_Lewistown_42_WSW", "MT_St._Mary_1_SSW", "MT_Wolf_Point_29_ENE", "MT_Wolf_Point_34_NE", "NC_Asheville_8_SSW", "NC_Asheville_13_S", "NC_Durham_11_W", "ND_Jamestown_38_WSW",
	"ND_Medora_7_E", "ND_Northgate_5_ESE", "NE_Harrison_20_SSE", "NE_Lincoln_8_ENE", "NE_Lincoln_11_SW", "NE_Whitman_5_ENE", "NH_Durham_2_N", "NH_Durham_2_SSW", "NM_Las_Cruces_20_N",
	"NM_Los_Alamos_13_W", "NM_Socorro_20_N", "NV_Baker_5_W", "NV_Denio_52_WSW", "NV_Mercury_3_SSW", "NY_Ithaca_13_E", "NY_Millbrook_3_W", "OH_Wooster_3_SSE", "OK_Goodwell_2_E",
	"OK_Goodwell_2_SE", "OK_Stillwater_2_W", "OK_Stillwater_5_WNW", "ON_Egbert_1_W", "OR_Coos_Bay_8_SW", "OR_Corvallis_10_SSW", "OR_John_Day_35_WNW", "OR_Riley_10_WSW",
	"PA_Avondale_2_N", "RI_Kingston_1_NW", "RI_Kingston_1_W", "SC_Blackville_3_W", "SC_McClellanville_7_NE", "SD_Aberdeen_35_WNW", "SD_Buffalo_13_ESE", "SD_Pierre_24_S",
	"SD_Sioux_Falls_14_NNE", "TN_Crossville_7_NW", "TX_Austin_33_NW", "TX_Bronte_11_NNE", "TX_Edinburg_17_NNE", "TX_Monahans_6_ENE", "TX_Muleshoe_19_S", "TX_Palestine_6_WNW",
	"TX_Panther_Junction_2_N", "TX_Port_Aransas_32_NNE", "UT_Brigham_City_28_WNW", "UT_Torrey_7_E", "VA_Cape_Charles_5_ENE", "VA_Charlottesville_2_SSE", "WA_Darrington_21_NNE",
    "WA_Quinault_4_NE", "WA_Spokane_17_SSW", "WI_Necedah_5_WNW", "WV_Elkins_21_ENE", "WY_Lander_11_SSE", "WY_Moose_1_NNE", "WY_Sundance_8_NNW"].forEach(station => {
        const option = document.createElement('option');
        option.text = station;
        option.value = station;
        uscrnStationSelect.add(option); 
    });
    // - tmy zip code input
    const tmyInput = document.createElement('input');
    tmyInput.id = 'tmyInput';
    tmyInput.name = 'tmyInput';
    const tmyInputLabel = document.createElement('label');
    tmyInputLabel.htmlFor = 'tmyInput';
    tmyInputLabel.innerText = 'ZIP code';
    // - Submit div
    const submitButton = _getSubmitButton();
    const submitDiv = _getSubmitDiv(submitButton);
    // - Event listeners
    uscrnYearSelect.addEventListener('change', function() {
        observable.setProperty('uscrnYear', this.value, 'formProps');
    });
    uscrnStationSelect.addEventListener('change', function() {
        observable.setProperty('uscrnStation', this.value, 'formProps');
    });
    tmyInput.addEventListener('change', function() {
        const value = this.value.trim();
        observable.setProperty('zipCode', value, 'formProps');
    });
    // - Modal
    const mainModal = new Modal();
    const modalInsert = document.getElementById('modalInsert');
    submitButton.addEventListener('click', function() {
        modalInsert.removeEventListener('click', hideModalInsert);
        mainModal.showProgress(true, 'Adding climate data...', ['caution']);
        controller.submitFeature(observable, mainModal, submitButton);
    });
    mainModal.addStyleClasses(['outerModal', 'fitContent'], 'divElement');
    mainModal.setTitle('Climate Change');
    mainModal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'titleElement');
    mainModal.insertTBodyRow([climateImportSelect]);
    const uscrnModal = new Modal();
    uscrnModal.addStyleClasses(['indent1'], 'divElement');
    uscrnModal.insertTBodyRow(['Year', uscrnYearSelect]);
    uscrnModal.insertTBodyRow(['Station', uscrnStationSelect]);
    mainModal.insertElement(uscrnModal.divElement);
    const tmyModal = new Modal();
    tmyModal.addStyleClasses(['indent1', 'collapsed'], 'divElement');
    tmyModal.insertTBodyRow([tmyInputLabel, tmyInput]);
    mainModal.insertElement(tmyModal.divElement);
    climateImportSelect.addEventListener('change', function() {
        observable.setProperty('climateImportOption', this.value, 'formProps');
        if (this.value === 'USCRNImport') {
            uscrnModal.removeStyleClasses(['collapsed'], 'divElement');
            tmyModal.addStyleClasses(['collapsed'], 'divElement');
        } else {
            uscrnModal.addStyleClasses(['collapsed'], 'divElement');
            tmyModal.removeStyleClasses(['collapsed'], 'divElement');
        }
    });
    const submitDivModal = new Modal();
    submitDivModal.insertElement(submitDiv);
    submitDivModal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'containerElement');
    mainModal.insertElement(submitDivModal.divElement);
    return mainModal;
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {HTMLDivElement}
 */
function getClimateDiv(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const feature = new Feature({
        geometry: { 'coordinates': [null, null], 'type': 'Point' },
        properties: {
            treeKey: 'modal:climate',
            urlProps: {
                fileExistsUrl: {
                    method: 'GET',
                    url: `/uniqObjName/Feeder/${gThisOwner}/${gThisFeederName}/${gThisModelName}`
                },
                pollUrl: {
                    method: 'GET',
                    url: `/checkConversion/${gThisModelName}/${gThisOwner}`
                },
                submitUrl: {
                    method: 'POST',
                    url: `/climateChange/${gThisOwner}/${gThisFeederName}`
                }
            },
            formProps: {
                modelName: gThisModelName,
                climateImportOption: 'USCRNImport',
                uscrnStation: 'AK_Bethel_87_WNW',
                uscrnYear: '2006',
                zipCode: ''
            }
        },
        type: 'Feature'
    });
    const modal =_getClimateModal(feature, controller);
    const div = _getMenuDiv('Climate...');
    const modalInsert = document.getElementById('modalInsert');
    div.addEventListener('click', function() {
        modalInsert.replaceChildren(modal.divElement);
        modalInsert.classList.add('visible');
    });
    return div;
}

/**
 * @param {Feature} observable
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {Modal}
 */
function _getScadaModal(observable, controller) {
    if (!(observable instanceof Feature)) {
        throw TypeError('"observable" argument must be instanceof Feature.');
    }
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    // - csv file input
    const scadaInput = document.createElement('input');
    scadaInput.type = 'file';
    scadaInput.accept = '.csv';
    scadaInput.required = true;
    scadaInput.id = 'scadaInput'; 
    const scadaLabel = document.createElement('label');
    scadaLabel.htmlFor = 'scadaInput';
    scadaLabel.innerHTML = 'File containing SCADA load data (.csv)';
    // - Format help anchor
    const anchor = document.createElement('a');
    anchor.href = 'https://github.com/dpinney/omf/wiki/Tools-~-gridEdit#scada-loadshapes';
    anchor.textContent = 'Format Help';
    anchor.target = '_blank';
    // - Note div
    const noteDiv = _getHorizontalFlexDiv();
    noteDiv.classList.add('centerCrossAxisFlex');
    noteDiv.style.alignSelf = 'start';
    const span = document.createElement('span');
    span.textContent = 'Note: model "Simulation Start Data" should lie within the SCADA load\'s dates.';
    noteDiv.appendChild(span);
    // - Submit div
    const submitButton = _getSubmitButton('Import');
    const submitDiv = _getSubmitDiv(submitButton);
    // - Event listeners
    scadaInput.addEventListener('change', function() {
        const scadaFile = this.files[0];
        observable.setProperty('scadaFile', scadaFile, 'formProps');
    }); 
    // - Modal
    const modal = new Modal();
    modal.addStyleClasses(['outerModal', 'fitContent'], 'divElement');
    const modalInsert = document.getElementById('modalInsert');
    submitButton.addEventListener('click', function() {
        if (scadaInput.checkValidity()) {
            modalInsert.removeEventListener('click', hideModalInsert);
            modal.showProgress(true, 'Importing file...', ['caution']);
            controller.submitFeature(observable, modal, submitButton);
        } else {
            scadaInput.reportValidity();
        }
    });
    modal.setTitle('SCADA Loadshapes');
    modal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'titleElement');
    modal.insertTBodyRow([anchor]);
    modal.insertTBodyRow([scadaLabel, scadaInput]);
    modal.insertElement(noteDiv);
    modal.insertElement(submitDiv);
    modal.addStyleClasses(['verticalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'containerElement');
    return modal;
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {HTMLDivElement}
 */
function getScadaDiv(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const feature = new Feature({
        geometry: { 'coordinates': [null, null], 'type': 'Point' },
        properties: {
            treeKey: 'modal:scada',
            urlProps: {
                fileExistsUrl: {
                    method: 'GET',
                    url: `/uniqObjName/Feeder/${gThisOwner}/${gThisFeederName}/${gThisModelName}`
                },
                pollUrl: {
                    method: 'GET',
                    url: `/checkConversion/${gThisModelName}/${gThisOwner}`
                },
                submitUrl: {
                    method: 'POST',
                    url: `/scadaLoadshape/${gThisOwner}/${gThisFeederName}`
                }
            },
            formProps: {
                modelName: gThisModelName,
                scadaFile: ''
            }
        },
        type: 'Feature'
    });
    const modal = _getScadaModal(feature, controller);
    const div = _getMenuDiv('SCADA loadshapes...');
    const modalInsert = document.getElementById('modalInsert');
    div.addEventListener('click', function() {
        modalInsert.replaceChildren(modal.divElement);
        modalInsert.classList.add('visible');
    });
    return div; 
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {HTMLDivElement}
 */
function getColorDiv(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const colorModal = new ColorModal([controller.observableGraph.getObservable('omd')], controller);
    const divElement = colorModal.getDOMElement();
    const div = _getMenuDiv('Color circuit...');
    const modalInsert = document.getElementById('modalInsert');
    div.addEventListener('click', function() {
        modalInsert.replaceChildren(divElement);
        modalInsert.classList.add('visible');
    });
    return div;
}

/**
 * @param {FeatureController} controller - a ControllerInterface instance
 * @returns {HTMLDivElement}
 */
function getGeojsonDiv(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const geojsonModal = new GeojsonModal([controller.observableGraph.getObservable('omd')], controller);
    const divElement = geojsonModal.getDOMElement();
    const div = _getMenuDiv('Add GeoJSON data...');
    const modalInsert = document.getElementById('modalInsert');
    div.addEventListener('click', function() {
        modalInsert.replaceChildren(divElement);
        modalInsert.classList.add('visible');
    });
    return div;
}

/**
 * @param {Nav} nav - a Nav instance
 * @param {TopTab} topTab - a TopTab instance
 * @returns {undefined}
 */
function getSearchDiv(nav, topTab) {
    if (!(nav instanceof Nav)) {
        throw TypeError('"nav" argument must be instanceof Nav.');
    }
    if (!(topTab instanceof TopTab)) {
        throw TypeError('"topTab" argument must be instanceof TopTab.');
    }
    const div = _getMenuDiv('Search objects...');
    div.addEventListener('click', function() {
        if (nav.sideNavNavElement.classList.contains('open')) {
            if (topTab.getTab('Search Objects').tab.classList.contains('selected')) {
                nav.sideNavNavElement.classList.remove('open');
                nav.sideNavDivElement.classList.remove('open');
                nav.sideNavArticleElement.classList.remove('compressed');
            }
            if (topTab.getTab('Add New Objects').tab.classList.contains('selected')) {
                topTab.selectTab(topTab.getTab('Search Objects').tab);
            }
        } else {
            if (topTab.getTab('Add New Objects').tab.classList.contains('selected')) {
                topTab.selectTab(topTab.getTab('Search Objects').tab);
            }
            nav.sideNavNavElement.classList.add('open');
            nav.sideNavDivElement.classList.add('open');
            nav.sideNavArticleElement.classList.add('compressed');
        }
        document.getElementById('editMenu').getElementsByTagName('button')[0].click();
    });
    return div;
}

/**
 * @param {Nav} nav - a Nav instance
 * @param {TopTab} topTab - a TopTab instance
 * @returns {undefined}
 */
function getAddComponentsDiv(nav, topTab) {
    if (!(nav instanceof Nav)) {
        throw TypeError('"nav" argument must be instanceof Nav.');
    }
    if (!(topTab instanceof TopTab)) {
        throw TypeError('"topTab" argument must be instanceof TopTab.');
    }
    const div = _getMenuDiv('Add new objects...');
    div.addEventListener('click', function() {
        if (nav.sideNavNavElement.classList.contains('open')) {
            if (topTab.getTab('Add New Objects').tab.classList.contains('selected')) {
                nav.sideNavNavElement.classList.remove('open');
                nav.sideNavDivElement.classList.remove('open');
                nav.sideNavArticleElement.classList.remove('compressed');
            }
            if (topTab.getTab('Search Objects').tab.classList.contains('selected')) {
                topTab.selectTab(topTab.getTab('Add New Objects').tab);
            }
        } else {
            if (topTab.getTab('Search Objects').tab.classList.contains('selected')) {
                topTab.selectTab(topTab.getTab('Add New Objects').tab);
            }
            nav.sideNavNavElement.classList.add('open');
            nav.sideNavDivElement.classList.add('open');
            nav.sideNavArticleElement.classList.add('compressed');
        }
        document.getElementById('editMenu').getElementsByTagName('button')[0].click();
    });
    return div;
}

/*********************************/
/* Private convenience functions */
/*********************************/

function _getHorizontalFlexDiv() {
    const div = document.createElement('div');
    div.classList.add('horizontalFlex');
    return div;
}

function _getMenuDiv(text) {
    if (typeof text !== 'string') {
        throw TypeError('"text" argument must be a string.');
    }
    const div = document.createElement('div');
    div.classList.add('hoverable', 'horizontalFlex', 'centerCrossAxisFlex');
    div.textContent = text;
    return div;
}

/**
 * - Firefox doesn't display the reportValidity() message correctly
 * - I don't know why I can't get actual regular expression literals to work. Only the regex string works for me
 * @param {Feature} observable
 * @param {Function} func - a function that takes the new name as an argument
 * @returns {HTMLInputElement}
 */
function _getNameInput(observable, func) {
    const input = document.createElement('input');
    input.pattern = '(?:\\w+-?\\s?)+';
    input.placeholder = 'New name';
    input.required = true;
    input.title = 'The new name must have one or more alphanumeric characters. Single spaces, hyphens, and underscores are allowed.';
    input.addEventListener('change', function() {
        this.setCustomValidity('');
        if (this.validity.valueMissing || this.validity.patternMismatch) {
            input.setCustomValidity('The new name must have one or more alphanumeric characters. Single spaces, hyphens, and underscores are allowed.');
            input.reportValidity();
        } else if (this.validity.valid) {
            func(this.value.trim());
        }
    });
    return input
}

function _getSubmitButton(text='Submit') {
    const submitButton = document.createElement('button');
    let span = document.createElement('span');
    span.textContent = text;
    submitButton.appendChild(span);
    submitButton.classList.add('horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex', 'fullWidth');
    return submitButton;
}

function _getSubmitDiv(button) {
    if (!(button instanceof HTMLButtonElement)) {
        throw TypeError('"button" argument must be instanceof HTMLButtonElement.');
    }
    const submitDiv = document.createElement('div');
    submitDiv.classList.add('horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex', 'halfWidth');
    submitDiv.appendChild(button);
    return submitDiv;
}
</script>
<script>
"use strict";

// - If we need more coloring functionality in the future, I should move all coloring-related code into the colormodal and create an instance of the
//   color modal here

/**
 * - Inherited methods: getPosition(), setPosition(), getContainer(), addTo(), remove()
 * - Extension methods: onAdd(), onRemove()
 */
const MultiselectControlClass = L.Control.extend({
    // - Set default values for L.Control options
    options: {
        position: 'topleft' // - Position the control in the top left corner by default
    },
    /**
     * @param {FeatureController} controller - a ControllerInterface instance 
     * @param {Object} options - a plain JavaScript object containing L.Control option values that should override the default values
     * @returns {undefined}
     */
    initialize: function(controller, options=null) {
        if (!(controller instanceof FeatureController)) {
            throw TypeError('The "controller" argument must be instanceof FeatureController.');
        }
        this._controller = controller;
        // - Create div
        this._div = L.DomUtil.create('div', 'leaflet-bar');
        this._div.classList.add('leaflet-customControlDiv');
        L.DomEvent.disableClickPropagation(this._div);
        this._div.appendChild(this._getSvg());
        // - Add a tooltip
        this._div.title = '- The multiselect tool allows you to draw a box on the map to select elements\n- Click this button or press shift to enable\n- While enabled, hold and drag the mouse to select elements\n- Click this button or press shift or escape to disable';
        // - Attach listeners
        this._on = false;
        this._div.addEventListener('click', () => {
            if (!this._on) {
                this._on = true;
                this._activate(LeafletLayer.map);
            } else {
                this._on = false;
                this._deactivate(LeafletLayer.map);
            }
        });
        this._mousedown = null;
        this._mousemove = null;
        this._mouseup = null;
        this._selectedObservables = [];
        this._modal = null;
        if (options !== null) {
            L.setOptions(this, options);
        }
    },
    onAdd: function(map) {
        this._onAdd(map);
        return this._div;
    },
    onRemove: function(map) {
        // - Don't do anything. The MultiselectControl will never be removed from the map
    },
    _onAdd(map) {
        map.on('keyup', (e) => {
            if (e.originalEvent.key === 'Shift' ) {
                if (!this._on) {
                    this._on = true;
                    this._activate(map);
                } else {
                    this._on = false;
                    this._deactivate(map);
                }
            }
        });
        map.on('keydown', (e) => {
            if (e.originalEvent.key === 'Escape') {
                this._on = false;
                this._deactivate(map);
            }
        });
    },
    _activate(map) {
        this._div.style.border = '2px solid #7FFF00';
        map.dragging.disable();
        document.getElementById('map').style.cursor = 'crosshair';
        const bounds = {};
        let rectangle = null;
        let mouseIsDown = false;
        this._mousedown = (e) => {
            // - Disable map dragging again just in case a marker was dragged which would have reenabled map dragging
            map.dragging.disable();
            this._removeHighlights();
            if (rectangle !== null) {
                rectangle.remove();
            }
            bounds.start = e.latlng;
            mouseIsDown = true;
        };
        map.on('mousedown', this._mousedown);
        this._mousemove = (e) => {
            if (mouseIsDown) {
                if (rectangle !== null) {
                    rectangle.remove();
                }
                bounds.end = e.latlng;
                rectangle = L.rectangle([bounds.start, bounds.end], {color: "#7FFF00", weight: 1});
                rectangle.addTo(map);
            }
        };
        map.on('mousemove', this._mousemove);
        this._mouseup = (e) => {
            if (rectangle !== null) {
                rectangle.remove();
            }
            bounds.end = e.latlng;
            if ((bounds.start.lat !== bounds.end.lat) || (bounds.start.lng !== bounds.end.lng)) {
                // - Highlight new paths
                const observables = this._controller.observableGraph.getObservables((ob) => {
                    // - This check is slow, but I can't think of a better way to do it right now
                    if (ob.hasCoordinates()) {
                        const layer = Object.values(ob.getObservers().filter(o => o instanceof LeafletLayer)[0].getLayer()._layers)[0];
                        if (map.hasLayer(layer)) {
                            if (ob.isNode()) {
                                return this._pointIsBounded(bounds, ob.getCoordinates());
                            } else if (ob.isLine()) {
                                const c = ob.getCoordinates();
                                return this._pointIsBounded(bounds, ob.getCoordinates()[0]) ||
                                    this._pointIsBounded(bounds, ob.getCoordinates()[1]) ||
                                    this._pointIsBounded(bounds, [(c[0][0] + c[1][0]) / 2, (c[0][1] + c[1][1]) / 2])
                            } else {
                                throw Error('Multiselect control only works with nodes or lines with coordinates.');
                            }
                        }
                        return false;
                    }
                });
                if (observables.length > 0) {
                    this._selectedObservables = observables;
                    for (const ob of this._selectedObservables) {
                        const path = Object.values(ob.getObservers().filter(o => o instanceof LeafletLayer)[0].getLayer()._layers)[0];
                        if (ob.isNode()) {
                            path.setStyle({
                                color: '#7FFF00'
                            });
                        } else if (ob.isLine()) {
                            if (!path.options.hasOwnProperty('originalColor')) {
                                path.options.originalColor = path.options.color;
                            }
                            path.setStyle({
                                color: '#7FFF00'
                            });
                        }
                    }
                    this._modal = new FeatureEditModal(observables, this._controller);
                    const div = this._modal.getDOMElement();
                    div.classList.add('outerModal');
                    const draggable = new L.Draggable(div);
                    draggable.enable()
                    document.getElementById('multiselectInsert').replaceChildren(div);
                }
            }
            mouseIsDown = false;
        };
        map.on('mouseup', this._mouseup);
    },
    _deactivate(map) {
        this._div.style.removeProperty('border');
        document.getElementById('map').style.removeProperty('cursor');
        this._removeHighlights();
        map.dragging.enable();
        map.off('mousedown', this._mousedown);
        map.off('mousemove', this._mousemove);
        map.off('mouseup', this._mouseup);
    },
    /**
     * @param {Object} bounds - a bounds object
     * @param {Array} coordinates - coordinates with [<lon>, <lat>] format
     */
    _pointIsBounded(bounds, coordinates) {
        let latIsBounded = false;
        let lngIsBounded = false;
        if (bounds.start.lat < bounds.end.lat && coordinates[1] >= bounds.start.lat && coordinates[1] <= bounds.end.lat) {
            latIsBounded = true;
        } else if (bounds.start.lat > bounds.end.lat && coordinates[1] <= bounds.start.lat && coordinates[1] >= bounds.end.lat) {
            latIsBounded = true;
        }
        if (bounds.start.lng < bounds.end.lng && coordinates[0] >= bounds.start.lng && coordinates[0] <= bounds.end.lng) {
            lngIsBounded = true;
        } else if (bounds.start.lng > bounds.end.lng && coordinates[0] <= bounds.start.lng && coordinates[0] >= bounds.end.lng) {
            lngIsBounded = true;
        }
        return latIsBounded && lngIsBounded;
    },
    /**
     * - Remove the highlight from the previously selected nodes and lines
     */
    _removeHighlights() {
        for (const ob of this._selectedObservables) {
            const path = Object.values(ob.getObservers().filter(o => o instanceof LeafletLayer)[0].getLayer()._layers)[0];
            if (ob.isNode()) {
                path.setStyle({
                    color: 'black'
                });
            } else if (ob.isLine()) {
                if (path.options.hasOwnProperty('colorModalColor')) {
                    path.setStyle({
                        color: path.options.colorModalColor
                    });
                } else {
                    path.setStyle({
                        color: path.options.originalColor
                    });
                }
            }
        }
        for (const ob of this._selectedObservables) {
            ob.removeObserver(this._modal)
        }
        this._selectedObservables = [];
        document.getElementById('multiselectInsert').replaceChildren();
    },
    /**
     * - x
     */
    _getSvg() {
        const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
        svg.setAttribute('width', '32px');
        svg.setAttribute('height', '32px');
        svg.setAttribute('viewBox', '0 0 24 24');
        svg.setAttribute('fill', 'none');
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M5 6C5.55228 6 6 5.55228 6 5C6 4.44772 5.55228 4 5 4C4.44772 4 4 4.44772 4 5C4 5.55228 4.44772 6 5 6ZM18 13C18 12.4477 17.5523 12 17 12C16.4477 12 16 12.4477 16 13V16H13C12.4477 16 12 16.4477 12 17C12 17.5523 12.4477 18 13 18H16V21C16 21.5523 16.4477 22 17 22C17.5523 22 18 21.5523 18 21V18H21C21.5523 18 22 17.5523 22 17C22 16.4477 21.5523 16 21 16H18V13ZM10 5C10 5.55228 9.55228 6 9 6C8.44771 6 8 5.55228 8 5C8 4.44772 8.44771 4 9 4C9.55228 4 10 4.44772 10 5ZM13 6C13.5523 6 14 5.55228 14 5C14 4.44772 13.5523 4 13 4C12.4477 4 12 4.44772 12 5C12 5.55228 12.4477 6 13 6ZM18 5C18 5.55228 17.5523 6 17 6C16.4477 6 16 5.55228 16 5C16 4.44772 16.4477 4 17 4C17.5523 4 18 4.44772 18 5ZM17 10C17.5523 10 18 9.55228 18 9C18 8.44771 17.5523 8 17 8C16.4477 8 16 8.44771 16 9C16 9.55228 16.4477 10 17 10ZM10 17C10 17.5523 9.55228 18 9 18C8.44771 18 8 17.5523 8 17C8 16.4477 8.44771 16 9 16C9.55228 16 10 16.4477 10 17ZM5 18C5.55228 18 6 17.5523 6 17C6 16.4477 5.55228 16 5 16C4.44772 16 4 16.4477 4 17C4 17.5523 4.44772 18 5 18ZM6 13C6 13.5523 5.55228 14 5 14C4.44772 14 4 13.5523 4 13C4 12.4477 4.44772 12 5 12C5.55228 12 6 12.4477 6 13ZM5 10C5.55228 10 6 9.55228 6 9C6 8.44771 5.55228 8 5 8C4.44772 8 4 8.44771 4 9C4 9.55228 4.44772 10 5 10Z');
        path.setAttribute('fill-rule', 'evenodd');
        path.setAttribute('clip-rule', 'evenodd');
        path.setAttribute('fill', '#000000');
        svg.appendChild(path);
        return svg;
    }
});
</script>
<script>
"use strict";

class FeatureDropdownDiv {
    #controller;        // - a ControllerInterface instance
    #dropdownDiv;       // - a DropdownDiv instance
    #featureEditModal;  // - a FeatureEditModal instance
    #observable;        // - an ObservableInterface instance
    #removed;           // - Whether this FeatureDropdownDiv instance has already been deleted

    constructor(observable, controller) {
        if (!(observable instanceof Feature)) {
            throw TypeError('"observable" argument must be instanceof Feature.');
        }
        if (!(controller instanceof FeatureController)) {
            throw TypeError('"controller" argument must be instanceof FeatureController.');
        }
        this.#controller = controller;
        this.#dropdownDiv = null;
        this.#featureEditModal = null;
        this.#observable = observable;
        this.#observable.registerObserver(this);
        this.#removed = false;
        this.renderContent();
    }

    // *******************************
    // ** ObserverInterface methods ** 
    // *******************************

    /**
     * - Remove this ObserverInterface instance (i.e. "this") from the ObservableInterface instance (i.e. "observable") that has been deleted, and
     *   perform other actions as needed
     * @param {Feature} observable - an ObservableInterface instance
     * @returns {undefined}
     */
    handleDeletedObservable(observable) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('"observable" argument must be instanceof Feature.');
        }
        this.remove();
    }

    /**
     *
     */
    handleNewObservable(observable) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        throw new UnsupportedOperationError();
    }

    /**
     * - Update this ObserverInterface instance (i.e. "this") based on the coordinates of the ObservableInterface instance (i.e. "observable") that
     *   have just changed and perform other actions as needed
     * @param {Feature} observable - an ObservableInterface instance
     * @param {Array} oldCoordinates - the old coordinates of the observable prior to the change in coordinates
     * @returns {undefined}
     */
    handleUpdatedCoordinates(observable, oldCoordinates) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('"observable" argument must be instanceof Feature.');
        }
        if (!(oldCoordinates instanceof Array)) {
            throw TypeError('"oldCoordinates" argument must be an array.');
        }
        // - Do nothing. Any inner FeatureEditModal should update itself
    } 

    /**
     * - Update this ObserverInstance (i.e. "this") based on the property of the ObservableInterface instance (i.e. "observable") that has just
     *   changed and perform other actions as needed
     * @param {Feature} observable - an ObservableInterface instance
     * @param {string} propertyKey - the property key of the property that has been created/changed/deleted in the observable
     * @param {(string|Object)} oldPropertyValue - the previous value of the property that has been created/changed/deleted in the observable
     * @param {string} namespace - the namespace of the property that has been created/changed/deleted in the observable
     * @returns {undefined}
     */
    handleUpdatedProperty(observable, propertyKey, oldPropertyValue, namespace='treeProps') {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('"observable" argument must be instanceof Feature.');
        }
        if (typeof propertyKey !== 'string') {
            throw TypeError('"propertyKey" argument must be a string.');
        }
        if (typeof namespace !== 'string') {
            throw TypeError('"namespace" argument must be a string.');
        }
        // - Do nothing. Any inner FeatureEditModal should update itself
    } 

    // ****************************
    // ** ModalInterface methods **
    // ****************************

    getDOMElement() {
        return this.#dropdownDiv.divElement;
    }

    /**
     * @returns {boolean}
     */
    isRemoved() {
        return this.#removed;
    }

    /**
     * @returns {undefined}
     */
    refreshContent() {

    }

    /**
     * @returns {undefined}
     */
    remove() {
        if (!this.#removed) {
            // - I have to check if this.#featureEditModal === null because often a FeatureDropdownDiv will be rendered, but the user will not have
            //   clicked on it to expand it, so it won't contain a FeatureEditModal
            if (this.#featureEditModal !== null) {
                this.#featureEditModal.remove();
                this.#featureEditModal = null;
            }
            this.#dropdownDiv.divElement.remove();
            this.#dropdownDiv = null;
            this.#observable.removeObserver(this);
            this.#observable = null;
            this.#controller = null;
            this.#removed = true;
        }
    }

    /**
     * @returns {undefined}
     */
    renderContent() {
        const dropdownDiv = new DropdownDiv();
        dropdownDiv.addStyleClasses(['sideNav'], 'divElement');
        const buttonTextSpan = document.createElement('span');
        buttonTextSpan.classList.add('indent2');
        if (this.#observable.hasProperty('object')) {
            if (this.#observable.hasProperty('name')) {
                let div = document.createElement('div');
                div.textContent = this.#observable.getProperty('object');
                buttonTextSpan.appendChild(div);
                div = document.createElement('div');
                div.textContent = this.#observable.getProperty('name');
                buttonTextSpan.appendChild(div);
            } else {
                buttonTextSpan.textContent = this.#observable.getProperty('object');
            }
        } else if (this.#observable.hasProperty('name')) {
            buttonTextSpan.textContent = this.#observable.getProperty('name');
        } else {
            buttonTextSpan.textContent = this.#observable.getProperty('treeKey', 'meta');
        }
        dropdownDiv.setButton(buttonTextSpan, true);
        const that = this;
        dropdownDiv.buttonElement.addEventListener('click', function() {
            if (dropdownDiv.contentDivElement.classList.contains('expanded')) {
                that.#featureEditModal = new FeatureEditModal([that.#observable], that.#controller);
                dropdownDiv.insertElement(that.#featureEditModal.getDOMElement());
            } else {
                that.#featureEditModal.remove();
            }
        });
        if (this.#dropdownDiv === null) {
            this.#dropdownDiv = dropdownDiv;
        }
        if (document.body.contains(this.#dropdownDiv.divElement)) {
            this.#dropdownDiv.divElement.replaceWith(dropdownDiv.divElement);
            this.#dropdownDiv = dropdownDiv;
        }
    }
}
</script>
<script>
"use strict";

class Modal {
    divElement;         // - The divElement is the outermost div that contains the modal's content
    #bannerElement;     // - The bannerElement contains the banner text. It's usually empty unless the user needs to be notified of something
    #containerElement;  // - The containerElement contains optional elements (e.g. buttons)
    #tableElement;      // - The table element is an actual table
    #titleElement;      // - The title element contains the optional title text

    /**
     * @returns {undefined}
     */
    constructor() {
        this.divElement = document.createElement('div');
        this.divElement.classList.add('js-div--modal');
        this.divElement.addEventListener('click', function(e) {
            // - Don't let clicks on the divElement cause the modalInsert to close
            e.stopPropagation();
        });
        this.#bannerElement = null;
        this.#containerElement = null;
        this.#tableElement = null;
        this.#titleElement = null;
    }
    
    /******************/
    /* Public methods */
    /******************/

    /**
     * @param {(string|Node)} banner - the banner to display
     * @param {Array} [styles=null] - any styles that should be applied to the banner
     * @returns {undefined}
     */
    setBanner(banner, styles=null) {
        if (this.#bannerElement === null) {
            this.#bannerElement = document.createElement('div');
            this.#bannerElement.classList.add('div--modalBanner');
            this.divElement.prepend(this.#bannerElement);
        }
        if (typeof banner === 'string') {
            const span = document.createElement('span');
            span.textContent = banner;
            this.#bannerElement.replaceChildren(span);
        } else if (banner instanceof Node) {
            this.#bannerElement.replaceChildren(banner);
        } else {
            throw TypeError('The "banner" argument must be a string or Node.');
        }
        if (!(styles instanceof Array) && styles !== null) {
            throw TypeError('The "styles" argumet must be an array or null.');
        }
        if (styles !== null) {
            this.#bannerElement.classList.value = `div--modalBanner ${styles.join(' ')}`;
        } else {
            this.#bannerElement.classList.value = 'div--modalBanner';
        }
    }

    /**
     * @param {(string|Node)} title - the title to display
     * @param {Array} [styles=null] - any styles that should be applied to the title
     * @returns {undefined}
     */
    setTitle(title, styles=null) {
        if (this.#titleElement === null) {
            this.#titleElement = document.createElement('div');
            this.#titleElement.classList.add('div--modalTitle');
        }
        if (this.#bannerElement === null) {
            this.divElement.prepend(this.#titleElement);
        } else {
            this.#bannerElement.after(this.#titleElement);
        }
        if (typeof title === 'string') {
            const span = document.createElement('span');
            span.textContent = title;
            this.#titleElement.replaceChildren(span);
        } else if (title instanceof Node) {
            this.#titleElement.replaceChildren(title);
        } else {
            throw TypeError('The "title" argument must be a string or Node.');
        }
        if (!(styles instanceof Array) && styles !== null) {
            throw TypeError('The "styles" argument must be an array or null.');
        }
        if (styles !== null) {
            this.#titleElement.classList.add(...styles);
        } else {
            this.#titleElement.classList.value = 'div--modalTitle';
        }
    }

    /**
     * @param {Array} elements - an array of elements that should occupy a table body row. null elements just append empty <td>/<td> elements
     * @param {string} [position='append'] - the location to insert the tBody row. Can be "prepend", "beforeEnd", or "append"
     * @param {(Array|null)} [styles=null] - any styles that should be applied to the row
     * @returns {undefined}
     */
    insertTBodyRow(elements, position='append', styles=null) {
        if (!(styles instanceof Array) && styles !== null) {
            throw TypeError('The "styles" argument must be an array or null.');
        }
        if (this.#tableElement === null) {
            this.#createTableElement();    
        }
        const tr = document.createElement('tr');
        if (styles !== null) {
            tr.classList.add(...styles);
        }
        elements.forEach(e => {
            const td = document.createElement('td');
            const div = document.createElement('div');
            if (typeof e === 'string') {
                const span = document.createElement('span');
                span.textContent = e;
                div.appendChild(span);
                td.appendChild(div)
            } else if (e instanceof Node) {
                div.appendChild(e);
                td.appendChild(div);
            } else if (e !== null) {
                throw TypeError(`The Table class only accepts arrays of null, Node, or string.`)
            }
            tr.appendChild(td);
        });
        if (position === 'prepend') {
            this.#tableElement.tBodies[0].prepend(tr);
        } else if (position === 'beforeEnd') {
            const lastNodeIndex = this.#tableElement.tBodies[0].children.length - 1;
            const lastNode = this.#tableElement.tBodies[0].children.item(lastNodeIndex);
            this.#tableElement.tBodies[0].insertBefore(tr, lastNode)
        } else if (position === 'append') {
            this.#tableElement.tBodies[0].appendChild(tr);
        } else {
            throw Error('Please specify a valid value for the "position" parameter: "prepend", "beforeEnd", or "append".');
        }
    }

    /**
     * @param {Array} elements - an array of elements that should occupy a table header row. null elements just append empty <td>/<td> elements
     * @param {string} [position='append'] - the location to insert the tHead row. Can be "prepend", "beforeEnd", or "append"
     * @param {Array} [styles=null] - any styles that should be applied to the row
     * @returns {undefined}
     */
    insertTHeadRow(elements, position='append', styles=null) {
        if (!(styles instanceof Array) && styles !== null) {
            throw TypeError('The "styles" argumet must be an array or null.');
        }
        if (this.#tableElement === null) {
            this.#createTableElement();
        }
        const tr = document.createElement('tr');
        if (styles !== null) {
            tr.classList.add(...styles);
        }
        elements.forEach(e => { 
            const th = document.createElement('th');
            const div = document.createElement('div');
            if (typeof e === 'string') {
                const span = document.createElement('span');
                span.textContent = e;
                div.appendChild(span);
                th.appendChild(div);
            } else if (e instanceof Node) {
                div.appendChild(e);
                th.appendChild(div);
            } else if (e !== null) {
                throw TypeError(`The Table class only accepts arrays of null, Node, or string.`);
            }
            tr.appendChild(th);
        });
        if (position === 'prepend') {
            this.#tableElement.tHead.prepend(tr);
        } else if (position === 'beforeEnd') {
            const lastNodeIndex = this.#tableElement.tHead.children.length - 1;
            const lastNode = this.#tableElement.tHead.children.item(lastNodeIndex);
            this.#tableElement.tHead.insertBefore(tr, lastNode)
        } else if (position === 'append') {
            this.#tableElement.tHead.appendChild(tr);
        } else {
            throw Error('Please specify a valid value for the "position" parameter: "prepend", "beforeEnd", or "append".');
        }
    }

    /**
     * @param {Array} styles
     * @param {string} elementName
     * @returns {undefined}
     */
    addStyleClasses(styles, elementName) {
        if (!(styles instanceof Array)) {
            throw TypeError('The "styles" argument must be an array.');
        }
        if (typeof elementName !== 'string') {
            throw TypeError('The "elementName" argument must be a string.');
        }
        switch (elementName) {
            case 'divElement':
                if (this.divElement !== null) {
                    this.divElement.classList.add(...styles);
                }
                break;
            case 'bannerElement':
                if (this.#bannerElement !== null) {
                    this.#bannerElement.classList.add(...styles);
                }
                break;
            case 'containerElement':
                if (this.#containerElement !== null) {
                    this.#containerElement.classList.add(...styles);
                }
                break;
            case 'tableElement':
                if (this.#tableElement !== null) {
                    this.#tableElement.classList.add(...styles);
                }
                break;
            case 'titleElement':
                if (this.#titleElement !== null) {
                    this.#titleElement.classList.add(...styles);
                }
                break;
            default:
                throw Error('The "elementName" argument must be "divElement", "bannerElement", "containerElement", "tableElement", or "titleElement".');
        }
    }

    /**
     * @param {Array} styles
     * @param {string} elementName
     * @returns {undefined}
     */
    removeStyleClass(styles, elementName) {
        if (!(styles instanceof Array)) {
            throw TypeError('The "styles" argument must be an array.');
        }
        if (typeof elementName !== 'string') {
            throw TypeError('The "elementName" argument must be a string.');
        }
        switch (elementName) {
            case 'divElement':
                if (this.divElement !== null) {
                    this.divElement.classList.remove(...styles);
                }
                break;
            case 'bannerElement':
                if (this.#bannerElement !== null) {
                    this.#bannerElement.classList.remove(...styles);
                }
                break;
            case 'containerElement':
                if (this.#containerElement !== null) {
                    this.#containerElement.classList.remove(...styles);
                }
                break;
            case 'tableElement':
                if (this.#tableElement !== null) {
                    this.#tableElement.classList.remove(...styles);
                }
                break;
            case 'titleElement':
                if (this.#titleElement !== null) {
                    this.#titleElement.classList.remove(...styles);
                }
                break;
            default:
                throw Error('The "elementName" argument must be "divElement", "bannerElement", "containerElement", "tableElement", or "titleElement".');
        }
    }

   /**
    * @param {Node} e - an element to append to the element div
    * @param {string} [position='append'] - the location to insert the element row. Can be "prepend", "beforeEnd", or "append"
    * @param {Array} [styles=null] - any styles that should be applied to the element
    * @returns {undefined}
    */
    insertElement(e, position='append', styles=null) {
        if (!(e instanceof Node)) {
            throw TypeError('"e" argument must be instanceof Node');
        }
        if (!(styles instanceof Array) && styles !== null) {
            throw TypeError('The "styles" argumet must be an array or null.');
        }
        if (styles !== null) {
            e.classList.add(...styles);
        }
        if (this.#containerElement === null) {
            this.#createContainerElement();
        }
        if (position === 'prepend') {
            this.#containerElement.prepend(e);
        } else if (position === 'beforeEnd') {
            const lastNodeIndex = this.#containerElement.children.length - 1;
            const lastNode = this.#containerElement.children.item(lastNodeIndex);
            this.#containerElement.insertBefore(e, lastNode)
        } else if (position === 'append') {
            this.#containerElement.appendChild(e);
        } else {
            throw Error('Please specify a valid value for the "position" parameter: "prepend", "beforeEnd", or "append".')
        } 
    }

    /**
     * @param {boolean} [spinner=true] - whether to show the spinner
     * @param {string} [bannerText=null] - the centered text to display below the spinnner, if the spinner exists
     * @param {Array} [styles=null] - any styles that should be applied to the title and banner
     * @returns {undefined}
     */
    showProgress(showSpinner=true, bannerText=null, styles=null) {
        if (typeof showSpinner !== 'boolean') {
            throw TypeError('The "showSpinner" argument must be a boolean.');
        }
        if (typeof bannerText !== 'string' && bannerText !== null) {
            throw TypeError('The "bannerText" argument must be a string or null.');
        }
        if (!(styles instanceof Array) && styles !== null) {
            throw TypeError('The "styles" argument must be an Array or null.');
        }
        const outerDiv = document.createElement('div');
        if (showSpinner) {
            const img = document.createElement('img');
            img.src = '/static/geoJsonMap/v3/spinner.gif';
            outerDiv.appendChild(img);
        }
        if (bannerText !== null) {
            const innerDiv = document.createElement('div');
            // - I don't want a span. A span gives me regular-sized font. I want banner-sized font
            //const span = document.createElement('span');
            //span.textContent = bannerText;
            innerDiv.textContent = bannerText;
            //innerDiv.appendChild(span);
            outerDiv.appendChild(innerDiv);
        }
        this.setBanner(outerDiv, styles);
    }

    // *********************
    // ** Private methods ** 
    // *********************

    #createTableElement() {
        this.#tableElement = document.createElement('table');
        this.#tableElement.classList.add('table--modal');
        this.#tableElement.appendChild(document.createElement('thead'));
        this.#tableElement.appendChild(document.createElement('tbody'));
        this.divElement.appendChild(this.#tableElement);
    }

    #createContainerElement() {
        this.#containerElement = document.createElement('div');
        this.#containerElement.classList.add('div--modalElementContainer');
        this.divElement.appendChild(this.#containerElement);
    }
}
</script>
<script>
"use strict";

class FeatureController { // implements ControllerInterface
    observableGraph; // - A FeatureGraph instance. It must be public so that views can query all of the data if they need to

    /**
     * @param {FeatureGraph} observableGraph - a FeatureGraph instance that contains all of the actual data
     */
    constructor(observableGraph) {
        if (!(observableGraph instanceof FeatureGraph)) {
            throw TypeError('The "observableGraph" argument must be instanceof FeatureGraph.')
        }
        this.observableGraph = observableGraph;
    }

    // *********************************
    // ** ControllerInterface methods **
    // *********************************

    /**
     * @param {Array} observables - an array of ObservableInterface instances that should be added to the graph
     * @returns {undefined}
     */
    addObservables(observables) {
        observables.forEach(ob => {
            const key = (this.observableGraph.getMaxKey() + 1).toString();
            ob.setProperty('treeKey', key, 'meta');
            this.observableGraph.insertObservable(ob);
            if (!ob.isConfigurationObject()) {
                LeafletLayer.createAndGroupLayer(ob, this);
            }
            if (ob.isLine()) {
                ob.getObservers().filter(ob => ob instanceof LeafletLayer)[0].getLayer().bringToBack();
            }
            if (ob.isChild()) {
                const parentKey = this.observableGraph.getKey(ob.getProperty('parent'), ob.getProperty('treeKey', 'meta'));
                const parentChildLineFeature = this.observableGraph.getParentChildLineFeature(parentKey, key);
                this.observableGraph.insertObservable(parentChildLineFeature);
                LeafletLayer.createAndGroupLayer(parentChildLineFeature, this);
                parentChildLineFeature.getObservers().filter(ob => ob instanceof LeafletLayer)[0].getLayer().bringToBack();
            }
        });
    }

    /**
     * - Delete the property with the matching namespace and property key from all of the ObservableInterface instances
     * @param {Array} observables - an array of ObservableInterface instances from which the property should be deleted
     * @param {string} propertyKey - the property key of the property that is in the observables
     * @param {string} [namespace='treeProps'] - the namespace of the property that is in the observables
     * @returns {undefined}
     */
    deleteProperty(observables, propertyKey, namespace='treeProps') {
        if (!(observables instanceof Array)) {
            throw TypeError('The "observables" argument must be instanceof Array.');
        }
        if (typeof propertyKey !== 'string') {
            throw TypeError('The "propertyKey" argument must be a string.');
        }
        if (typeof namespace !== 'string') {
            throw TypeError('The "namespace" argument must be a string.');
        }
        observables.forEach(ob => {
            if (ob.hasProperty(propertyKey, namespace)) {
                ob.deleteProperty(propertyKey, namespace);
            }
        });
        // - Currently, this function is a convenience function that views could do themselves because nothing else needs to be done besides calling
        //   deleteProperty() on the ObservableInterface instances
    }

    /**
     * - Tell the ObservableInterface instances to delete themselves
     * @param {Array} observables - an array of ObservableInterface instances from which the property should be deleted
     * @returns {undefined}
     */
    deleteObservables(observables) {
        if (!(observables instanceof Array)) {
            throw TypeError('The "observables" argument must be instanceof Array.');
        }
        const observablesCopy = [...observables];
        for (const ob of observablesCopy) {
            ob.deleteObservable();
        }
        // - I shouldn't have to do this because all visited nodes are deleted
        //this.observableGraph.markNodesAsUnvisited();
        // - Currently, this function is a convenience function that views could do themselves because nothing else needs to be done besides calling
        //   deleteObservable() on the ObservableInterface instances
    }

    /**
     * @param {Array} observables - an array of ObservableInterface instances whose coordinates should be set
     * @param {Array} coordinates - an array of coordinates for this ObservableInterface instance
     *  - E.g. for node Feature instances this should be in [<lon>, <lat>] format
     * @returns {undefined}
     */
    setCoordinates(observables, coordinates) {
        if (!(observables instanceof Array)) {
            throw TypeError('The "observables" argument must be instanceof Array.');
        }
        if (!(coordinates instanceof Array)) {
            throw TypeError('The "coordinates" argument must be instanceof Array.');
        }
        observables.forEach(ob => {
            ob.setCoordinates(coordinates);
        });
        // - I have to mark all the nodes as unvisted here because I can't do it in any of the other coordinate-related functions since they all call
        //   each other
        this.observableGraph.markNodesAsUnvisited();        
    }

    /**
     * @param {Array} observables - an array of ObservableInterface instances whose property should be set
     * @param {string} propertyKey - the property key of the property that is being created/changed in the ObservableInterface instances
     * @param {(string|Object)} propertyValue - the property value of the property that is being created/changed in the ObservableInterface instances.
     *  I don't like to store Objects, Arrays, etc. as property values, but it's required for certain observables like those that represent form
     *  objects
     * @param {string} [namespace='treeProps'] - the namespace of the property key in this observable. Whether a new namespace is created if a
     *  non-existent namespace is passed is implementation dependent. I throw a ReferenceError because I don't want new namespaces
     * @returns {undefined}
     */
    setProperty(observables, propertyKey, propertyValue, namespace='treeProps') {
        if (!(observables instanceof Array)) {
            throw TypeError('The "observables" argument must be instanceof Array.');
        }
        if (typeof propertyKey !== 'string') {
            throw TypeError('The "propertyKey" argument must be a string.');
        }
        if (typeof namespace !== 'string') {
            throw TypeError('The "namespace" argument must be a string.');
        }
        observables.forEach(ob => {
            ob.setProperty(propertyKey, propertyValue, namespace); 
            const obKey = ob.getProperty('treeKey', 'meta');
            if (['from', 'to'].includes(propertyKey)) {
                if (ob.isComponentFeature()) {
                    // - Do nothing. There's no need to set the coordinates of a component line that hasn't been inserted yet
                } else {
                    const fromKey = this.observableGraph.getKey(ob.getProperty('from'), obKey);
                    const toKey = this.observableGraph.getKey(ob.getProperty('to'), obKey);
                    const { sourceLat, sourceLon, targetLat, targetLon } = this.observableGraph.getLineLatLon(fromKey, toKey);
                    ob.setCoordinates([[sourceLon, sourceLat], [targetLon, targetLat]]);
                }
            } 
            if (propertyKey === 'parent') {
                if (ob.isComponentFeature()) {
                    // - Do nothing. Child components don't yet have a parent-child line
                } else {
                    const fromKey = this.observableGraph.getKey(ob.getProperty('parent'), obKey);
                    const toKey = obKey;
                    const { sourceLat, sourceLon, targetLat, targetLon } = this.observableGraph.getLineLatLon(fromKey, toKey);
                    const parentChildLine = this.observableGraph.getParentChildLine(obKey);
                    parentChildLine.setCoordinates([[sourceLon, sourceLat], [targetLon, targetLat]]);
                }
            } 
        });
        // - <FeatureGraph>.handleUpdatedProperty() no longer marks nodes as visited, so I don't need to undo that here
        //this.observableGraph.markNodesAsUnvisited();
    }
    
    // ********************
    // ** Public methods **
    // ********************

    /**
     * - Send an AJAX request to the server
     * @param {Feature} observable - the ObservableInterface instance to submit
     * @param {ModalFeatureModal} modal
     * @param {HTMLButtonElement} submitButton - a button to enable/disable depending on the state of the operation
     * @param {boolean} reload - whether or not to reload the page. This is necessary when chaining multiple operations together (e.g. every rename
     * operation must be preceeded by a save operation)
     * @returns {undefined}
     */
    async submitFeature(observable, modal, submitButton=null, reload=true) {
        if (!(observable instanceof Feature)) {
            throw TypeError('"observable" argument must be instanceof Feature.');
        }
        if (!(modal instanceof Modal)) {
            throw TypeError('The "modal" argument must be instanceof Modal.');
        }
        if (!(submitButton instanceof HTMLButtonElement) && !(submitButton === null)) {
            throw TypeError('The "submitButton" argument must be instanceof HTMLButtonElement or null');
        }
        if (typeof reload !== 'boolean') {
            throw TypeError('The "reload" argument must be a boolean.');
        }
        if (submitButton !== null) {
            submitButton.disabled = true;
        }
        const modalInsert = document.getElementById('modalInsert');
        let data;
        if (observable.hasProperty('fileExistsUrl', 'urlProps')) {
            try {
                data = await $.ajax({
                    type: observable.getProperty('fileExistsUrl', 'urlProps').method,
                    url: observable.getProperty('fileExistsUrl', 'urlProps').url
                });
                switch (observable.getProperty('treeKey', 'meta')) {
                    case 'modal:rename':
                    case 'modal:opendss':
                    case 'modal:windmil':
                    case 'modal:cymdist':
                    case 'modal:gridlabd':
                        if (data.exists === true) {
                            modal.showProgress(false, 'You already have a feeder with that name. Please choose a different name', ['caution']);
                            if (submitButton !== null) {
                                submitButton.disabled = false;
                            }
                            modalInsert.addEventListener('click', hideModalInsert);
                            return;
                        }
                        break;
                    case 'modal:loadFeeder':
                        // - I do this to assert that data.exists is equal to true, not that it is truthy. There's an important difference
                        if (data.exists === true) {
                            modal.showProgress(true, 'Loading feeder from the server...', ['caution']);
                            break;
                        }
                    default:
                        if (data.exists !== true) {
                            modal.showProgress(false, 'This feeder no longer exists on the server, so the operation failed. Please save and try again.', ['caution']);
                            if (submitButton !== null) {
                                submitButton.disabled = false;
                            }
                            modalInsert.addEventListener('click', hideModalInsert);
                        }
                }
            } catch {
                modal.showProgress(false, 'The server raised an internal exception during the operation. Please save before trying again.', ['caution']); 
                if (submitButton !== null) {
                    submitButton.disabled = false;
                }
                modalInsert.addEventListener('click', hideModalInsert);
                return;
            }
        }
        const formData = new FormData(); 
        if (observable.hasProperty('formProps', 'meta')) {
            for (const [key, val] of Object.entries(observable.getProperties('formProps'))) {
                formData.set(key, val);
            };
        }
        try {
            data = await $.ajax({
                type: observable.getProperty('submitUrl', 'urlProps').method,
                url: observable.getProperty('submitUrl', 'urlProps').url,
                data: formData,
                processData: false,
                contentType: false,
            });
        } catch {
            modal.showProgress(false, 'The server raised an internal exception during the operation. Please save before trying again.', ['caution']); 
            if (submitButton !== null) {
                submitButton.disabled = false;
            }
            modalInsert.addEventListener('click', hideModalInsert);
            return;
        }
        const that = this;
        // - We don't want to poll the server. Just reload the page.
        if (!observable.hasProperty('pollUrl', 'urlProps')) {
            if (data === 'Failure') {
                modal.showProgress(false, 'The server operation failed.', ['caution']);
                if (submitButton !== null) {
                    submitButton.disabled = false;
                }
                modalInsert.addEventListener('click', hideModalInsert);
            } else {
                if (reload) {
                    that.#reloadPage();
                } else {
                    document.getElementById('modalInsert').classList.remove('visible');
                    if (submitButton !== null) {
                        submitButton.disabled = false;
                    }
                    modalInsert.addEventListener('click', hideModalInsert);
                }
            }
        } else {
            const intervalId = setInterval(async function() {
                try {
                    data = await $.ajax({
                        type: observable.getProperty('pollUrl', 'urlProps').method,
                        url: observable.getProperty('pollUrl', 'urlProps').url
                    });
                    // - The server process ID file no longer exists, so the server operation completed successfully
                    if (data.exists === false) {
                        clearInterval(intervalId);
                        if (reload) {
                            that.#reloadPage();
                        } else {
                            document.getElementById('modalInsert').classList.remove('visible');
                            if (submitButton !== null) {
                                submitButton.disabled = false;
                            }
                            modalInsert.addEventListener('click', hideModalInsert);
                        }
                    } else if (data.exists === undefined) {
                        clearInterval(intervalId);
                        if (submitButton !== null) {
                            submitButton.disabled = false;
                        }
                        modalInsert.addEventListener('click', hideModalInsert);
                        if (data === 'milError') {
                            modal.showProgress(false, 'The .std and .seq files used were incorrectly formatted. Please save before trying again.', ['caution']);
                        } else if (data === 'dssError') {
                            modal.showProgress(false, 'The .dss file used was incorrectly formatted. Please save before trying again.', ['caution']);
                        } else if (data === 'cymeError') {
                            modal.showProgress(false, 'The .mdb file used was incorrectly formatted. Please save before trying again.', ['caution']);
                        } else if (data === 'glmError') {
                            modal.showProgress(false, 'The .glm file used was incorrectly formatted. Please save before trying again.', ['caution']);
                        } else if (data === 'amiError') {
                            modal.showProgress(false, 'The AMI file used was incorrectly formatted. Please save before trying again.', ['caution']);
                        } else if (data === 'anonymizeError') {
                            modal.showProgress(false, 'The anonymization process failed. Please save before trying again.', ['caution']);
                        } else {
                            if (!data.endsWith('.')) {
                                data += '.';
                            }
                            data += ' Please save before trying again.';
                            modal.showProgress(false, data, ['caution']);
                        }
                    // - The server process is ongoing, so let setInterval keep going
                    } else if (data.exists === true) {
                        // - Do nothing
                    } else {
                        if (submitButton !== null) {
                            submitButton.disabled = false;
                        }
                        modalInsert.addEventListener('click', hideModalInsert);
                        throw Error('Undefined value returned by server during the polling process.');
                    }
                } catch {
                    clearInterval(intervalId);
                    modal.showProgress(false, 'The server raised an internal exception during the operation. Please save before trying again.', ['caution']);
                    if (submitButton !== null) {
                        submitButton.disabled = false;
                    }
                    modalInsert.addEventListener('click', hideModalInsert);
                    return;
                }
            }, 10000);
        }
    }

    // *********************
    // ** Private methods ** 
    // *********************

    /**
     * - Force the client to always request new files from the server without using the browser cache.
     */
    #reloadPage() {
        window.location.reload(true);
        //console.log('Reloaded page');
    }
}
</script>
<script>
"use strict";

/**
 * - Each LeafletLayer instance is a view in the MVC pattern. Each observes an ObservableInterface instance, which is part of the model in the MVC
 *   pattern. An ObservableInterface instance does NOT observe a LeafletLayer instance. Instead, a LeafletLayer instance uses the controller to pass
 *   its own changes to the underlying ObservableInterface instance
 */
class LeafletLayer {    // implements ObserverInterface
    #controller;        // ControllerInterface instance
    #layer;             // - Leaflet layer
    #observable;        // - ObservableInterface instance
    #modal;
    static trackCursor = null;  // - HACK: the currently active trackCusor function. This is needed to get rid of sticky markers when the map gets a mouseup event
    static map = null;
    static control = null;
    static nodeLayers = L.featureGroup();
    static lineLayers = L.featureGroup();
    static parentChildLineLayers = L.featureGroup();
    static nodeClusterLayers = L.markerClusterGroup();
    static clusterControl = null;

    /**
     * @param {Feature} observable - an ObservableInterface instance
     * @param {FeatureController} controller - a ControllerInterface instance
     * @returns {undefined}
     */
    constructor(observable, controller) {
        if (!(observable instanceof Feature)) {
            throw TypeError('The "observable" argument must be instance of Feature.');
        }
        if (!(controller instanceof FeatureController)) {
            throw Error('The "controller" argument must be an instance of FeatureController.');
        }
        this.#controller = controller;
        this.#observable = observable;
        // - Here, the first observer is added to every visible feature
        this.#observable.registerObserver(this);
        const feature = {'type': 'Feature', 'geometry': {}};
        if (this.#observable.isNode()) {
            feature.geometry.type = 'Point';
        } else if (this.#observable.isLine()) {
            feature.geometry.type = 'LineString';
        } else if (this.#observable.isPolygon()) {
            feature.geometry.type = 'Polygon';
        } else if (this.#observable.isMultiPoint()) {
            feature.geometry.type = 'MultiPoint';
        } else if (this.#observable.isMultiLineString()) {
            feature.geometry.type = 'MultiLineString';
        } else if (this.#observable.isMultiPolygon()) {
            feature.geometry.type = 'MultiPolygon';
        } else {
            throw Error('The observable does not reference a valid GeoJSON feature (is it a configuration object or GeometryCollection?)');
        }
        feature.geometry.coordinates = structuredClone(this.#observable.getCoordinates());
        feature.properties = structuredClone(this.#observable.getProperties('meta'));
        // - L.geoJSON() returns an instance of https://leafletjs.com/reference.html#geojson
        //  - A GeoJSON object extends FeatureGroup which extends LayerGroup which extends Layer
        //  - Therefore, a GeoJSON object can contain one or more layers
        //  - Access the underlying layer(s) with <GeoJSON>._layers, which is a map (i.e. object) that maps layer ids to actual layer objects
        this.#layer = L.geoJSON(feature, {
            pointToLayer: this.#pointToLayer.bind(this), 
            style: this.#style.bind(this),
        });
        this.#layer.addEventListener('popupclose', () => {
            this.#observable.removeObserver(this.#modal);
        });
        if (this.#observable.isLine() || this.#observable.isPolygon() || this.#observable.isMultiPolygon()) {
            this.bindPopup();
        }
    }

    // *******************************
    // ** ObserverInterface methods ** 
    // *******************************

    /**
     * - Remove this ObserverInterface instance (i.e. "this") from the ObservableInterface instance (i.e. "observable") that has been deleted, and
     *   perform other actions as needed
     *  - E.g. delete this layer if its underlying feature was deleted
     * @param {Object} observable - an instance of ObservableInterface that this Observer is observing
     * @returns {undefined}
     */
    handleDeletedObservable(observable) {
        if (!(observable instanceof Feature)) {
            throw TypeError('The "observable" argument must be instance of Feature.');
        }
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        observable.removeObserver(this);
        const layer = Object.values(this.#layer._layers)[0]; 
        // - Why does this also delete the FeatureEditModal in the pop-up? I don't know but I have to deal with it
        layer.remove();
        // - Need to explicitly remove the underlying layer from its LayerGroup
        if (observable.isNode()) {
            LeafletLayer.nodeLayers.removeLayer(this.#layer);
            LeafletLayer.nodeClusterLayers.removeLayer(this.#layer);
        } else if (observable.isLine()) {
            if (observable.isParentChildLine()) {
                LeafletLayer.parentChildLineLayers.removeLayer(this.#layer);
            } else {
                LeafletLayer.lineLayers.removeLayer(this.#layer);
            }
        } else if (observable.isPolygon()) {
            // - Do nothing for now
        } else if (observable.isMultiPoint()) {
            // - Do nothing for now
        } else if (observable.isMultiLineString()) {
            // - Do nothing for now
        } else if (observable.isMultiPolygon()) {
            // - Do nothing for now
        } else {
            throw Error('The observable does not reference a valid GeoJSON feature (is it a configuration object or GeometryCollection?)');
        }
    }

    /**
     * - Update this ObserverInterface instance (i.e. "this") based on the coordinates of the ObservableInterface instance (i.e. "observable") that
     *   have just changed and perform other actions as needed
     *  - E.g. update this layer's coordinates if the coordinates of the underlying feature changed
     * @param {Object} observable - an instance of ObservableInterface that this Observer is observing
     * @param {Array} oldCoordinates - the old coordinates of the observable prior to the change in coordinates
     * @param {Array} visited - an array of ObserverInterface instances. It's required to prevent infinite recursion caused by Observers updating each
     * other
     * @returns {undefined}
     */
    handleUpdatedCoordinates(observable, oldCoordinates) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('The "observable" argument must be instance of Feature.');
        }
        if (!(oldCoordinates instanceof Array)) {
            throw TypeError('The "oldCoordinates" argument must be an array.')
        }
        const coordinates = observable.getCoordinates();
        if (observable.isNode()) {
            // - Object.values(this.<GeoJSON>.<mapping object>)[0] === <Layer>
            Object.values(this.#layer._layers)[0].setLatLng([coordinates[1], coordinates[0]]);
        } else {
            Object.values(this.#layer._layers)[0].setLatLngs([[coordinates[0][1], coordinates[0][0]],[coordinates[1][1], coordinates[1][0]]]);
        }
    }

    /**
     * - Update this ObserverInstance (i.e. "this") based on the property of the ObservableInterface instance (i.e. "observable") that has just
     *   changed and perform other actions as needed
     *  - E.g. update this line's "to" and/or "from" property to match the "name" property of the node that was just changed
     * @param {Object} observable - the observable that this observer is observing
     * @param {string} propertyKey - the property key of the property that has been created/changed/deleted in the observable
     * @param {(string|Object)} oldPropertyValue - the previous value of the property that has been created/changed/deleted in the observable
     * @param {string} namespace - the namespace of the property that has been created/changed/deleted in the observable
     * @returns {undefined}
     */
    handleUpdatedProperty(observable, propertyKey, oldPropertyValue, namespace='treeProps') {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('The "observable" argument must be instance of Feature.');
        }
        if (typeof propertyKey !== 'string') {
            throw TypeError('"propertyKey" argument must be a string.');
        }
        if (typeof namespace !== 'string') {
            throw TypeError('"namespace" argument must be a string.');
        }
        // - Currently, we don't need to do anything like change the color of a node in response to a property change, but we could
    }

    // ********************
    // ** Public methods **
    // ********************

    bindPopup() {
        const layer = Object.values(this.#layer._layers)[0];
        layer.bindPopup(() => {
            if (this.#observable.hasProperty('treeKey', 'meta')) {
                // - Show a modal for OMD objects
                this.#modal = new FeatureEditModal([this.#observable], this.#controller);
                return this.#modal.getDOMElement();
            } else {
                // - Show a modal for arbitrary GeoJSON features
                this.#modal = new TestModal([this.#observable], this.#controller);
                return this.#modal.getDOMElement();
            }
        });
    }

    unbindPopup() {
        Object.values(this.#layer._layers)[0].unbindPopup();
    }

    /**
     * - Creating a LeafletLayer with the constructor does not automatically add the underlying layer to a layer group by design. This function must
     *   be called explicitly, or LayerGroups must be managed outside of this function
     * @param {LeafletLayer} - layer
     * @returns {undefined}
     */
    static createAndGroupLayer(observable, controller) {
        if (!(observable instanceof Feature)) {
            throw TypeError('The "observable" argument must be instanceof Feature.');
        }
        if (!(controller instanceof FeatureController)) {
            throw TypeError('The "controller" argument must be instanceof FeatureController.');
        }
        const ll = new LeafletLayer(observable, controller);
        if (observable.isNode()) {
            // - If clustering is active and a component is added, then the layer of the component should go into the nodeClusterLayers group (very
            //   rare case but it's good to cover it)
            if (LeafletLayer.clusterControl._on) {
                LeafletLayer.nodeClusterLayers.addLayer(ll.getLayer());
            } else {
                LeafletLayer.nodeLayers.addLayer(ll.getLayer());
            }
        } else if (observable.isLine()) {
            if (observable.isParentChildLine()) {
                LeafletLayer.parentChildLineLayers.addLayer(ll.getLayer());
            } else {
                LeafletLayer.lineLayers.addLayer(ll.getLayer());
            }
        } else if (observable.isPolygon()) {
            // - Do nothing for now
        } else if (observable.isMultiPoint()) {
            // - Do nothing for now
        } else if (observable.isMultiLineString()) {
            // - Do nothing for now
        } else if (observable.isMultiPolygon()) {
            // - Do nothing for now
        } else {
            throw Error('The observable does not reference a valid GeoJSON feature (is it a configuration object or GeometryCollection?)');
        }
    }

    /**
     * @returns {GeoJSON}
     */
    getLayer() {
        return this.#layer;
    }

    /**
     * - Iterate through all observables and put every visible overvable back into its proper layer group
     * - This has to be static because it shouldn't need to be called off of any particular instance
     * @returns {undefined}
     */
    static resetLayerGroups(controller) {
        if (!(controller instanceof FeatureController)) {
            throw TypeError('The "controller" argument must be instanceof FeatureController.');
        }
        for (const observable of controller.observableGraph.getObservables()) {
            if (observable.isNode() && !observable.isConfigurationObject()) {
                const ll = observable.getObservers().filter(observer => observer instanceof LeafletLayer)[0];
                if (LeafletLayer.clusterControl._on) {
                    LeafletLayer.nodeClusterLayers.addLayer(ll.getLayer());
                } else {
                    LeafletLayer.nodeLayers.addLayer(ll.getLayer());
                }
            } else if (observable.isLine()) {
                const ll = observable.getObservers().filter(observer => observer instanceof LeafletLayer)[0];
                if (observable.isParentChildLine()) {
                    LeafletLayer.parentChildLineLayers.addLayer(ll.getLayer());
                } else {
                    LeafletLayer.lineLayers.addLayer(ll.getLayer());
                }
            }
        }
        // - Force redraw
        for (const layer of [LeafletLayer.parentChildLineLayers, LeafletLayer.lineLayers, LeafletLayer.nodeLayers, LeafletLayer.nodeClusterLayers]) {
            LeafletLayer.map.removeLayer(layer);
            LeafletLayer.map.addLayer(layer);
        }
    }

    // *********************
    // ** Private methods ** 
    // *********************

    #pointToLayer(feature, latlng) {
        const marker = L.circleMarker(latlng);
        // - Make circle marker draggable
        const trackCursor = (e) => {
            this.#controller.setCoordinates([this.#observable], [e.latlng.lng, e.latlng.lat]);
        };
        const mousedownPoint = {
            lat: null,
            lng: null
        };
        marker.on('mousedown', (e) => {
            // - Don't let the map get the mousedown event. This matters for multiselectControl.js
            L.DomEvent.stopPropagation(e);
            this.bindPopup();
            mousedownPoint.lat = e.latlng.lat;
            mousedownPoint.lng = e.latlng.lng;
            LeafletLayer.map.dragging.disable();
            LeafletLayer.map.on('mousemove', trackCursor);
            LeafletLayer.trackCursor = trackCursor;
        });
        marker.on('mouseup', (e) => {
            // - Don't let the map get the mouseup event. This matters for multiselectControl.js
            L.DomEvent.stopPropagation(e);
            LeafletLayer.map.dragging.enable();
            LeafletLayer.map.off('mousemove', trackCursor)
            LeafletLayer.trackCursor = null;
            if (e.latlng.lat !== mousedownPoint.lat || e.latlng.lng !== mousedownPoint.lng) {
                this.unbindPopup();
            }
            mousedownPoint.lat = null;
            mousedownPoint.lng = null;
        });
        return marker;
    }

    #style() {
        // - Extension styling
        if (this.#observable.hasProperty('SOVI_RATNG', 'meta') && this.#observable.getProperty('SOVI_RATNG', 'meta') === 'Very High') {
            return {
                color: 'blue'
            }
        } else if (this.#observable.hasProperty('SOVI_RATNG', 'meta') && this.#observable.getProperty('SOVI_RATNG', 'meta') === 'Relatively High') {
            return {
                color: 'lightblue'
            }
        } else if (this.#observable.hasProperty('SOVI_RATNG', 'meta') && this.#observable.getProperty('SOVI_RATNG', 'meta') === 'Relatively Moderate') {
            return {
                color: 'lightgreen'
            }
        } else if (this.#observable.hasProperty('SOVI_RATNG', 'meta') && this.#observable.getProperty('SOVI_RATNG', 'meta') === 'Relatively Low') {
            return {
                color: 'yellow'
            }
        } else if (this.#observable.hasProperty('SOVI_RATNG', 'meta') && this.#observable.getProperty('SOVI_RATNG', 'meta') === 'Very Low') {
            return {
                color: 'grey'
            }
        }
        // - Default OMF editor styling
        if (this.#observable.isNode()) {
            let fillColor = 'gray';
            if (this.#observable.hasProperty('pointColor')) {
                fillColor = this.#observable.getProperty('pointColor');
            } else if (this.#observable.hasProperty('object')) {
                const object = this.#observable.getProperty('object');
                if (object === 'capacitor') {
                    fillColor = 'purple';
                }
                if (object === 'generator') {
                    fillColor = 'red';
                }
                if (object == 'load') {
                    fillColor = 'blue';
                }
            }
            return {
                color: 'black',
                fillColor: fillColor,
                fillOpacity: .8,
                radius: 6.5,
                weight: 1
            }
        }
        if (this.#observable.isParentChildLine()) {
            return {
                color: 'black',
                // - Dashed lines are only useful if the child is reasonably far from the parent, so I need other differences in style
                dashArray: '.5 10',
                lineCap: 'square',
                weight: '3'
            }
        }
        if (this.#observable.isLine()) {
            let color = 'black';
            if (this.#observable.hasProperty('edgeColor')) {
                color = this.#observable.getProperty('edgeColor')
            } else if (this.#observable.hasProperty('object')) {
                const object = this.#observable.getProperty('object');
                if (object === 'transformer') {
                    color = 'orange';
                } else if (object === 'regulator') {
                    color = 'red';
                } else if (object === 'underground_line') {
                    color = 'gray';
                }

            }
            return {
                color: color
            }
        }
        return {
            color: 'blue'
        }
    }
}

</script>
<script>
"use strict";

class SideNav {
    navElement; // Navigation pane. Contains divs
    divElement; // Cover pane for when the SideNav is opened in a narrow browser
    articleElement; // Content that shifts when the SideNav opens

    constructor() {
        this.navElement = document.createElement('nav');
        this.navElement.classList.add('js-nav--sideNav');
        this.divElement = document.createElement('div');
        this.divElement.classList.add('js-div--sideNavCover');
        this.articleElement = document.createElement('article');
        this.articleElement.classList.add('js-article--sideNavArticle');
    }
}
</script>
<script>
"use strict";

const ZoomControlClass = L.Control.extend({
    options: {
        position: 'topleft' // - Position the control in the top left corner by default
    },
    initialize: function(controller, options=null) {
        if (!(controller instanceof FeatureController)) {
            throw TypeError('The "controller" argument must be instanceof FeatureController.');
        }
        this._controller = controller;
        // - Create div
        this._div = L.DomUtil.create('div', 'leaflet-bar');
        this._div.classList.add('leaflet-customControlDiv');
        L.DomEvent.disableClickPropagation(this._div);
        this._div.appendChild(this._getSvg());
        // - Add a tooltip
        this._div.title = '- The focus button pans the map to show the circuit';
        // - Attach listeners
        this._div.addEventListener('click', () => {
            if (LeafletLayer.nodeClusterLayers.getLayers().length > 0) {
                LeafletLayer.map.fitBounds(LeafletLayer.nodeClusterLayers.getBounds());
            } else if (LeafletLayer.nodeLayers.getLayers().length > 0) {
                LeafletLayer.map.fitBounds(LeafletLayer.nodeLayers.getBounds());
            } else {
                LeafletLayer.map.fitBounds(LeafletLayer.lineLayers.getBounds());
            }
        });
        if (options !== null) {
            L.setOptions(this, options);
        }
    },
    onAdd(map) {
        return this._div; 
    },
    onRemove(map) {

    },
    _getSvg() {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '32px');
        svg.setAttribute('height', '32px');
        svg.setAttribute('viewBox', '0 0 64 64');
        svg.setAttribute('fill', 'none');
        let element = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        element.setAttribute('cx', '32');
        element.setAttribute('cy', '32');
        element.setAttribute('r', '18.5');
        element.setAttribute('stroke', '#000000');
        element.setAttribute('stroke-width', '4');
        svg.appendChild(element);
        element = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        element.setAttribute('cx', '32');
        element.setAttribute('cy', '32');
        element.setAttribute('r', '10.68');
        element.setAttribute('stroke', '#000000');
        element.setAttribute('stroke-width', '4');
        svg.appendChild(element);
        element = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        element.setAttribute('x1', '32');
        element.setAttribute('y1', '4.56');
        element.setAttribute('x2', '32');
        element.setAttribute('y2', '26.56');
        element.setAttribute('stroke', '#000000');
        element.setAttribute('stroke-width', '4');
        element.setAttribute('stroke-linecap', 'round');
        svg.appendChild(element);
        element = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        element.setAttribute('x1', '32');
        element.setAttribute('y1', '37');
        element.setAttribute('x2', '32');
        element.setAttribute('y2', '59');
        element.setAttribute('stroke', '#000000');
        element.setAttribute('stroke-width', '4');
        element.setAttribute('stroke-linecap', 'round');
        svg.appendChild(element);
        element = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        element.setAttribute('x1', '37');
        element.setAttribute('y1', '32');
        element.setAttribute('x2', '59');
        element.setAttribute('y2', '32');
        element.setAttribute('stroke', '#000000');
        element.setAttribute('stroke-width', '4');
        element.setAttribute('stroke-linecap', 'round');
        svg.appendChild(element);
        element = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        element.setAttribute('x1', '5.06');
        element.setAttribute('y1', '32');
        element.setAttribute('x2', '26.94');
        element.setAttribute('y2', '32');
        element.setAttribute('stroke', '#000000');
        element.setAttribute('stroke-width', '4');
        element.setAttribute('stroke-linecap', 'round');
        svg.appendChild(element);
        return svg;
    }
});
</script>
<script>
"use strict";

class Feature {
    #feature;
    #graph;
    #observers;

    /**
     * @param {Object} feature - a standard GeoJSON feature
     * @param {FeatureGraph} graph - an already-constructed graph that is used to optimize observable-observer notifications
     * @returns {undefined}
     */
    constructor(feature) {
        this.#feature = feature;
        this.#graph = null
        this.#observers = [];
    }
    
    // *********************************
    // ** ObservableInterface methods **
    // *********************************

    /**
     * - Delete the property with the matching namespace and property key in this ObservableInstance (i.e. "this") if it exists, otherwise throw a
     *   ReferenceError
     * @param {string} propertyKey - the property key of the property that is in the observable
     * @param {string} [namespace='treeProps'] - the namespace of the property that is in the observable 
     *  - E.g. for Feature instances, this defaults to "treeProps" which corresponds to properties in the "treeProps" object
     * @returns {undefined}
     */
    deleteProperty(propertyKey, namespace='treeProps') {
        // - The function signature above is part of the ObservableInterface API. The implementation below is not
        if (typeof propertyKey !== 'string') {
            throw TypeError('The "propertyKey" argument must be a string.');
        }
        if (typeof namespace !== 'string') {
            throw TypeError('The "namespace" argument must be a string.');
        }
        if (['treeProps', 'formProps', 'urlProps'].includes(namespace)) {
            if (this.#feature.properties.hasOwnProperty(namespace)) {
                if (this.#feature.properties[namespace].hasOwnProperty(propertyKey)) {
                    const oldPropertyValue = this.getProperty(propertyKey, namespace);
                    delete this.#feature.properties[namespace][propertyKey];
                    this.updatePropertyOfObservers(propertyKey, oldPropertyValue, namespace);
                } else {
                    throw ReferenceError(`The property "${propertyKey}" could not be found in the namespace "${namespace}" in the Feature instance.`);
                }
            } else {
                throw ReferenceError(`This feature does not have the namespace "${namespace}".`);
            }
        } else if (namespace === 'meta') {
            if (this.#feature.properties.hasOwnProperty(propertyKey)) {
                const oldPropertyValue = this.getProperty(propertyKey, namespace);
                delete this.#feature.properties[propertyKey];
                this.updatePropertyOfObservers(propertyKey, oldPropertyValue, namespace);
            } else {
                throw ReferenceError(`The property "${propertyKey}" could not be found in the namespace "${namespace}" in the Feature instance.`);
            }
        } else {
            throw ReferenceError(`The namespace "${namespace}" does not exist in this Feature. Leave the "namespace" argument empty to use the "treeProps" namespace.`);
        }
    }

    /**
     * - Mark this ObservableInterface instance as being no longer observable to any observers (i.e. "delete" it)
     *  - Make all of its observers ignore it
     *  - Remove it from the ObservableGraph interface instance
     * @returns {undefined}
     */
    deleteObservable() {
        // - The function signature above is part of the ObservableInterface API. The implementation below is not
        // - I need to clone the array because if I iterate over this.#observers while I'm removing elements from it, everything gets messed up
        const observers = [...this.#observers];
        observers.forEach(ob => {
            ob.handleDeletedObservable(this);
        });
        if (this.#graph instanceof FeatureGraph) {
            this.#graph.handleDeletedObservable(this);
        }
    }

    /**
     * @returns {Array} the coordinates of the ObservableInterface instance in [<lon>, <lat>] format
     *  - E.g. [<lon>, <lat>] for points and [[<lon_1>, <lat_1>], [<lon_2>, <lat_2>]] for lines
     */
    getCoordinates() {
        // - The function signature above is part of the ObservableInterface API. The implementation below is not
        return this.#feature.geometry.coordinates;
    }

    getObservable() {
        throw new UnsupportedOperationError();
    }

    /**
     * @returns {Object} a copy of the underlying data of this ObservableInterface instance
     *  - E.g. a vanilla JavaSCript GeoJSON feature object
     */
    getObservableExportData() {
        const clone = structuredClone(this.#feature);
        if (clone.properties.hasOwnProperty('treeProps')) {
            if (clone.properties.treeProps.hasOwnProperty('object')) {
                // - Recorders and players cannot have a "name" property when being saved, but they need to maintain that property in the interface
                if (['recorder', 'player'].includes(clone.properties.treeProps.object)) {
                    if (clone.properties.treeProps.hasOwnProperty('name')) {
                        const nameComponents = clone.properties.treeProps.name.split(':');
                        if (nameComponents.length === 3 && nameComponents[2] === 'addedName') {
                            delete clone.properties.treeProps.name;
                        }
                    }
                }
                // - !CMD objects have their "name" property moved to the "command" property in the interface so that they have unique names. The
                //   "name" property value must be set to the value of the "command" property on export
                if (clone.properties.treeProps.object === '!CMD') {
                    clone.properties.treeProps.name = clone.properties.treeProps.CMD_command;
                    delete clone.properties.treeProps.CMD_command;
                }
                // - geo_py_validation_status should never be written back to any file
                delete clone.properties.treeProps['geo_py_validation_status'];
            }
        }
        return clone;
    }

    getObservables(func) {
        throw new UnsupportedOperationError();
    }

    /**
     * - Get the ObserverInterface instances that are observing this ObservableInterface instance
     *  - This is needed to get the LeafletMap for the Zoom button in the TreeFeatureModal class
     * @returns {Array}
     */
    getObservers() {
        return this.#observers;
    }

    /**
     * - Return the properties in the specified namespace in this ObservableInstance (i.e. "this") if it exists, otherwise throw a ReferenceError
     * @param {string} namespace - the namespace of some properties in this observable
     * @returns {Object}
     */
    getProperties(namespace) {
        // - The function signature above is part of the ObservableInterface API. The implementation below is not
        if (typeof namespace !== 'string') {
            throw TypeError('The "namespace" argument must be a string');
        }
        if (['treeProps', 'formProps', 'urlProps'].includes(namespace)) {
            if (this.#feature.properties.hasOwnProperty(namespace)) {
                // - I need to be consistent
                return this.#feature.properties[namespace];
            }
            throw ReferenceError(`This feature does not have the namespace "${namespace}".`);
        } else if (namespace === 'meta') {
            // - I need to be consistent
            return this.#feature.properties;
        }
        throw ReferenceError(`The namespace "${namespace}" does not exist in this Feature. Leave the "namespace" argument empty to get all properties.`);
    }

    /**
     * - Return the property value of the property with the matching namespace and property key in this ObservableInstance (i.e. "this") if it exists,
     *   otherwise throw a ReferenceError
     * @param {string} propertyKey - the property key of the property that is in the observable
     * @param {string} [namespace='treeProps'] - the namespace of the property that is in the observable 
     *  - E.g. for Feature instances, this defaults to "treeProps" which corresponds to properties in the "treeProps" object
     * @returns {(string|Object)} propertyValue 
     */
    getProperty(propertyKey, namespace='treeProps') {
        // - The function signature above is part of the ObservableInterface API. The implementation below is not
        if (typeof propertyKey !== 'string') {
            throw TypeError('The "propertyKey" argument must be a string.');
        }
        if (typeof namespace !== 'string') {
            throw TypeError('The "namespace" argument must be a string.');
        }
        if (['treeProps', 'formProps', 'urlProps'].includes(namespace)) {
            if (this.#feature.properties.hasOwnProperty(namespace)) {
                if (this.#feature.properties[namespace].hasOwnProperty(propertyKey)) {
                    // - At this point, I don't want to return a structuredClone becuase I use this method everywhere
                    return this.#feature.properties[namespace][propertyKey];
                }
                throw ReferenceError(`The property "${propertyKey}" could not be found in the namespace "${namespace}" in the Feature instance."`);
            }
            throw ReferenceError(`This feature does not have the namespace "${namespace}".`);
        } else if (namespace === 'meta') {
            if (this.#feature.properties.hasOwnProperty(propertyKey)) {
                // - I need to be consistent
                return this.#feature.properties[propertyKey];
            }
            throw ReferenceError(`The property "${propertyKey}" could not be found in the namespace "${namespace}" in the Feature instance."`);
        }
        throw ReferenceError(`The namespace "${namespace}" does not exist in this Feature. Leave the "namespace" argument empty to use the "treeProps" namespace.`);
    }

    /**
     * @returns {boolean} whether this ObservableInterface instance has coordinates
     */
    hasCoordinates() {
        // - The function signature above is part of the ObservableInterface API. The implementation below is not
        if (this.#feature.geometry.type === 'Point') {
            return !this.#feature.geometry.coordinates.some(c => typeof c !== 'number');
        } else if (this.#feature.geometry.type === 'LineString') {
            return !this.#feature.geometry.coordinates.flat().some(c => typeof c !== 'number');
        } else if (this.#feature.geometry.type === 'Polygon') {
            return !this.#feature.geometry.coordinates.flat(2).some(c => typeof c !== 'number');
        } else if (this.#feature.geometry.type === 'MultiPoint') {
            return !this.#feature.geometry.coordinates.flat().some(c => typeof c !== 'number');
        } else if (this.#feature.geometry.type === 'MultiLineString') {
            return !this.#feature.geometry.coordinates.flat(2).some(c => typeof c !== 'number');
        } else if (this.#feature.geometry.type === 'MultiPolygon') {
            return !this.#feature.geometry.coordinates.flat(3).some(c => typeof c !== 'number');
        } else {
            throw Error('The observable does not reference a valid GeoJSON feature (is it a configuration object or GeometryCollection?)');
        }
    }

    /**
     * @returns {boolean} whether this ObservableInterface instance has this.#graph set to some FeatureGraph
     */
    hasGraph() {
        // - The function signature above is part of the ObservableInterface API. The implementation below is not
        return (this.#graph instanceof FeatureGraph);
    }

    /**
     * @param {string} propertyKey - the property key of the property that may or may not be in this observable's namespace 
     * @param {string} [namespace='treeProps'] - the namespace of the property key that may or may not be in this observable
     * @returns {boolean}
     */
    hasProperty(propertyKey, namespace='treeProps') {
        // - The function signature above is part of the ObservableInterface API. The implementation below is not
        if (typeof propertyKey !== 'string') {
            throw TypeError('The "propertyKey" argument must be a string.');
        }
        if (typeof namespace !== 'string') {
            throw TypeError('The "namespace" argument must be a string.');
        }
        if (['treeProps', 'formProps', 'urlProps'].includes(namespace)) {
            if (this.#feature.properties.hasOwnProperty(namespace)) {
                return this.#feature.properties[namespace].hasOwnProperty(propertyKey);
            }
            return false;
        } else if (namespace === 'meta') {
            return this.#feature.properties.hasOwnProperty(propertyKey);
        }
        throw ReferenceError(`The namespace "${namespace}" does not exist in this Feature. Leave the "namespace" argument empty to use the "treeProps" namespace.`);
    }

    /**
     * @returns {undefined}
     */
    notifyObserversOfNewObservable() {
        throw new UnsupportedOperationError();
    }

    /**
     * @param {Object} observer - an instance of ObserverInterface that wants to observer this ObservableInterface instance
     *  - E.g. this feature is a node and a LeafletLayer instance wants to observe it
     * @returns {undefined}
     */
    registerObserver(observer) {
        // - The function signature above is part of the ObservableInterface API. The implementation below is not
        if (observer instanceof Feature) {
            throw new ObserverError();
        }
        this.#observers.push(observer);
    }

    /**
     * @param {Object} observer - an instance of ObserverInterface that no longer should observe this ObservableInterface instance
     *  - E.g. a TreeFeatureModal instance shouldn't observe this ObservableInterface instance anymore
     * @returns {undefined}
     */
    removeObserver(observer) {
        // - The function signature above is part of the ObservableInterface API. The implementation below is not
        if (observer instanceof Feature) {
            throw new ObserverError();
        }
        const index = this.#observers.indexOf(observer);
        if (index > -1) {
            this.#observers.splice(index, 1);
        } else {
            // - Unfortunately, <Leaflet layer>.remove() also removes the FeatureEditModal in the pop-up from this.#observers for some reason before
            //   the FeatureEditModal is removed. I can't control the behavior of Leaflet, so I can't throw an error here
            //console.log('The observer was not found in this.#observers');
            //throw Error('The observer was not found in this.#observers');
        }
    }

    /**
     * @param {Array} coordinates - an array of coordinates for this ObservableInterface instance
     *  - E.g. for Feature instances this should be in [<lon>, <lat>] format
     * @returns {undefined}
     */
    setCoordinates(coordinates) {
        // - The function signature above is part of the ObservableInterface API. The implementation below is not
        if (!(coordinates instanceof Array)) {
            throw TypeError('The "coordinates" argument must be instanceof Array.');
        }
        // - Check that all coordinate values are valid numbers
        const flatCoordinates = coordinates.flat(3);
        for (let i = 0; i < flatCoordinates.length; i++) {
            const coordinateType = typeof flatCoordinates[i];
            if (!['string', 'number'].includes(coordinateType)) {
                throw TypeError(`${flatCoordinates[i]} must be typeof number or string.`);
            }
            flatCoordinates[i] = +flatCoordinates[i];
            if (isNaN(flatCoordinates[i])) {
                throw TypeError(`${flatCoordinates[i]} must be a valid number.`);
            }
        }
        if (this.isNode()) {
            coordinates[0] = +coordinates[0];
            coordinates[1] = +coordinates[1];
            if (coordinates.length !== 2) {
                throw Error('"coordinates" argument must be an array of two numbers for node features.');
            }
        } else if (this.isLine()) {
            coordinates[0][0] = +coordinates[0][0];
            coordinates[0][1] = +coordinates[0][1];
            coordinates[1][0] = +coordinates[1][0];
            coordinates[1][1] = +coordinates[1][1];
            if (coordinates.length !== 2) {
                throw Error('"coordinates" argument must be an array of two arrays of two numbers for line features.');
            }
        } else if (this.isPolygon()) {
            for (let i = 0; i < coordinates.length; i++) {
                let ary = coordinates[i];
                for (const innerAry of ary) {
                    innerAry[0] = +innerAry[0];
                    innerAry[1] = +innerAry[1];
                    if (innerAry.length !== 2) {
                        throw Error('"coordinates" argument must be an array of one or two arrays, each containing at least two arrays of points for polygon features.');
                    }
                }
            }
        } else {
            throw Error('MultiPoint, MultiLineString, MultiPolygon, and GeometryCollection are not yet supported by setCoordinates().');
        }
        const oldCoordinates = this.getCoordinates();
        this.#feature.geometry.coordinates = coordinates;
        this.updateCoordinatesOfObservers(oldCoordinates);
    }

    /**
     * - Set the "graph" property of this Feature instance to optimize communication between Feature observables and Feature observers. All
     *   non-component Feature instances are part of the same graph. I can use a graph because all Features have a unique ID, but the overall Observer
     *   Pattern doesn't assume that Observables have unique IDs or that a graph exists at all
     * - Calling this method essentially makes this Feature observable to all other features and makes it an observer of all other features
     * - This method is only supposed to be invoked by an instance of the FeatureGraph class
     * @param {FeatureGraph} graph - an instance of my FeatureGraph class that has already been built
     * @returns {undefined}
     */
    setGraph(graph) {
        if (!(graph instanceof FeatureGraph)) {
            throw TypeError('"graph" argument must be an instanceof FeatureGraph.');
        }
        if (this.#graph instanceof FeatureGraph) {
            throw Error(`The feature "${this.getProperty('treeKey', 'meta')}" is already in a FeatureGraph.`);
        }
        this.#graph = graph;
    }

    /**
     * @param {string} propertyKey - the property key of the property that is being changed or created in this ObservableInterface instance
     * @param {(string|Object)} propertyValue - the property value of the property that is being changed or created in this observable. I don't like
     *  to store Objects, Arrays, etc. as property values, but it's required for certain observables like those that represent form objects
     * @param {string} [namespace='treeProps'] - the namespace of the property key in this observable. Whether a new namespace is created if a
     *  non-existent namespace is passed is implementation dependent. I throw a ReferenceError because I don't want new namespaces
     * @returns {undefined}
     */
    setProperty(propertyKey, propertyValue, namespace='treeProps') {
        // - The function signature above is part of the ObservableInterface API. The implementation below is not
        if (typeof propertyKey !== 'string') {
            throw TypeError('The "propertyKey" argument must be a string.');
        }
        if (typeof namespace !== 'string') {
            throw TypeError('The "namespace" argument must be a string.');
        }
        if (['treeProps', 'formProps', 'urlProps'].includes(namespace)) {
            if (this.#feature.properties.hasOwnProperty(namespace)) {
                let oldPropertyValue = propertyValue;
                if (this.hasProperty(propertyKey, namespace)) {
                    oldPropertyValue = this.getProperty(propertyKey, namespace);
                }
                this.#feature.properties[namespace][propertyKey] = propertyValue;
                this.updatePropertyOfObservers(propertyKey, oldPropertyValue, namespace);
                return;
            } 
            throw ReferenceError(`This feature does not have the namespace "${namespace}".`);
        } else if (namespace === 'meta') {
            let oldPropertyValue = propertyValue;            
            if (this.hasProperty(propertyKey, namespace)) {
                oldPropertyValue = this.getProperty(propertyKey, namespace);
            }
            this.#feature.properties[propertyKey] = propertyValue;
            this.updatePropertyOfObservers(propertyKey, oldPropertyValue, namespace);
            return;
        }
        throw ReferenceError(`The namespace "${namespace}" does not exist in this Feature. Leave the "namespace" argument empty to use the "treeProps" namespace.`);
    }

    /**
     * - Don't pass arbitrary messages between Observables and Observers. If I want to do crazy things like use one node as a pivot point to rotate
     *   all of the other nodes, all of the rotating nodes should have a "pivot" property in the meta namespace that matches this Observable or
     *   something, and they should check that property when coordinates are updated and respond appropriately
     * @param {Array} oldCoordinates - the previous coordinates of this ObservableInterface instance prior to the new, current coordinates
     * @returns {undefined}
     */
    updateCoordinatesOfObservers(oldCoordinates) {
        // - The function signature above is part of the ObservableInterface API. The implementation below is not
        this.#observers.forEach(ob => ob.handleUpdatedCoordinates(this, oldCoordinates));
        if (this.#graph instanceof FeatureGraph) {
            this.#graph.handleUpdatedCoordinates(this, oldCoordinates);
        }
    }

    /**
     * - This should really be called "notifyObserversOfChangedProperty"
     * @param {string} propertyKey - the property key of the property that is being created/changed/deleted in this ObservableInterface instance
     * @param {(string|Object)} oldPropertyValue - the previous property value of the property that was created/changed/deleted in this observable. I
     *  don't like to store Objects, Arrays, etc. as property values, but it's required for certain observables like those that represent form objects
     * @param {string} [namespace='treeProps'] - the namespace of the property key in this observable. Whether a new namespace is created if a
     *  non-existent namespace is passed is implementation dependent. I throw a ReferenceError because I don't want new namespaces
     * @returns {undefined}
     */
    updatePropertyOfObservers(propertyKey, oldPropertyValue, namespace='treeProps') {
        // - The function signature above is part of the ObservableInterface API. The implementation below is not
        if (typeof propertyKey !== 'string') {
            throw TypeError('The "propertyKey" argument must be typeof string.');
        }
        if (typeof namespace !== 'string') {
            throw TypeError('The "namespace" argument must be typeof string.');
        }
        this.#observers.forEach(ob => ob.handleUpdatedProperty(this, propertyKey, oldPropertyValue, namespace));
        if (this.#graph instanceof FeatureGraph) {
            this.#graph.handleUpdatedProperty(this, propertyKey, oldPropertyValue, namespace);
        }
    }

    // *******************************
    // ** ObserverInterface methods **
    // *******************************

    /**
     * - Remove this ObserverInterface instance (i.e. "this") from the ObservableInterface instance (i.e. "observable") that has been deleted, and
     *   perform other actions as needed
     * @param {Object} observable - an instance of ObservableInterface that this Observer is observing
     * @returns {undefined}
     */
    handleDeletedObservable(observable) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        throw new UnsupportedOperationError();
    }

    handleNewObservable(observable) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        throw new UnsupportedOperationError();
    }

    /**
     * - Update this ObserverInterface instance (i.e. "this") based on the coordinates of the ObservableInterface instance (i.e. "observable") that
     *   have just changed and perform other actions as needed
     *  - E.g. update the line observer's coordinates to match the node observable's coordinates if the line was connected to the node
     * @param {Object} observable - an instance of ObservableInterface that this Observer is observing
     * @param {Array} oldCoordinates - the old coordinates of the observable prior to the change in coordinates
     * @returns {undefined}
     */
    handleUpdatedCoordinates(observable, oldCoordinates) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(oldCoordinates instanceof Array)) {
            throw TypeError('The "oldCoordinates" argument must be an array.');
        }
        const observableName = observable.getProperty('name');
        const thisName = this.getProperty('name');
        const thisKey = this.getProperty('treeKey', 'meta');
        if (this.isLine()) {
            const fromName = this.getProperty('from');
            const toName = this.getProperty('to');
            if (![fromName, toName].includes(observableName)) {
                if (observable.isLine()) {
                    // - This isn't an error. It means a child line is connected to this line and the child line was updated. Since parents observe
                    //   children, this line gets a call to update even though it doesn't need to do anything
                } else {
                    throw Error(`The Feature instance "${observableName}" is not connected to the line Feature instance "${thisName}."`);
                }
            }
            const fromKey = this.#graph.getKey(fromName, thisKey);
            const toKey = this.#graph.getKey(toName, thisKey);
            const { sourceLat, sourceLon, targetLat, targetLon } = this.#graph.getLineLatLon(fromKey, toKey);
            this.setCoordinates([[sourceLon, sourceLat], [targetLon, targetLat]]);
        } else {
            throw Error(`The Feature instance "${observableName}" tried to update the Feature instance "${thisName}", but there is no relationship between the features.`);
        }
    }

    /**
     * - Update this ObserverInstance (i.e. "this") based on the property of the ObservableInterface instance (i.e. "observable") that has just
     *   changed and perform other actions as needed
     *  - E.g. update this line's "to" and/or "from" property to match the "name" property of the node that was just changed
     * @param {Object} observable - the observable that this observer is observing
     * @param {string} propertyKey - the property key of the property that has been created/changed/deleted in the observable
     * @param {(string|Object)} oldPropertyValue - the previous value of the property that has been created/changed/deleted in the observable
     * @param {string} namespace - the namespace of the property that has been created/changed/deleted in the observable
     * @returns {undefined}
     */
    handleUpdatedProperty(observable, propertyKey, oldPropertyValue, namespace='treeProps') {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (typeof propertyKey !== 'string') {
            throw TypeError('The "propertyKey" argument must be a string.');
        }
        if (typeof namespace !== 'string') {
            throw TypeError('The "namespace" argument must be a string.');
        }
        if (propertyKey === 'name') {
            ['from', 'to', 'parent'].forEach(k => {
                if (this.hasProperty(k) && this.getProperty(k) === oldPropertyValue) {
                    this.setProperty(k, observable.getProperty('name'));
                }
            });
        }
    }

    // ********************
    // ** Public methods **
    // ********************

    /**
     * @returns {boolean} whether this ObservableInterface instance (i.e. a node) is a child of another node or line
     */
    isChild() {
        // - regcontrol objects used to NOT be configuration objects, but then David made them into configuration objects again. They have a "parent"
        //   property, so they are child nodes, but they still shouldn't be displayed
        return this.hasProperty('parent') && !this.isConfigurationObject();
    }

    /**
     * @returns {boolean} whether this ObservableInterface instance is a component feature, which is a non-displayed ObservableInterface instance that
     * is used to create displayed ObservableInterface instances. Non-configuration-object components DO have real coordinates.
     */
    isComponentFeature() {
        return this.hasProperty('treeKey', 'meta') && this.getProperty('treeKey', 'meta').startsWith('component:');
    }

    /**
     * @returns {boolean} whether this ObservableInterface instance is displayed in the map visualization
     */
    isConfigurationObject() {
        return !this.hasCoordinates();
    }

    // - Deprecated because I should never be able to feed a GeometryCollection to the constructor anyway
    //isGeometryCollection() {
    //    return this.#feature.type === 'GeometryCollection' && !this.isConfigurationObject();
    //}

    /**
     * @returns {boolean} whether this ObservableInterface instance is a line
     */
    isLine() {
        return this.#feature.geometry.type === 'LineString' && !this.isConfigurationObject();
    }

    /**
     * - Deprecated because I don't insert modal features into the FeatureGraph anymore, but don't delete
     * @returns {boolean} whether this ObservableInterface instance is a modal feature, which is a non-displayed ObservableInterface instance that is
     * used to create a modal.
     */
    //isModalFeature() {
    //    return this.getProperty('treeKey', 'meta').startsWith('modal');
    //}

    isMultiLineString() {
        return this.#feature.geometry.type === 'MultiLineString' && !this.isConfigurationObject();
    }

    isMultiPoint() {
        return this.#feature.geometry.type === 'MultiPoint' && !this.isConfigurationObject();
    }

    isMultiPolygon() {
        return this.#feature.geometry.type === 'MultiPolygon' && !this.isConfigurationObject();
    }

    /**
     * @returns {boolean} whether this ObservableInterface instance is a node
     */
    isNode() {
        return this.#feature.geometry.type === 'Point' && !this.isConfigurationObject();
    }

    /**
     * @returns {boolean} whether this ObservableInterface instance is a parent-child line
     */
    isParentChildLine() {
        return this.hasProperty('treeKey', 'meta') && this.getProperty('treeKey', 'meta').startsWith('parentChild:');
    }

    isPolygon() {
        return this.#feature.geometry.type === 'Polygon' && !this.isConfigurationObject();
    }
}

class UnsupportedOperationError extends Error {

    constructor() {
        super();
        this.message = `An interface defines this method, but the method is not implemented in this class.`;
        this.name = 'UnsupportedOperationError';
    }
}

class ObserverError extends Error {
    
    constructor() {
        super();
        this.message = `This type of ObserverInterface instance is not allowed to observe this ObservableInterface instance`;
        this.name = 'ObserverError';
    }
}
</script>
<script>
"use strict";

const ClusterControlClass = L.Control.extend({
    options: {
        position: 'topleft' // - Position the control in the top left corner by default
    },
    /**
     * @param {FeatureController} controller - a ControllerInterface instance 
     * @param {Object} options - a plain JavaScript object containing L.Control option values that should override the default values
     * @returns {undefined}
     */
    initialize: function(controller, options=null) {
        if (!(controller instanceof FeatureController)) {
            throw TypeError('The "controller" argument must be instanceof FeatureController.');
        } 
        this._controller = controller;
        this._on = false;
        // - Create div
        this._div = L.DomUtil.create('div', 'leaflet-bar');
        this._div.classList.add('leaflet-customControlDiv');
        L.DomEvent.disableClickPropagation(this._div);
        this._div.appendChild(this._getExpandSvg());
        // - Add a tooltip
        this._div.title = '- The node grouping tool allows you to group nodes into a cluster\n- Click this button to enable\n- Click this button to disable'
        // - Attach listeners
        this._div.addEventListener('click', () => {
            // - Clustering was enabled, so disable it
            if (this._on) {
                this._div.style.removeProperty('border');
                this._div.replaceChildren(this._getExpandSvg());
                for (const node of LeafletLayer.nodeClusterLayers.getLayers()) {
                    LeafletLayer.nodeLayers.addLayer(node);
                }
                LeafletLayer.nodeClusterLayers.clearLayers();
                this._on = false;
            // - Clustering was disabled, so enable it
            } else {
                this._div.style.border = '2px solid #7FFF00';
                this._div.replaceChildren(this._getCompressSvg());
                for (const node of LeafletLayer.nodeLayers.getLayers()) {
                    LeafletLayer.nodeClusterLayers.addLayer(node);
                }
                LeafletLayer.nodeLayers.clearLayers();
                this._on = true;
            }
            // - Force redraw
            for (const layer of [LeafletLayer.nodeLayers, LeafletLayer.nodeClusterLayers]) {
                LeafletLayer.map.removeLayer(layer);
                LeafletLayer.map.addLayer(layer);
            }
        });
        if (options !== null) {
            L.setOptions(this, options);
        }
    },
    onAdd(map) {
        return this._div; 
    },
    onRemove(map) {

    },
    _getExpandSvg() {
        const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
        svg.setAttribute('width', '32px');
        svg.setAttribute('height', '32px');
        svg.setAttribute('viewBox', '0 0 24 24'); 
        svg.setAttribute('fill', 'none');
        let path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M9 9L5 5M5 5L5 9M5 5L9 5');
        path.setAttribute('stroke', '#000000');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        svg.appendChild(path);
        path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M15 9L19 5M19 5L15 5M19 5L19 9');
        path.setAttribute('stroke', '#000000');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        svg.appendChild(path);
        path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M9 15L5 19M5 19L9 19M5 19L5 15');
        path.setAttribute('stroke', '#000000');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        svg.appendChild(path);
        path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M15 15L19 19M19 19L19 15M19 19L15 19');
        path.setAttribute('stroke', '#000000');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        svg.appendChild(path);
        return svg;
    },
    _getCompressSvg() {
        const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
        svg.setAttribute('width', '32px');
        svg.setAttribute('height', '32px');
        svg.setAttribute('viewBox', '0 0 24 24'); 
        svg.setAttribute('fill', 'none');
        let path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M5 5L9 9M9 9V5M9 9H5');
        path.setAttribute('stroke', '#000000');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        svg.appendChild(path);
        path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M19 5L15 9M15 9L19 9M15 9L15 5');
        path.setAttribute('stroke', '#000000');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        svg.appendChild(path);
        path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M5 19L9 15M9 15L5 15M9 15L9 19');
        path.setAttribute('stroke', '#000000');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        svg.appendChild(path);
        path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M19 19L15 15M15 15L15 19M15 15L19 15');
        path.setAttribute('stroke', '#000000');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        svg.appendChild(path);
        return svg;
    }
});
</script>
<script>
"use strict";

class FeatureEditModal { // implements ObserverInterface, ModalInterface
    #controller;    // - ControllerInterface instance
    #modal;         // - A single Modal instance
    #observables;   // - An array of ObservableInterface instances
    #removed;       // - Whether this FeatureEditModal instance has already been deleted
    static #nonDeletableProperties = ['name', 'object', 'from', 'to', 'parent', 'latitude', 'longitude', 'treeKey', 'CMD_command'];

    /**
     * @param {Array} observables - an array of ObservableInterface instances
     * @param {FeatureController} controller - a ControllerInterface instance
     * @returns {undefined}
     */
    constructor(observables, controller) {
        if (!(observables instanceof Array)) {
            throw TypeError('"observables" argumnet must be an Array.');
        }
        if (!(controller instanceof FeatureController)) {
            throw Error('"controller" argument must be instanceof FeatureController');
        }
        this.#controller = controller;
        this.#modal = null;
        this.#observables = observables;
        this.#observables.forEach(ob => ob.registerObserver(this));
        this.#removed = false;
        this.renderContent();
    }

    // *******************************
    // ** ObserverInterface methods ** 
    // *******************************

    /**
     * - Remove this ObserverInterface instance (i.e. "this") from the ObservableInterface instance (i.e. "observable") that has been deleted, and
     *   perform other actions as needed
     * @param {Feature} observable - an ObservableInterface instance
     * @returns {undefined}
     */
    handleDeletedObservable(observable) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('"observable" argument must be instanceof Feature.');
        }
        if (!this.#removed) {
            observable.removeObserver(this);
            const index = this.#observables.indexOf(observable);
            if (index > -1) {
                this.#observables.splice(index, 1);
            } else {
                throw Error('The observable was not found in this.#observables.');
            }
            if (this.#observables.length === 0) {
                this.remove();
            } else {
                this.refreshContent();
            }
        }
    }

    /**
     *
     */
    handleNewObservable(observable) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        throw new UnsupportedOperationError();
    }

    /**
     * - Update this ObserverInterface instance (i.e. "this") based on the coordinates of the ObservableInterface instance (i.e. "observable") that
     *   have just changed and perform other actions as needed
     * @param {Feature} observable - an ObservableInterface instance
     * @param {Array} oldCoordinates - the old coordinates of the observable prior to the change in coordinates
     * @returns {undefined}
     */
    handleUpdatedCoordinates(observable, oldCoordinates) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('"observable" argument must be instanceof Feature.');
        }
        if (!(oldCoordinates instanceof Array)) {
            throw TypeError('"oldCoordinates" argument must be an array.');
        }
        this.refreshContent();
    }

    /**
     * - Update this ObserverInstance (i.e. "this") based on the property of the ObservableInterface instance (i.e. "observable") that has just
     *   changed and perform other actions as needed
     * @param {Feature} observable - an ObservableInterface instance
     * @param {string} propertyKey - the property key of the property that has been created/changed/deleted in the observable
     * @param {(string|Object)} oldPropertyValue - the previous value of the property that has been created/changed/deleted in the observable
     * @param {string} namespace - the namespace of the property that has been created/changed/deleted in the observable
     * @returns {undefined}
     */
    handleUpdatedProperty(observable, propertyKey, oldPropertyValue, namespace='treeProps') {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('"observable" argument must be instanceof Feature.');
        }
        if (typeof propertyKey !== 'string') {
            throw TypeError('"propertyKey" argument must be a string.');
        }
        if (typeof namespace !== 'string') {
            throw TypeError('"namespace" argument must be a string.');
        }
        this.refreshContent();
    }

    // ****************************
    // ** ModalInterface methods **
    // ****************************

    getDOMElement() {
        return this.#modal.divElement;
    }

    /**
     * @returns {boolean}
     */
    isRemoved() {
        return this.#removed;
    }

    /**
     * - Refresh aspects of the modal so that I don't have to re-render the whole thing
     * @returns {undefined}
     */
    refreshContent() {
        const tableState = {};
        // - Don't grab a row that was added with the "+" button, if it exists
        [...this.#modal.divElement.getElementsByTagName('tr')].filter(tr => tr.querySelector('span[data-property-key]') !== null).forEach(tr => {
            const span = tr.getElementsByTagName('span')[0];
            let namespace = span.dataset.propertyNamespace;
            // - latitude and longitude don't exist in any property namespace
            if (namespace === undefined) {
                namespace = null;
            }
            tableState[span.dataset.propertyKey] = {
                propertyNamespace: namespace,
                propertyTableRow: tr,
                // - This is either an input or a span
                propertyValueElement: tr.children[2].children[0].children[0]
            }
        });
        const tableKeys = Object.keys(tableState);
        const observablesState = this.#getKeyToValuesMapping();
        for (const [key, ary] of Object.entries(observablesState.meta)) {
            const valueElement = tableState[key].propertyValueElement;
            if (valueElement instanceof HTMLSpanElement) {
                valueElement.textContent = ary.join(',');
            } else {
                // - Only the treeKey should be in the meta namespace and the treeKey only ever displays with a span
                throw Error()
            }
        }
        for (const [key, ary] of Object.entries(observablesState.treeProps)) {
            // - First, compare the observables' state to the table state. If the observables' state has a property that is not in the table state,
            //   add a row to the table
            if (!tableKeys.includes(key)) {
                // - Don't let unintended properties show up when a FeatureEditModal refreshes due to a marker being dragged
                if (['from', 'to'].includes(key)) {
                    if (!this.#observables.every(ob => ob.isLine() && !ob.isParentChildLine())) {
                        continue;
                    }
                }
                if (key === 'type' && !this.#observables.every(ob => ob.isParentChildLine())) {
                    continue;
                }
                if (key === 'parent' && !this.#observables.every(ob => ob.isChild())) {
                    continue;
                }
                const keySpan = document.createElement('span');
                keySpan.textContent = key;
                keySpan.dataset.propertyKey = key;
                keySpan.dataset.propertyNamespace = 'treeProps';
                this.#modal.insertTBodyRow([this.#getDeletePropertyButton(key), keySpan, this.#getValueTextInput(key, ary)], 'beforeEnd');
            } else {
                // - If the table has the key, update the display of the values for that key
                const valueElement = tableState[key].propertyValueElement;
                if (valueElement instanceof HTMLInputElement) {
                    valueElement.replaceWith(this.#getValueTextInput(key, ary));
                } else if (valueElement instanceof HTMLSpanElement) {
                    valueElement.textContent = ary.join(', ');
                }
            }
        }
        for (const [key, ary] of Object.entries(observablesState.coordinates)) {
            // - Don't add latitude or longitude rows to tables that didn't already have those rows, just update the existing inputs
            if (tableKeys.includes(key)) {
                const valueElement = tableState[key].propertyValueElement;
                if (valueElement instanceof HTMLInputElement) {
                    valueElement.replaceWith(this.#getValueTextInput(key, ary));
                }
            }
        }
        // - Now compare the table's state to the observables' state. If the table's state has a property that is not in the observables' state,
        //   remove the row from the table
        const observablesKeysFromAllNamespaces = [];
        for (const obj of Object.values(observablesState)) {
            observablesKeysFromAllNamespaces.push(...Object.keys(obj))
        }
        for (const [key, obj] of Object.entries(tableState)) {
            if (!observablesKeysFromAllNamespaces.includes(key)) {
                obj.propertyTableRow.remove();
            }
        }
    }

    /**
     * @returns {undefined}
     */
    remove() {
        if (!this.#removed) {
            this.#observables.forEach(ob => ob.removeObserver(this));
            this.#observables = null;
            this.#modal.divElement.remove();
            this.#removed = true;
        }
    }

    /**
     * - Render the modal for the first time
     * @returns {undefined}
     */
    renderContent() {
        const modal = new Modal();
        modal.addStyleClasses(['featureEditModal'], 'divElement');
        const keyToValues = this.#getKeyToValuesMapping();
        for (const [key, ary] of Object.entries(keyToValues.meta)) {
            const keySpan = document.createElement('span');
            keySpan.textContent = 'ID';
            keySpan.dataset.propertyKey = 'treeKey';
            keySpan.dataset.propertyNamespace = 'meta';
            if (ary.length === 1) {
                modal.insertTHeadRow([null, keySpan, ary[0].toString()], 'prepend');
            } else {
                modal.insertTHeadRow([null, keySpan, ary.join(',')], 'prepend');
            }
        }
        for (const [key, ary] of Object.entries(keyToValues.treeProps)) {
            const keySpan = document.createElement('span');
            if (['object'].includes(key)) {
                keySpan.textContent = key;
                keySpan.dataset.propertyKey = key;
                keySpan.dataset.propertyNamespace = 'treeProps';
                if (ary.length === 1) {
                    modal.insertTHeadRow([null, keySpan, ary[0].toString()])
                } else {
                    //modal.insertTHeadRow([null, keySpan, `<Multiple "${key}" values>`]);
                    modal.insertTHeadRow([null, keySpan, ary.join(', ')]);
                }
                continue;
            }
            if (['from', 'to'].includes(key)) {
                if (!this.#observables.every(ob => ob.isLine() && !ob.isParentChildLine())) {
                    continue;
                }
            }
            if (key === 'type' && !this.#observables.every(ob => ob.isParentChildLine())) {
                continue;
            }
            if (key === 'parent' && !this.#observables.every(ob => ob.isChild())) {
                continue;
            }
            keySpan.textContent = key;
            keySpan.dataset.propertyKey = key;
            keySpan.dataset.propertyNamespace = 'treeProps';
            let deleteButton = null;
            if (!FeatureEditModal.#nonDeletableProperties.includes(key)) {
                deleteButton = this.#getDeletePropertyButton(key);
            }
            modal.insertTBodyRow([deleteButton, keySpan, this.#getValueTextInput(key, ary)]);
        }
        // - We don't allow the coordinates of multiple objects to be changed with multiselect
        if (this.#observables.length === 1) {
            for (const [key, ary] of Object.entries(keyToValues.coordinates)) {
                const keySpan = document.createElement('span');
                if (['latitude', 'longitude'].includes(key)) {
                    if (!this.#observables.every(ob => ob.isNode() && !ob.isConfigurationObject())) {
                        continue;
                    } else {
                        keySpan.textContent = key;
                        keySpan.dataset.propertyKey = key;
                        // - longitude and latitude aren't in any property namespace
                        modal.insertTBodyRow([null, keySpan, this.#getValueTextInput(key, ary)], 'prepend');
                    }
                }
            }
        }
        modal.insertTBodyRow([this.#getAddPropertyButton(), null, null], 'append', ['absolute']);
        modal.addStyleClasses(['centeredTable'], 'tableElement');
        // - Add buttons for regular features
        if (this.#observables.every(ob => !ob.isComponentFeature())) {
            modal.insertElement(this.#getDeleteFeatureDiv());
            if (this.#observables.every(ob => !ob.isConfigurationObject())) {
                modal.insertElement(this.#getZoomDiv(), 'prepend');
            }
        // - Add buttons for components
        } else {
            if (this.#observables.every(ob => ob.isConfigurationObject())) {
                modal.insertElement(this.#getAddConfigurationObjectDiv());
            } else if (this.#observables.some(ob => ob.isConfigurationObject())) {
                // - Don't add buttons. Configuration objects cannot be added because not every observable is a configuration object.
                //   Non-configuration objects cannot be added because there is at least one configuration object. The user should refine their search
                //   results, but mixing configuration and non-configuration objects isn't necessarily an error
            } else {
                if (this.#observables.every(ob => ob.isNode())) {
                    modal.insertElement(this.#getAddNodeWithCoordinatesDiv());
                    modal.insertElement(this.#getAddNodeWithMapClickDiv());
                } else if (this.#observables.every(ob => ob.isLine())) {
                    modal.insertElement(this.#getAddLineWithFromToDiv());
                } else {
                    // - Don't add buttons. The user's search returned both nodes and lines
                }
            }
        }
        modal.addStyleClasses(['verticalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'containerElement');
        if (this.#modal === null) {
            this.#modal = modal;
        } 
        if (document.body.contains(this.#modal.divElement)) {
            this.#modal.divElement.replaceWith(modal.divElement);
            this.#modal = modal;
        }
    }

    // *********************
    // ** Private methods ** 
    // *********************

    /**
     * @returns {boolean}
     */
    #componentsStateIsValid() {
        for (const ob of this.#observables) {
            for (const [k, v] of Object.entries(ob.getProperties('treeProps'))) { 
                if (!this.#valueTextInputIsValid(k, v)) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * - Add a configuration object to the data. Components arrive with bad data. That's why I have to validate a component twice: once during any
     *   value input changes and once when the button is clicked. I assume that regular features arrive with valid data. That's why I only validate
     *   when an input changes
     * @returns {HTMLDivElement}
     */
    #getAddConfigurationObjectDiv() {
        const btn = this.#getWideButton();
        btn.classList.add('add');
        btn.appendChild(getCirclePlusSvg());
        const span = document.createElement('span');
        span.textContent = 'Add config object';
        btn.appendChild(span);
        btn.addEventListener('click', () => {
            if (this.#componentsStateIsValid()) {
                this.#controller.addObservables(this.#observables.map(ob => this.#getObservableFromComponent(ob)));
            }
        });
        const div = this.#getWideButtonDiv();
        div.appendChild(btn);
        return div;
    }

    /**
     * - Add a line to the map by inputing "from" and "to" values and then clicking this button
     * @returns {HTMLDivElement}
     */
    #getAddLineWithFromToDiv() {
        const btn = this.#getWideButton();
        btn.classList.add('add');
        btn.appendChild(getCirclePlusSvg());
        const span = document.createElement('span');
        span.textContent = 'Add line with from/to';
        btn.appendChild(span);
        btn.addEventListener('click', () => {
            if (this.#componentsStateIsValid()) {
                this.#controller.addObservables(this.#observables.map(ob => this.#getObservableFromComponent(ob)));
            }
        });
        const div = this.#getWideButtonDiv();
        div.appendChild(btn);
        return div;
    }

    /**
     * - Add a node to the map by inputing coordinates and then clicking this button
     * @returns {HTMLDivElement}
     */
    #getAddNodeWithCoordinatesDiv() {
        const btn = this.#getWideButton();
        btn.classList.add('add');
        btn.appendChild(getCirclePlusSvg());
        const span = document.createElement('span');
        span.textContent = 'Add with coordinates';
        btn.appendChild(span);
        btn.addEventListener('click', () => {
            if (this.#componentsStateIsValid()) {
                this.#controller.addObservables(this.#observables.map(ob => this.#getObservableFromComponent(ob)));
            }
        });
        const div = this.#getWideButtonDiv();
        div.appendChild(btn);
        return div;
    }

    /**
     * - Add a node to the map by clicking on the map
     * @returns {HTMLDivElement}
     */
    #getAddNodeWithMapClickDiv() {
        const btn = this.#getWideButton();
        btn.classList.add('add');
        btn.appendChild(getCirclePlusSvg());
        const span = document.createElement('span');
        span.textContent = 'Add with map click';
        btn.appendChild(span);
        const that = this;
        btn.addEventListener('click', () => {
            const mapDiv = document.getElementById('map');
            mapDiv.style.cursor = 'crosshair';
            LeafletLayer.map.on('click', function(e) {
                LeafletLayer.map.off('click');
                mapDiv.style.removeProperty('cursor');
                if (that.#componentsStateIsValid()) {
                    that.#controller.addObservables(that.#observables.map(ob => that.#getObservableFromComponent(ob, [e.latlng.lat, e.latlng.lng])));
                }
            });
        });
        const div = this.#getWideButtonDiv();
        div.appendChild(btn);
        return div;
    }
    
    /**
     * @returns {HTMLButtonElement}
     */
    #getAddPropertyButton() {
        const btn = document.createElement('button');
        btn.classList.add('add');
        btn.classList.add('horizontalFlex');
        btn.classList.add('centerMainAxisFlex');
        btn.classList.add('centerCrossAxisFlex');
        btn.appendChild(getCirclePlusSvg());
        const that = this;
        btn.addEventListener('click', function() {
            const deletePlaceholder = document.createElement('span');
            const keyInputPlaceholder = document.createElement('span');
            const valueInputPlaceholder = document.createElement('span');
            that.#modal.insertTBodyRow([deletePlaceholder, keyInputPlaceholder, valueInputPlaceholder], 'beforeEnd');
            that.#insertKeyTextInput(deletePlaceholder, keyInputPlaceholder, valueInputPlaceholder);
        });
        return btn;
    }

    /**
     * @returns {HTMLDivElement}
     */
    #getDeleteFeatureDiv() {
        const btn = this.#getWideButton();
        btn.classList.add('delete');
        btn.appendChild(getTrashCanSvg());
        const span = document.createElement('span');
        span.textContent = 'Delete';
        btn.appendChild(span);
        btn.addEventListener('click', () => {
            this.#controller.deleteObservables(this.#observables);    
        });
        const div = this.#getWideButtonDiv();
        div.appendChild(btn);
        return div;
    }
    
    /**
     * @param {string} propertyKey
     * @returns {HTMLButtonElement} a button that can be clicked on to remove a property from an ObservableInterface instance
     */
    #getDeletePropertyButton(propertyKey) {
        if (typeof propertyKey !== 'string') {
            throw TypeError('"propertyKey" argument must be a string.');
        }
        const btn = document.createElement('button');
        btn.classList.add('delete');
        btn.classList.add('horizontalFlex');
        btn.classList.add('centerMainAxisFlex');
        btn.classList.add('centerCrossAxisFlex');
        btn.appendChild(getTrashCanSvg());
        const that = this;
        btn.addEventListener('click', function(e) {
            that.#controller.deleteProperty(that.#observables, propertyKey);
            // - This is code is required for a transitionalDeleteButton to remove the row
            let parentElement = this.parentElement;
            while (!(parentElement instanceof HTMLTableRowElement)) {
                parentElement = parentElement.parentElement;
            }
            parentElement.remove();
            e.stopPropagation();
        });
        return btn;
    }

    /**
     * - Iterate through all of the observables and map each property key to all unique values for that (treeProps) property key across all of the
     *   observables. Also includes treeKey, longitude, and latitude values
     * @returns {Object}
     */
    #getKeyToValuesMapping() {
        const keyToValues = {
            meta: {},
            treeProps: {},
            coordinates: {}
        };
        this.#observables.forEach(ob => {
            const treeKey = ob.getProperty('treeKey', 'meta');
            if (!keyToValues.meta.hasOwnProperty('treeKey')) {
                keyToValues.meta.treeKey = [treeKey];
            } else if (!keyToValues.meta.treeKey.includes(treeKey)) {
                keyToValues.meta.treeKey.push(treeKey);
            }
            if (ob.hasProperty('treeProps', 'meta')) {
                for (const [k, v] of Object.entries(ob.getProperties('treeProps'))) {
                    if (!keyToValues.treeProps.hasOwnProperty(k)) {
                        keyToValues.treeProps[k] = [v];
                    } else if (!keyToValues.treeProps[k].includes(v)) {
                        keyToValues.treeProps[k].push(v);
                    }
                }
            }
            let coordinatesArray = [];
            if (ob.isNode()) {
                const [lon, lat] = ob.getCoordinates();
                coordinatesArray = [['longitude', +lon], ['latitude', +lat]];
            }
            if (ob.isLine()) {
                const [[lon_1, lat_1], [lon_2, lat_2]] = ob.getCoordinates();
                coordinatesArray = [['longitude', +lon_1], ['latitude', +lat_1], ['longitude', +lon_2], ['latitude', +lat_2]];
            }
            coordinatesArray.forEach(ary => {
                const k = ary[0];
                const v = ary[1];
                if (!keyToValues.coordinates.hasOwnProperty(k)) {
                    keyToValues.coordinates[k] = [v];
                } else if (!keyToValues.coordinates[k].includes(v)) {
                    keyToValues.coordinates[k].push(v);
                }
            });
        });
        return keyToValues;
    }

    /**
     * - TODO: move this into the controller? Wouldn't be so bad if I did. Actually I should because of mass add. But mass add should just be another
     *   button so this function can stay here.
     * @param {Feature} component - a component feature
     * @param {Array} [coordinates=null] - an array of coordinates in [<lat>, <lon>] format that the new feature should have instead of the
     *      coordinates that were in the component 
     * @returns {Feature} a feature that can be added to the graph
     */
    #getObservableFromComponent(component, coordinates=null) {
        if (!(component instanceof Feature)) {
            throw TypeError('"component" argument must be instanceof Feature.');
        }
        const geometry = {
            type: 'Point'
        };;
        const observable = new Feature({
            geometry: geometry,
            properties: {
                treeKey: component.getProperty('treeKey', 'meta'),
                treeProps: structuredClone(component.getProperties('treeProps'))
            },
            type: 'Feature'
        });
        // - Start with whatever coordinates were in the text inputs
        let featureCoordinates = structuredClone(component.getCoordinates());
        // - If coordinates were provided, use those instead
        if (coordinates !== null) {
            featureCoordinates = [coordinates[1], coordinates[0]];
        }
        // - If the component is a line, get the coordinates of its nodes
        if (component.isLine()) {
            geometry.type = 'LineString';
            const fromKey = this.#controller.observableGraph.getKeyForComponent(observable.getProperty('from'));
            const toKey = this.#controller.observableGraph.getKeyForComponent(observable.getProperty('to'));
            const { sourceLat, sourceLon, targetLat, targetLon } = this.#controller.observableGraph.getLineLatLon(fromKey, toKey);
            featureCoordinates = [[sourceLon, sourceLat], [targetLon, targetLat]];
        }
        geometry.coordinates = featureCoordinates;
        return observable;
    }

    /**
     * - Return a text input that can be viewed in a modal
     * @param {string} propertyKey
     * @param {Array} [propertyValues=null]
     * @returns {HTMLInputElement} a text input that can be edited on to change a property value in an ObservableInterface instance
     */
    #getValueTextInput(propertyKey, propertyValues=null) {
        if (typeof propertyKey !== 'string') {
            throw TypeError('"propertyKey" argument must be typeof string.');
        }
        if (!(propertyValues instanceof Array) && propertyValues !== null) {
            throw TypeError('"propertyValues" argument must be instanceof Array or null.');
        }
        const input = document.createElement('input');
        input.addEventListener('mousedown', (e) => {
            e.stopPropagation(e);
        });
        if (propertyValues === null) {
            //- Do nothing. A new property was just added so the value text input should be blank
        } else if (propertyValues.length === 1) {
            // - This works even if propertyValues = [""], which it can be sometimes
            input.value = propertyValues[0];
        } else {
            //input.value = `<Multiple "${propertyKey}" values>`;
            input.value = propertyValues.join(', ');
        }
        let originalValue = input.value;
        const that = this;
        input.addEventListener('change', function() {
            const inputValue = this.value.trim();
            if (that.#valueTextInputIsValid(propertyKey, inputValue)) {
                that.#observables.forEach(ob => {
                    if (['latitude', 'longitude'].includes(propertyKey)) {
                        if (ob.isNode()) {
                            const [lon, lat] = ob.getCoordinates();
                            if (propertyKey === 'latitude') {
                                that.#controller.setCoordinates([ob], [lon, inputValue]);
                            } else {
                                that.#controller.setCoordinates([ob], [inputValue, lat]);
                            }
                        } else if (ob.isLine()) {
                            const [[lon, lat], [lon_1, lat_1]] = ob.getCoordinates(); 
                            if (propertyKey === 'latitude') {
                                that.#controller.setCoordinates([ob], [[lon, inputValue], [lon_1, inputValue]]);
                            } else {
                                that.#controller.setCoordinates([ob], [[inputValue, lat], [inputValue, lat_1]]);
                            }
                        }
                    } else if (['from', 'to', 'parent'].includes(propertyKey)) {
                        that.#controller.setProperty([ob], propertyKey, inputValue);
                    } else {
                        that.#controller.setProperty([ob], propertyKey, inputValue);
                    }
                });
                originalValue = inputValue;
            } else {
                this.value = originalValue;
            }
        });
        return input;
    }

    /**
     * @returns {HTMLButtonElement}
     */
    #getWideButton() {
        const btn = document.createElement('button');
        btn.classList.add('horizontalFlex');
        btn.classList.add('centerMainAxisFlex');
        btn.classList.add('centerCrossAxisFlex');
        btn.classList.add('fullWidth');
        return btn;
    }

    /**
     * @returns {HTMLDivElement}
     */
    #getWideButtonDiv() {
        const div = document.createElement('div');
        div.classList.add('horizontalFlex');
        div.classList.add('centerMainAxisFlex');
        div.classList.add('centerCrossAxisFlex');
        div.classList.add('halfWidth');
        return div;
    }
    
    /**
     * @returns {HTMLDivElement}
     */
    #getZoomDiv() {
        const btn = this.#getWideButton();
        btn.appendChild(getPinSvg());
        const span = document.createElement('span');
        span.textContent = 'Zoom';
        btn.appendChild(span);
        btn.addEventListener('click', zoom.bind(null, this.#observables));
        const div = this.#getWideButtonDiv();
        div.appendChild(btn);
        return div;
    }

    /**
     * @param {Node} deletePlaceholder - a document node that will be replaced by a "delete property" button
     * @param {Node} keyInputPlaceholder - a document node that will be replaced by this key input
     * @param {Node} valueInputPlaceholder - a document node that will be replaced by a value input 
     * @returns {undefined}
     */
    #insertKeyTextInput(deletePlaceholder, keyInputPlaceholder, valueInputPlaceholder) {
        const input = document.createElement('input');
        keyInputPlaceholder.replaceWith(input);
        const transitionalDeleteButton = this.#getDeletePropertyButton('');
        deletePlaceholder.replaceWith(transitionalDeleteButton);
        const that = this;
        let originalValue = input.value;
        input.addEventListener('change', function () {
            const inputValue = this.value.trim();
            // - If the input value isn't valid, just don't create a text input for the value and don't update the feature's properties
            if (that.#keyTextInputIsValid(inputValue)) {
                let parentElement = this.parentElement;
                while (!(parentElement instanceof HTMLTableRowElement)) {
                    parentElement = parentElement.parentElement;
                }
                parentElement.remove();
                that.#controller.setProperty(that.#observables, inputValue, '', 'treeProps');
            } else {
                input.value = originalValue;
            }
        });
    }

    /**
     * @param {string} inputValue
     * @returns {boolean}
     */
    #keyTextInputIsValid(inputValue) {
        // - I am no longer always converting to lowercase because names are case-sensitive and therefore other properties should be too
        if (FeatureEditModal.#nonDeletableProperties.includes(inputValue)) {
            alert(`The following properties cannot be added to objects: ${FeatureEditModal.#nonDeletableProperties}.`);
            return false;
        } else if (inputValue === '') {
            return false;
        } else if (this.#observables.some(ob => ob.hasProperty(inputValue))) {
            if (this.#observables.length === 1) {
                alert(`The property "${inputValue}" could not be added because this object already has this property.`);
            } else {
                alert(`The property "${inputValue}" could not be added because one or more objects already has this property.`);
            }
            return false;
        }
        return true;
    }

    /**
     * @param {string} propertyKey
     * @param {string} inputValue
     * @returns {boolean}
     */
    #toFromParentObjectIsValid(propertyKey, inputValue) {
        let observableKey;
        try {
            if (this.#observables.every(ob => ob.isComponentFeature())) {
                observableKey = this.#controller.observableGraph.getKeyForComponent(inputValue);
            } else if (this.#observables.every(ob => !ob.isComponentFeature())) {
                observableKey = this.#controller.observableGraph.getKey(inputValue, this.#observables[0].getProperty('treeKey', 'meta'));
                // - This is commented out because it's fine if different objects in the search selection will return different keys. If there are
                //   different keys for the same name, the FeatureGraph should just return the correct key for each object. Actually it's not. What if a
                //   configuration object and a non-configuration object share a name? I could write logic that decides whether returning multiple keys is
                //   okay (e.g. do both keys point to non-configuration objects?) but that would be annoying. Just return false if there are multiple keys
                if (this.#observables.some(ob => this.#controller.observableGraph.getKey(inputValue, ob.getProperty('treeKey', 'meta')) !== observableKey)) {
                    alert(`The value of the "${propertyKey}" property cannot be set to "${inputValue}" because multiple objects have that value for their
                        "name" property. Either ensure that value for the "${propertyKey}" property is a unique name, or change the value of the
                        "name" property of other object(s) to ensure the name is unique.`);
                    return false;
                }
            } else {
                throw Error('Components and non-components should never be together in this.#observables');
            }
        } catch {
            alert(`No object has the value "${inputValue}" for the "name" property. Ensure that the value for the "${propertyKey}" property matches an existing name.`);
            return false;
        }
        if (observableKey.startsWith('parentChild:')) {
            alert(`The value "${inputValue}" is the name of a parent-child line. Parent-child line names cannot be used as a value for the "${propertyKey}" property.`);
            return false;
        }
        const observable = this.#controller.observableGraph.getObservable(observableKey);
        if (observable.isConfigurationObject()) {
            alert(`The value "${inputValue}" is the name of a configuration object. Configuration object names cannot be used as a value for the "${propertyKey}" property.`);
            return false;
        }
        // - Components are not in the graph, so the observable cannot be a component feature
        return true;
    } 

    /**
     * - Validate the just-inputed value for a value text input
     * @param {string} propertyKey
     * @param {string} inputValue
     * @returns {boolean} whether the propertyKey and value are valid from a domain perspective
     */
    #valueTextInputIsValid(propertyKey, inputValue) {
        if (typeof propertyKey !== 'string') {
            throw TypeError('"propertyKey" argument must be typeof string.');
        }
        if (typeof inputValue !== 'string') {
            throw TypeError('"inputValue" argument must be typeof string.');
        }
        // - I am no longer always converting to lowercase because names are case-sensitive and therefore other properties should be too
        switch (propertyKey) {
            case 'type':
                inputValue = inputValue.toLowerCase();
                if (inputValue === 'parentchild') {
                    alert('The "type" property may not have a value of "parentChild".');
                    return false;
                }
                return true;
            case 'treeKey':
                alert('The "treeKey" property cannot be changed.');
                return false;
            case 'name':
                if (this.#observables.length > 1) {
                    alert('The "name" property cannot be edited for multiple objects simultaneously.');
                    return false;
                } else {
                    if (inputValue.trim() === '') {
                        alert('The "name" property cannot be blank.');
                        return false;
                    }
                    if (this.#controller.observableGraph.getObservables(ob => ob.hasProperty('name') && ob.getProperty('name') === inputValue).length > 0) {
                        alert(`The "name" property must be unique for all objects. The name "${inputValue}" is already used by another object.`);
                        return false;
                    }
                }
                return true;
            case 'from':
            case 'to':
                // - Test. It works
                //[...this.#modal.divElement.getElementsByTagName('tr')].forEach(tr => {
                //    [...tr.getElementsByTagName('span')].forEach(span => {
                //        if (span.textContent === propertyKey) {
                //            tr.getElementsByTagName('input')[0].classList.add('invalid');
                //        }
                //    });
                //});
                // - Test
                if (!this.#observables.every(ob => ob.isLine())) {
                    alert(`The value of the "${propertyKey}" property cannot be edited for non-line objects. Ensure your search includes only line objects.`);
                    return false;
                }
                if (!this.#toFromParentObjectIsValid(propertyKey, inputValue)) {
                    return false;
                }
                if (propertyKey === 'from' && this.#observables.some(ob => ob.getProperty('to') === inputValue)) {
                    if (this.#observables.length === 1) {
                        alert(`This line already has the value "${inputValue}" for the property "to". Lines may not begin and end on the same object.`);
                    } else {
                        alert(`One or more objects already has the value "${inputValue}" for the property "to". Lines may not begin and end on the same object.`);
                    }
                    return false;
                }
                if (propertyKey === 'to' && this.#observables.some(ob => ob.getProperty('from') === inputValue)) {
                    if (this.#observables.length === 1) {
                        alert(`This line already has the value "${inputValue}" for the property "from". Lines may not begin and end on the same object.`);
                    } else {
                        alert(`One or more objects already has the value "${inputValue}" for the property "from". Lines may not begin and end on the same object.`);
                    }
                    return false;
                }
                return true;
            case 'parent':
                if (!this.#observables.every(ob => ob.isChild())) {
                    alert(`The value of the "${propertyKey}" property cannot be edited for non-child objects. Ensure your search includes only child objects.`);
                    return false;
                }
                return this.#toFromParentObjectIsValid(propertyKey, inputValue);
            case 'latitude':
            case 'longitude':
                if (this.#observables.some(ob => ob.isConfigurationObject())) {
                    if (this.#observables.length === 1) {
                        alert(`This object is a configuration object. The property "${propertyKey}" cannot be set for configuration objects because they aren't shown on the map.`);
                    } else {
                        alert(`One or more objects are configuration objects. The property "${propertyKey}" cannot be set for configuration objects because they aren't shown on the map.`);
                    }
                    return false;
                }
                if (inputValue === '' || isNaN(+inputValue)) {
                    alert(`The value "${inputValue}" is not a valid number. A value for the "${propertyKey}" property must be a valid number.`);
                    return false;
                }
                return true;
            default:
                return true;
        }
    }
}

function getCirclePlusSvg() {
    const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.setAttribute('width', '22px');
    svg.setAttribute('height', '22px');
    svg.setAttribute('viewBox', '0 0 24 24'); 
    svg.setAttribute('fill', 'none'); 
    let path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', 'M9 12H15');
    path.setAttribute('stroke', '#FFFFFF');
    path.setAttribute('stroke-width', '2');
    path.setAttribute('stroke-linecap', 'round');
    path.setAttribute('stroke-linejoin', 'round');
    svg.appendChild(path);
    path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', 'M12 9L12 15');
    path.setAttribute('stroke', '#FFFFFF');
    path.setAttribute('stroke-width', '2');
    path.setAttribute('stroke-linecap', 'round');
    path.setAttribute('stroke-linejoin', 'round');
    svg.appendChild(path);
    path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', 'M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z');
    path.setAttribute('stroke', '#FFFFFF');
    path.setAttribute('stroke-width', '2');
    svg.appendChild(path);
    return svg;
}

function getTrashCanSvg() {
    const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.setAttribute('width', '22px');
    svg.setAttribute('height', '22px');
    svg.setAttribute('viewBox', '0 0 24 24');
    svg.setAttribute('fill', 'none');
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', 'M10 10V16M14 10V16M4 6H20M15 6V5C15 3.89543 14.1046 3 13 3H11C9.89543 3 9 3.89543 9 5V6M18 6V14M18 18C18 19.1046 17.1046 20 16 20H8C6.89543 20 6 19.1046 6 18V13M6 9V6');
    path.setAttribute('stroke', '#FFFFFF');
    path.setAttribute('stroke-width', '1.5');
    path.setAttribute('stroke-width', '1.5');
    path.setAttribute('stroke-linecap', 'round');
    path.setAttribute('stroke-linejoin', 'round');
    svg.appendChild(path);
    return svg;
}

function getPinSvg() {
    const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.setAttribute('width', '22px');
    svg.setAttribute('height', '22px');
    svg.setAttribute('viewBox', '0 0 24 24'); 
    svg.setAttribute('fill', 'none'); 
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', '12');
    circle.setAttribute('cy', '10');
    circle.setAttribute('r', '3');
    circle.setAttribute('stroke', '#FFFFFF');
    circle.setAttribute('stroke-width', '1.5');
    circle.setAttribute('stroke-width', '1.5');
    circle.setAttribute('stroke-linecap', 'round');
    circle.setAttribute('stroke-linejoin', 'round');
    svg.appendChild(circle);
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', "M19 9.75C19 15.375 12 21 12 21C12 21 5 15.375 5 9.75C5 6.02208 8.13401 3 12 3C15.866 3 19 6.02208 19 9.75Z");
    path.setAttribute('stroke', '#FFFFFF');
    path.setAttribute('stroke-width', '1.5');
    path.setAttribute('stroke-width', '1.5');
    path.setAttribute('stroke-linecap', 'round');
    path.setAttribute('stroke-linejoin', 'round');
    svg.appendChild(path);
    return svg;
}

/**
 * - There's no need to create a function that returns a function if I use Function.prototype.bind() propertly
 * @param {Array} observables - an array of ObservableInterface instances
 * @returns {undefined}
 */
function zoom(observables) {
    if (!(observables instanceof Array)) {
        throw TypeError('"observables" argument must be instanceof Array.');
    }
    if (observables.length === 1) {
        const observable = observables[0];
        const layer = observable.getObservers().filter(ob => ob instanceof LeafletLayer)[0];
        const leafletLayer = Object.values(layer.getLayer()._layers)[0];
        if (observable.isNode()) {
            const [lon, lat] = structuredClone(observable.getCoordinates());
            // - The max zoom level without losing the map is 19
            LeafletLayer.map.flyTo([lat, lon], 19, {duration: .3});
            layer.bindPopup();
            if (!leafletLayer.isPopupOpen()) {
                leafletLayer.openPopup();
            }
        } else if (observable.isLine()) {
            const [[lon1, lat1], [lon2, lat2]] = observable.getCoordinates();
            LeafletLayer.map.flyTo([(lat1 + lat2) / 2, (lon1 + lon2) / 2], 19, {duration: .3});
            if (!leafletLayer.isPopupOpen()) {
                leafletLayer.openPopup();
            }
        } else {
            throw Error('Zoom button is only supported for nodes and lines.');
            //let coordinates;
            //if (observable.isPolygon()) {
            //    coordinates = observable.getCoordinates().flat(1);
            //} else if (observable.isMultiPolygon()) {
            //    coordinates = observable.getCoordinates().flat(2);
            //} else {
            //    return;
            //}
            //const lons = [];
            //const lats = [];
            //coordinates.forEach(ary => { lons.push(ary[0]); lats.push(ary[1]); });
            //LeafletLayer.map.flyToBounds([
            //    [Math.min.apply(null, lats), Math.min.apply(null, lons)],
            //    [Math.max.apply(null, lats), Math.max.apply(null, lons)]],
            //    {duration: .3});
            //if (!leafletLayer.isPopupOpen()) {
            //    leafletLayer.openPopup();
            //}
        }
    } else {
        const lons = [];
        const lats = [];
        observables.forEach(ob => {
            if (ob.isNode()) {
                const [lon, lat] = ob.getCoordinates();
                lons.push(lon);
                lats.push(lat);
            } else if (ob.isLine()) {
                const [[lon1, lat1], [lon2, lat2]] = ob.getCoordinates();
                lons.push(...[lon1, lon2]);
                lats.push(...[lat1, lat2]);
            }
        });
        LeafletLayer.map.flyToBounds([
            [Math.min.apply(null, lats), Math.min.apply(null, lons)],
            [Math.max.apply(null, lats), Math.max.apply(null, lons)],
            19,
            {duration: .3}
        ]);
    }
}
</script>
<script>
"use strict";

class DropdownDiv {
    divElement;         // - The divElement is the outermost div that contains the DropdownDiv's button (if any) and content
    buttonElement;      // - The buttonElement is an optional button that can be clicked to expand and collapse the contentDivElement
    contentDivElement;  // - The contentDivElement is the div that expands and collapses as needed 
    
    /**
     * @returns {undefined}
     */
    constructor() {
        this.divElement = document.createElement('div');
        this.divElement.classList.add('js-div--dropdown');
        this.buttonElement = null;
        this.contentDivElement = null;
    }

    // ********************
    // ** Public methods **
    // ********************

    /**
     * @returns {boolean}
     */
    isExpanded() {
        return this.contentDivElement !== null && this.contentDivElement.classList.contains('expanded');
    }

   /**
    * @param {Node} e - an element to append to the content div
    * @param {string} [position='append'] - the location to insert the element row. Can be "prepend", "beforeEnd", or "append"
    * @returns {undefined}
    */
    insertElement(e, position='append') {
        if (!(e instanceof Node)) {
            throw Error('"e" argument must be instanceof Node');
        }
        if (this.contentDivElement === null) {
            this.#createContentDivElement();
        }
        if (position === 'prepend') {
            this.contentDivElement.prepend(e);
        } else if (position === 'beforeEnd') {
            const lastNodeIndex = this.contentDivElement.children.length - 1;
            const lastNode = this.contentDivElement.children.item(lastNodeIndex);
            this.contentDivElement.insertBefore(e, lastNode) 
        } else if (position === 'append') {
            this.contentDivElement.appendChild(e);
        } else {
            throw Error('Please specify a valid value for the "position" parameter: "prepend", "beforeEnd", or "append".')
        }
    }

    /**
     * @param {(string|Node)} button - the button to display
     * @param {boolean} showArrow - whether to append an arrow SVG to the button that rotates in response to clicks
     * @returns {undefined}
     */
    setButton(button, showArrow=false) {
        let svgWasRotated = false;
        if (this.buttonElement === null) {
            this.buttonElement = document.createElement('button');
            this.buttonElement.classList.add('js-button--dropdown');
            this.divElement.prepend(this.buttonElement);
            if (this.contentDivElement === null) {
                this.#createContentDivElement();
            }
            this.buttonElement.addEventListener('click', this.#getContentDivDisplayFunction());
        } else {
            const svg = this.buttonElement.lastChild;
            if (svg instanceof SVGElement) {
                if (svg.classList.contains('rotated')) {
                    svgWasRotated = true;
                }
            }
        }
        if (typeof button === 'string') {
            const span = document.createElement('span'); 
            span.textContent = button;
            this.buttonElement.replaceChildren(span);
        } else if (button instanceof Node) {
            this.buttonElement.replaceChildren(button);
        } else {
            throw TypeError('"button" argument must be a string or Node.');
        }
        if (showArrow) {
            const svg = document.createElementNS('http://www.w3.org/2000/svg','svg'); 
            svg.classList.add('js-svg--dropdown');    
            svg.setAttribute('width', '40px');
            svg.setAttribute('height', '40px');
            svg.setAttribute('viewBox', '0 0 10 10');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M4,2.5L6.5,5L4,7.5L3,6.5L4.5,5L3,3.5L4,2.5');
            svg.appendChild(path);
            if (svgWasRotated) {
                svg.classList.add('rotated');
            }
            this.buttonElement.appendChild(svg);
        }
    }

    /**
     * - Return a function that is intended to be attached to any other element to control the display of the entire DropdownDiv
     * @returns {function}
     */
    getDropdownDivShowHideFunction() {
        const that = this;
        return function() {
            that.divElement.classList.toggle('expanded');
        };
    }

    /**
     * @param {Array} styles
     * @param {string} elementName
     * @returns {undefined}
     */
    addStyleClasses(styles, elementName) {
        if (!(styles instanceof Array)) {
            throw Error('"styles" argument must be an array.');
        }
        if (typeof elementName !== 'string') {
            throw Error('The "elementName" argument must be a string');
        }
        switch (elementName) {
            case 'divElement':
                if (this.divElement !== null) {
                    this.divElement.classList.add(...styles);
                }
                break;
            case 'buttonElement':
                if (this.buttonElement !== null) {
                    this.buttonElement.classList.add(...styles);
                }
                break;
            case 'contentDivElement':
                if (this.contentDivElement !== null) {
                    this.contentDivElement.classList.add(...styles);
                }
                break;
            default:
                throw Error('"elementName" argument must be "divElement", "buttonElement", or "contentDivElement".');
        }
    }

    /**
     * @param {Array} styles
     * @param {string} elementName
     * @returns {undefined}
     */
    removeStyleClasses(styles, elementName) {
        if (!(styles instanceof Array)) {
            throw Error('"styles" argument must be an array.');
        }
        if (typeof elementName !== 'string') {
            throw Error('The "elementName" argument must be a string');
        }
        switch (elementName) {
            case 'divElement':
                if (this.divElement !== null) {
                    this.divElement.classList.remove(...styles);
                }
                break;
            case 'buttonElement':
                if (this.buttonElement !== null) {
                    this.buttonElement.classList.remove(...styles);
                }
                break;
            case 'contentDivElement':
                if (this.contentDivElement !== null) {
                    this.contentDivElement.classList.remove(...styles);
                }
                break;
            default:
                throw Error('"elementName" argument must be "divElement", "buttonElement", or "contentDivElement".');
        }
    }

    // *********************
    // ** Private methods ** 
    // *********************

    /**
     * - Return a function that is intended to be attached to the button in the DropdownDiv to control the display of the content div of the
     *   DropdownDiv
     * @returns {function}
     */
    #getContentDivDisplayFunction() {
        const that = this;
        return function() {
            // - I don't need to manage the content of this.contentDivElement because any additional event listeners added later should be managing
            //   the creation and removal of content in response to clicks
            that.contentDivElement.classList.toggle('expanded');
            that.buttonElement.classList.toggle('expanded');
            const svg = that.buttonElement.lastChild;
            if (svg instanceof SVGElement) {
                svg.classList.toggle('rotated');
            }
            if (!that.contentDivElement.classList.contains('expanded')) {
                for (const innerDiv of that.contentDivElement.getElementsByClassName('js-div--dropdown')) {
                    // - There is no button, just a content div
                    if (innerDiv.children[0] instanceof HTMLDivElement) {
                        // - I'm going to assume that if there is no button, then the creation of the content in the content div is being controlled
                        //   somewhere else, so I shouldn't clear the content div or do anything to it except visually collapse it
                        innerDiv.children[0].classList.remove('expanded');
                    } else if (innerDiv.children[0] instanceof HTMLButtonElement) {
                        // - If there is a button, then I should simulate a click on that button, but only if that button was open. If the button was
                        //   closed, don't click on it. Clicking on the button should take care of the svg if it exists
                        const contentDiv = innerDiv.children[1];
                        if (contentDiv.classList.contains('expanded')) {
                            innerDiv.children[0].click();
                        }
                    }
                }
            }
        }
    }

    #createContentDivElement() {
        this.contentDivElement = document.createElement('div');
        this.contentDivElement.classList.add('js-div--dropdownContent');
        this.divElement.appendChild(this.contentDivElement);
    }
}
</script>
<script>
"use strict";

class TopTab {
    divElement;         // Container for tabDivElement and contentDivElement;
    #contentDivElement; // Container for content. Contains other divs that contain content
    #tabDivElement;     // Container for tabs. Contains other divs that are tabs
    #tabMap;            // Mapping from tabs to content

    constructor() {
        this.divElement = document.createElement('div');
        this.divElement.classList.add('div--topTab');
        this.#tabDivElement = document.createElement('div');
        this.#tabDivElement.classList.add('div--topTabTabContainer');
        this.divElement.appendChild(this.#tabDivElement);
        this.#contentDivElement = document.createElement('div');
        this.#contentDivElement.classList.add('div--topTabContentContainer')
        this.divElement.appendChild(this.#contentDivElement);
        this.#tabMap = {};
    }

    /**
     * - Add a tab and some content
     * 
     * @param {(string|Node)} label - a string or node label a tab
     * @param {Node} content - A node (e.g. a div) that will be displayed when the tab is clicked on
     */
    addTab(label, content) {
        if (!(content instanceof Node)) {
            throw Error('"content" argument must be instanceof Node.');
        }
        if (this.#tabMap.hasOwnProperty(label)) {
            throw Error('The "label" argument must be unique across all tabs.');
        }
        const tab = document.createElement('div');
        const closeButton = document.createElement('button');
        closeButton.textContent = '×';
        closeButton.addEventListener('click', function() {
            document.getElementsByClassName('js-nav--sideNav')[0].classList.remove('open');
            document.getElementsByClassName('js-div--sideNavCover')[0].classList.remove('open');
            document.getElementsByClassName('js-article--sideNavArticle')[0].classList.remove('compressed');
        });
        //const that = this;
        //tab.addEventListener('click', function() {
        //    that.selectTab(this);
        //});
        tab.appendChild(closeButton);
        const span = document.createElement('span');
        if (typeof label === 'string') {
            span.textContent = label;
        } else {
            span.appendChild(label);
        }
        tab.appendChild(span);

        this.#tabDivElement.appendChild(tab);
        this.#contentDivElement.appendChild(content);
        this.#tabMap[label] = {
            tab: tab,   
            content: content
        };
    }

    getTab(label) {
        return this.#tabMap[label];
    }

    removeTab(label) {
        if (!this.#tabMap.hasOwnProperty(label)) {
            throw Error(`This TopTab does not have a tab with label ${label}`);
        }
        const {tab, content} = this.#tabMap[label];
        tab.remove();
        content.remove();
        delete this.#tabMap[label];
    }

    /**
     * - @param {HTMLDivElement} div - The <div></div> element that was clicked. The div element has the event listener instead of the inner span (or
     *   SVG) because the whole div should be clickable, especially if I choose not to visually round off my tabs. If the inner span (or SVG) is
     *   clicked, the event will bubble up to the div
     */
    selectTab(div) {
        if (!(div instanceof HTMLDivElement)) {
            throw TypeError('"div" argument must be instanceof HTMLDivElement.');
        }
        Object.values(this.#tabMap).forEach(obj => {
            if (obj.tab !== div) {
                obj.tab.classList.remove('selected');   
                obj.content.classList.remove('selected');
            } else if (!(obj.tab.classList.contains('selected'))) {
                obj.tab.classList.add('selected');
                obj.content.classList.add('selected');
            }
        }); 
    }

    // *********************
    // ** Private methods **
    // *********************
}
</script>
<script>
"use strict";

class SearchModal {
    #configDropdownDiv; // - A DropdownDiv instance
    #controller;        // - ControllerInterface instance for this SearchModal
    #keySelects;        // - An array of HTMLSelectElement instances
    #lineDropdownDiv;   // - A DropdownDiv instance
    #modal;             // - A single Modal instance for this SearchModal
    #nodeDropdownDiv;   // - A DropdownDiv instance
    #observables;       // - An array of ObservableInterface instances (i.e. components) or an array containing a FeatureGraph
    #removed;           // - Whether this SearchModal instance has already been deleted
    #searchResults;     // - An array of all of the ObservableInterface instances that matched the search. This is necessary to build additional functionality (e.g. coloring, etc.)
    static searchModal = null;
    static componentModal = null;

    /**
     * @param {FeatureController} controller - a ControllerInterface instance
     * @param {Array} [observables=null] - an array of ObservableInterface instances (i.e. components)
     * @returns {undefined}
     */
    constructor(controller, observables=null) {
        if (!(controller instanceof FeatureController)) {
            throw TypeError('The "controller" argument must be instanceof FeatureController.');
        }
        if (!(observables instanceof Array) && observables !== null) {
            throw TypeError('The "observables" argument must be an array or null.');
        }
        this.#configDropdownDiv = new DropdownDiv();
        this.#configDropdownDiv.addStyleClasses(['sideNav', 'searchCategory'], 'divElement');
        this.#controller = controller;
        this.#keySelects = [];
        this.#lineDropdownDiv = new DropdownDiv();
        this.#lineDropdownDiv.addStyleClasses(['sideNav', 'searchCategory'], 'divElement');
        this.#modal = null;
        this.#nodeDropdownDiv = new DropdownDiv();
        this.#nodeDropdownDiv.addStyleClasses(['sideNav', 'searchCategory'], 'divElement');
        if (observables === null) {
            this.#observables = [controller.observableGraph];
            this.#observables[0].registerObserver(this);
        } else {
            this.#observables = observables;
            this.#observables.forEach(ob => ob.registerObserver(this));
        }
        this.#removed = false;
        this.#searchResults = [];
        this.renderContent();
        this.#search();
        this.#attachDropdownDivEventHandlers();
    }

    // *******************************
    // ** ObserverInterface methods **
    // *******************************

    /**
     * - Remove this ObserverInterface instance (i.e. "this") from the ObservableInterface instance (i.e. "observable") that has been deleted, and
     *   perform other actions as needed
     * @param {Feature} observable - an ObservableInterface instance. While this SearchModal is an observer of the FeatureGraph, the FeatureGraph
     *      calls this function with a Feature argument
     * @returns {undefined}
     */
    handleDeletedObservable(observable) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('The "observable" argument must be instanceof Feature.');
        }
        this.#searchResults = this.#searchResults.filter(ob => ob !== observable);
        this.refreshContent();
        const {configs, nodes, lines} = this.#getCategorizedSearchResults();
        [
            [this.#configDropdownDiv, configs, 'Configuration objects'],
            [this.#nodeDropdownDiv, nodes, 'Nodes'],
            [this.#lineDropdownDiv, lines, 'Lines']
        ].forEach(ary => {
            ary[0].setButton(`${ary[2]}: ${ary[1].length}`, true);
        });
    }

    /**
     * @param {Feature} observable - an ObservableInterface instance. While this SearchModal is an observer of the FeatureGraph, the FeatureGraph
     *      calls this function with a Feature argument
     * @returns {undefined}
     */
    handleNewObservable(observable) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('The "observable" argument must be instanceof FeatureGraph.');
        }
        this.refreshContent();
    }

    /**
     * - Update this ObserverInterface instance (i.e. "this") based on the coordinates of the ObservableInterface instance (i.e. "observable") that
     *   have just changed and perform other actions as needed
     * @param {Feature} observable - an ObservableInterface instance
     * @param {Array} oldCoordinates - the old coordinates of the observable prior to the change in coordinates
     * @returns {undefined}
     */
    handleUpdatedCoordinates(observable, oldCoordinates) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature) && !(observable instanceof FeatureGraph)) {
            throw TypeError('The "observable" argument must be instanceof Feature or FeatureGraph.');
        }
        if (!(oldCoordinates instanceof Array)) {
            throw TypeError('The "oldCoordinates" argument must be an array.');
        }
        this.refreshContent();
    }

    /**
     * - Update this ObserverInstance (i.e. "this") based on the property of the ObservableInterface instance (i.e. "observable") that has just
     *   changed and perform other actions as needed
     * @param {Feature} observable - an ObservableInterface instance
     * @param {string} propertyKey - the property key of the property that has been created/changed/deleted in the observable
     * @param {(string|Object)} oldPropertyValue - the previous value of the property that has been created/changed/deleted in the observable
     * @param {string} namespace - the namespace of the property that has been created/changed/deleted in the observable
     * @returns {undefined}
     */
    handleUpdatedProperty(observable, propertyKey, oldPropertyValue, namespace='treeProps') {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        // - A SearchModal can either directly observer Features or a FeatureGraph. Since in both cases the SearchModal response is the same, this is
        //   a special case where the observable can be one of two classes
        if (!(observable instanceof Feature) && !(observable instanceof FeatureGraph)) {
            throw TypeError('The "observable" argument must be instanceof Feature or FeatureGraph.');
        }
        if (typeof propertyKey !== 'string') {
            throw TypeError('The "propertyKey" argument must be a string.');
        }
        if (typeof namespace !== 'string') {
            throw TypeError('The "namespace" argument must be a string.');
        }
        this.refreshContent();
    }

    // ****************************
    // ** ModalInterface methods **
    // ****************************

    /**
     * @returns {HTMLDivElement}
     */
    getDOMElement() {
        return this.#modal.divElement;
    }

    /**
     * @returns {boolean}
     */
    isRemoved() {
        return this.#removed;
    }

    /**
     * @returns {undefined}
     */
    refreshContent() {
        const keySelects = [...this.#keySelects];
        const that = this;
        keySelects.forEach(oldKeySelect => {
            const index = this.#keySelects.indexOf(oldKeySelect);
            if (index > -1) {
                this.#keySelects.splice(index, 1);
            }
            const newKeySelect = this.#getKeySelect(oldKeySelect);
            oldKeySelect.replaceWith(newKeySelect);
            that.#handleKeySelectChange(newKeySelect);
        });
    }

    /**
     * @returns {undefined}
     */
    remove() {
        if (!this.#removed) {
            this.#configDropdownDiv.divElement.remove();
            this.#configDropdownDiv = null;
            this.#controller = null;
            this.#keySelects = null;
            this.#lineDropdownDiv.divElement.remove();
            this.#lineDropdownDiv = null;
            this.#modal.divElement.remove(); 
            this.#modal = null;
            this.#nodeDropdownDiv.divElement.remove();
            this.#nodeDropdownDiv = null;
            this.#observables.forEach(ob => ob.removeObserver(this));
            this.#observables = null;
            this.#removed = true;
        }
    }
 
    /**
     * @returns {undefined}
     */
    renderContent() {
        const modal = new Modal();
        modal.addStyleClasses(['searchModal'], 'divElement');
        const keySelect = this.#getKeySelect();
        modal.insertTBodyRow([this.#getAddRowButton(), null, keySelect, this.#getOperatorSelect(), this.#getValueTextInput()], 'beforeEnd');
        this.#handleKeySelectChange(keySelect);
        modal.addStyleClasses(['centeredTable'], 'tableElement');
        modal.insertElement(this.#getSearchButton());
        modal.insertElement(this.#getResetButton());
        modal.addStyleClasses(['verticalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'containerElement');
        if (this.#modal === null) {
            this.#modal = modal;
        } 
        if (document.body.contains(this.#modal.divElement)) {
            this.#modal.divElement.replaceWith(modal.divElement);
            this.#modal = modal;
        }
    }

    // ********************
    // ** Public methods **
    // ********************

    /**
     * @returns {HTMLDivElement}
     */
    getConfigSearchResultsDiv() {
        return this.#configDropdownDiv.divElement;
    }

    /**
     * @returns {HTMLDivElement}
     */
    getLineSearchResultsDiv() {
        return this.#lineDropdownDiv.divElement;
    }

    /**
     * @returns {HTMLDivElement}
     */
    getNodeSearchResultsDiv() {
        return this.#nodeDropdownDiv.divElement;
    }
    
    // *********************
    // ** Private methods ** 
    // *********************

    /**
     * @param {DropdownDiv} dropdownDiv
     * @param {Array} observables
     * @returns {undefined}
     */
    #appendFeatureDropdownDivs(dropdownDiv, observables) {
        if (!(dropdownDiv instanceof DropdownDiv)) {
            throw TypeError('The "dropdown" argument must be instanceof DropdownDiv');
        }
        if (!(observables instanceof Array)) {
            throw TypeError('The "observables" argument must be an Array');
        }
        observables.forEach(ob => {
            const featureDropdownDiv = new FeatureDropdownDiv(ob, this.#controller);
            dropdownDiv.contentDivElement.appendChild(featureDropdownDiv.getDOMElement())
        });
    }

    /**
     * - The event handler must itself call this.#getCategorizedSearchResults() in order to get the current set of search results
     * @returns {undefined}
     */
    #attachDropdownDivEventHandlers() {
        [[this.#configDropdownDiv, 'Configuration objects'], [this.#nodeDropdownDiv, 'Nodes'], [this.#lineDropdownDiv, 'Lines']].forEach(ary => {
            ary[0].buttonElement.addEventListener('click', () => {
                if (ary[0].isExpanded() && ary[0].contentDivElement.children.length === 0) {
                    ary[0].setButton('Loading search results...', true);
                    setTimeout(() => {
                        const {configs, nodes, lines} = this.#getCategorizedSearchResults();
                        if (ary[1] === 'Configuration objects') {
                            this.#appendFeatureDropdownDivs(ary[0], configs);
                            ary[0].setButton(`${ary[1]}: ${configs.length}`, true);
                        } else if (ary[1] === 'Nodes') {
                            this.#appendFeatureDropdownDivs(ary[0], nodes);
                            ary[0].setButton(`${ary[1]}: ${nodes.length}`, true);
                        } else if (ary[1] === 'Lines') {
                            this.#appendFeatureDropdownDivs(ary[0], lines);
                            ary[0].setButton(`${ary[1]}: ${lines.length}`, true);
                        }
                    }, 1);
                }
            });
        });
    }

    /**
     * @returns {HTMLButtonElement}
     */
    #getAddRowButton() {
        const btn = document.createElement('button');
        btn.classList.add('add');
        btn.classList.add('horizontalFlex');
        btn.classList.add('centerMainAxisFlex');
        btn.classList.add('centerCrossAxisFlex');
        btn.appendChild(getCirclePlusSvg());
        const that = this;
        btn.addEventListener('click', function() {
            const keySelect = that.#getKeySelect();
            that.#modal.insertTBodyRow([that.#getDeleteRowButton(), that.#getAndOrSelect(), keySelect, that.#getOperatorSelect(), that.#getValueTextInput()], 'append');
            that.#handleKeySelectChange(keySelect);
        });
        return btn;
    }

    /**
     * @returns {HTMLSelectElement}
     */
    #getAndOrSelect() {
        const select = document.createElement('select');
        select.dataset.role = 'andOrSelect';
        ['and', 'or'].forEach(o => {
            const option = document.createElement('option');
            option.text = o;
            option.value = o;
            select.add(option);
        });
        const that = this;
        return select;
    }

    /**
     * @returns {Object}
     */
    #getCategorizedSearchResults() {
        const configs = [];
        const nodes = [];
        const lines = [];
        this.#searchResults.forEach(ob => {
            if (ob.isConfigurationObject()) {
                configs.push(ob);
            } else if (ob.isNode()) {
                nodes.push(ob);
            } else if (ob.isLine()) {
                lines.push(ob);
            } else {
                throw TypeError('"The observable was not a configuration object, node, or line.');
            }
        });
        return {
            'configs': configs,
            'nodes': nodes,
            'lines': lines
        }
    }
        

    /**
     * @returns {HTMLButtonElement}
     */
    #getDeleteRowButton() {
        const btn = document.createElement('button');
        btn.classList.add('delete');
        if (this.#observables[0] instanceof FeatureGraph) {
            btn.classList.add('searchModalDeleteButton');
        } else {
            btn.classList.add('componentModalDeleteButton');
        }
        btn.classList.add('horizontalFlex');
        btn.classList.add('centerMainAxisFlex');
        btn.classList.add('centerCrossAxisFlex');
        btn.appendChild(getTrashCanSvg());
        const that = this;
        btn.addEventListener('click', function(e) {
            let parentElement = this.parentElement;
            while (!(parentElement instanceof HTMLTableRowElement)) {
                parentElement = parentElement.parentElement;
            }
            for (const select of parentElement.getElementsByTagName('select')) {
                if (select.dataset.role = 'keySelect') {
                    that.#keySelects = that.#keySelects.filter(s => s !== select);
                }
            }
            parentElement.remove();
            e.stopPropagation();
        });
        return btn;
    }

    /**
     * @param {HTMLSelectElement} oldKeySelect - an old key select that should be used to set up the new key select
     * @returns {HTMLSelectElement}
     */
    #getKeySelect(oldKeySelect=null) {
        if (!(oldKeySelect instanceof HTMLSelectElement) && oldKeySelect !== null)  {
            throw TypeError('The "oldKeySelect" argument must be instanceof HTMLKeySelect or null.');
        }
        const keySelect = document.createElement('select');
        keySelect.dataset.role = 'keySelect';
        this.#keySelects.push(keySelect);
        const keys = [];
        const metaKeys = [];
        let observables;
        if (this.#observables[0] instanceof FeatureGraph) {
            observables = this.#observables[0].getObservables();
        } else {
            observables = this.#observables;
        }
        observables.forEach(f => {
            Object.keys(f.getProperties('meta')).forEach(k => {
                if (!['attachments', 'componentType', 'formProps', 'hiddenLinks', 'hiddenNodes', 'layoutVars', 'links', 'name2', 'nodes', 'owner', 'syntax',
                    'treeProps', 'urlProps'].includes(k) && !metaKeys.includes(k)) {
                    metaKeys.push(k);
                }
            });
            if (f.hasProperty('treeProps', 'meta')) {
                Object.keys(f.getProperties('treeProps')).forEach(k => {
                    if (![].includes(k) && !keys.includes(k)) {
                        keys.push(k);
                    }
                });
            }
        });
        // - Add fake key to search all fields
        const option = document.createElement('option');
        option.dataset.namespace = 'treeProps';
        option.text = '<All Fields>';
        option.value = 'searchModalSearchAllFields';
        keySelect.add(option);
        keySelect.addEventListener('change', this.#handleKeySelectChange.bind(this, keySelect));
        // - Add regular keys
        metaKeys.sort((a, b) => a.localeCompare(b));
        keys.sort((a, b) => a.localeCompare(b));
        metaKeys.forEach(k => {
            const option = document.createElement('option');
            option.dataset.namespace = 'meta';
            if (k === 'treeKey') {
                option.text = 'ID';
            } else {
                option.text = k;
            }
            option.value = k;
            keySelect.add(option);
        });
        keys.forEach(k => {
            const option = document.createElement('option');
            option.dataset.namespace = 'treeProps';
            option.text = k;
            option.value = k;
            keySelect.add(option);
        });
        for (const op of keySelect.options) {
            if (op.value === 'searchModalSearchAllFields') {
                keySelect.selectedIndex = op.index;
            }
        }
        if (oldKeySelect instanceof HTMLSelectElement) {
            const oldValue = oldKeySelect.value;
            for (const op of keySelect.options) {
                if (op.value === oldValue) {
                    keySelect.selectedIndex = op.index;
                }
            }
        }
        keySelect.classList.add('fullWidth');
        return keySelect;
    }

    /**
     * @returns {HTMLSelectElement}
     */
    #getOperatorSelect() {
        const select = document.createElement('select');
        select.dataset.role = 'operatorSelect';
        ['=', '!=', 'exists', "! exists", 'contains', "! contains", '<', '<=', '>', '>='].forEach(o => {
            const option = document.createElement('option');
            option.text = o;
            option.value = o;
            select.add(option);
        });
        select.value = 'exists';
        const that = this;
        select.addEventListener('change', function() {
            let parentElement = this.parentElement;
            while (!(parentElement instanceof HTMLTableRowElement)) {
                parentElement = parentElement.parentElement;
            }
            const valueTextInput = parentElement.querySelector('input[data-role="valueInput"]');
            if (['exists', '! exists'].includes(this.value)) {
                if (valueTextInput !== null) {
                    valueTextInput.remove();
                }
            } else {
                if (valueTextInput === null) {
                    parentElement.lastChild.lastChild.appendChild(that.#getValueTextInput());
                }
            }
        });
        for (const op of select.options) {
            if (op.value === 'contains') {
                select.selectedIndex = op.index;
            }
        }
        return select;
    }

    /**
     * @returns {HTMLButtonElement}
     */
    #getResetButton() {
        const btn = this.#getWideButton();
        btn.appendChild(getResetSvg());
        const span = document.createElement('span');
        span.textContent = 'Clear'
        btn.appendChild(span);
        const that = this;
        btn.addEventListener('click', () => {
            if (this.#observables[0] instanceof FeatureGraph) {
                const button = document.querySelector('button.searchModalDeleteButton');
                if (button !== null) {
                    button.click();
                }
                document.querySelector('input.searchModalValueInput').value = '';
            } else {
                const button = document.querySelector('button.componentModalDeleteButton');
                if (button !== null) {
                    button.click();
                }
                document.querySelector('input.componentModalValueInput').value = '';
            }
            this.#search();
        });
        const div = this.#getWideButtonDiv();
        div.appendChild(btn);
        return div;
    }

    /**
     * @returns {HTMLButtonElement}
     */
    #getSearchButton() {
        const btn = this.#getWideButton();
        btn.appendChild(getEyeGlassSvg());
        const span = document.createElement('span');
        span.textContent = 'Search'
        btn.appendChild(span);
        const that = this;
        btn.addEventListener('click', function() {
            that.#search();
        });
        const div = this.#getWideButtonDiv();
        div.appendChild(btn);
        return div;
    }

    /**
     * - x
     * @param {Array} searchCriteria - an array of search criteria
     * @returns {Function}
     */
    #getSearchFunction(searchCriteria) {
        if (!(searchCriteria instanceof Array)) {
            throw TypeError('The "searchCriteria" argumet must be instanceof Array.');
        }
        const func = function(ob) {
            if (ob.getProperty('treeKey', 'meta') === 'omd') {
                return false;
            }
            let flag = true;
            for (const searchCriterion of searchCriteria) {
                const result = searchCriterion.searchFunction(ob);
                if (searchCriterion.logic === 'and') {
                    flag &= result;
                } else if (searchCriterion.logic === 'or') {
                    flag |= result;
                }
            }
            return flag;
        };
        return func.bind(this);
    }

    #getValueTextInput() {
        const input = document.createElement('input');
        input.dataset.role = 'valueInput';
        if (this.#observables[0] instanceof FeatureGraph) {
            input.classList.add('searchModalValueInput');
        } else {
            input.classList.add('componentModalValueInput');
        }
        return input
    }

    /**
     * @returns {HTMLButtonElement}
     */
    #getWideButton() {
        const btn = document.createElement('button');
        btn.classList.add('horizontalFlex');
        btn.classList.add('centerMainAxisFlex');
        btn.classList.add('centerCrossAxisFlex');
        btn.classList.add('fullWidth');
        return btn;
    }

    /**
     * @returns {HTMLDivElement}
     */
    #getWideButtonDiv() {
        const div = document.createElement('div');
        div.classList.add('horizontalFlex');
        div.classList.add('centerMainAxisFlex');
        div.classList.add('centerCrossAxisFlex');
        div.classList.add('halfWidth');
        return div;
    }

    /**
     * - This has to be a function because it's used as an event handler and it's called separately on page load to supply a correct operator select
     * @param {HTMLSelectElement} select
     * @returns {undefined}
     */
    #handleKeySelectChange(select) {
        if (!(select instanceof HTMLSelectElement)) {
            throw TypeError('The "select" argument must be instanceof HTMLSelectElement');
        }
        let parentElement = select.parentElement;
        while (!(parentElement instanceof HTMLTableRowElement)) {
            parentElement = parentElement.parentElement;
        }
        const valueTextInput = parentElement.querySelector('input[data-role="valueInput"]');
        const operatorSelect = parentElement.querySelector('select[data-role="operatorSelect"]');
        // - This corresponds to the "<All Fields>" option being selected
        if (select.selectedIndex === 0) {
            if (valueTextInput === null) {
                parentElement.lastChild.lastChild.appendChild(this.#getValueTextInput());
            }
            const newOperatorSelect = document.createElement('select');
            newOperatorSelect.dataset.role = 'operatorSelect';
            ['contains', '! contains'].forEach(o => {
                const option = document.createElement('option');
                option.text = o;
                option.value = o;
                newOperatorSelect.add(option);
            });
            newOperatorSelect.value = 'contains';
            operatorSelect.replaceWith(newOperatorSelect);
        } else {
            const oldValue = operatorSelect.value;
            const newOperatorSelect = this.#getOperatorSelect();
            newOperatorSelect.value = oldValue;
            operatorSelect.replaceWith(newOperatorSelect);
        }
    }

    /**
     * - Set the contents of this.#searchResults
     * @returns {undefined}
     */
    #search() {
        // - Clear the old FeatureDropdownDivs
        //  - One time I saw a bug where an observable had multiple FeatureDropdownDiv observers, so just remove all of them
        this.#searchResults.forEach(observable => observable.getObservers().filter(observer => observer instanceof FeatureDropdownDiv).forEach(fdd => fdd.remove()));
        // - Clear the old search results
        this.#searchResults = [];
        if (this.#observables[0] instanceof FeatureGraph) {
            LeafletLayer.resetLayerGroups(this.#controller);
        }
        // - Clear the old search criteria and build new search criteria
        const searchCriteria = [];
        for (const tr of this.#modal.divElement.getElementsByTagName('tr')) {
            const keySelect = tr.querySelector('[data-role="keySelect"]');
            // - I only care about rows that have a keySelect
            if (keySelect !== null) {
                const key = keySelect[keySelect.selectedIndex].value;
                const namespace = keySelect[keySelect.selectedIndex].dataset.namespace;
                const operatorSelect = tr.querySelector('[data-role="operatorSelect"]');
                const operator = operatorSelect[operatorSelect.selectedIndex].value;
                let valueInputValue = tr.querySelector('[data-role="valueInput"]');
                if (valueInputValue !== null) {
                    valueInputValue = valueInputValue.value;
                }
                let logic = tr.querySelector('[data-role="andOrSelect"]');
                if (logic !== null) {
                    logic = logic[logic.selectedIndex].value;
                } else {
                    // - First row gets an implicit "and"
                    logic = 'and';
                }
                const searchCriterion = {
                    logic: logic,
                };
                if (operator === 'exists') {
                    searchCriterion.searchFunction = function(ob) {
                        return ob.hasProperty(key, namespace);
                    }
                }
                if (operator === '! exists') {
                    searchCriterion.searchFunction = function(ob) {
                        return !ob.hasProperty(key, namespace);
                    };
                }
                if (operator === '=') {
                    searchCriterion.searchFunction = function(ob) {
                        if (ob.hasProperty(key, namespace)) {
                            const value = ob.getProperty(key, namespace);
                            if (!isNaN(+value)) {
                                return +value === +valueInputValue;
                            } else {
                                return value.toString().toLowerCase() === valueInputValue.toLowerCase();
                            }
                        }
                        return false;
                    };
                }
                if (operator === '!=') {
                    searchCriterion.searchFunction = function(ob) {
                        if (ob.hasProperty(key, namespace)) {
                            const value = ob.getProperty(key, namespace);
                            if (!isNaN(+value)) {
                                return +value !== +valueInputValue;
                            } else {
                                return value.toString().toLowerCase() !== valueInputValue.toLowerCase();
                            }
                        }
                        return false;
                    };
                }
                if (operator === 'contains') {
                    searchCriterion.searchFunction = function(ob) {
                        // - TODO: I really should use a JavaScript symbol or something instead of "searchModalSearchAllFields"
                        if (key === 'searchModalSearchAllFields') {
                            for (const [key, val] of Object.entries(ob.getProperties(namespace))) {
                                if (val.toString().toLowerCase().includes(valueInputValue.toLowerCase()) || key.toString().toLowerCase().includes(valueInputValue.toLowerCase())) {
                                    return true;
                                }
                            }
                            if (ob.getProperty('treeKey', 'meta').toString().toLowerCase().includes(valueInputValue.toLowerCase())) {
                                return true;
                            }
                        } else if (ob.hasProperty(key, namespace)) {
                            return ob.getProperty(key, namespace).toString().toLowerCase().includes(valueInputValue.toLowerCase());
                        }
                        return false;
                    }
                }
                if (operator === '! contains') {
                    searchCriterion.searchFunction = function(ob) {
                        if (key === 'searchModalSearchAllFields') {
                            for (const [key, val] of Object.entries(ob.getProperties(namespace))) {
                                if (val.toString().toLowerCase().includes(valueInputValue.toLowerCase()) || key.toString().toLowerCase().includes(valueInputValue.toLowerCase())) {
                                    return false;
                                }
                            }
                            if (ob.getProperty('treeKey', 'meta').toString().toLowerCase().includes(valueInputValue.toLowerCase())) {
                                return false;
                            }
                            return true;
                        } else if (ob.hasProperty(key, namespace)) {
                            return !ob.getProperty(key, namespace).toString().toLowerCase().includes(valueInputValue.toLowerCase());
                        }
                        return false;
                    }
                }
                if (operator === '<') {
                    searchCriterion.searchFunction = function(ob) {
                        if (ob.hasProperty(key, namespace)) {
                            return +ob.getProperty(key, namespace) < +valueInputValue;
                        }
                        return false;
                    }
                }
                if (operator === '<=') {
                    searchCriterion.searchFunction = function(ob) {
                        if (ob.hasProperty(key, namespace)) {
                            return +ob.getProperty(key, namespace) <= +valueInputValue;
                        }
                        return false;
                    }
                }
                if (operator === '>') {
                    searchCriterion.searchFunction = function(ob) {
                        if (ob.hasProperty(key, namespace)) {
                            return +ob.getProperty(key, namespace) > +valueInputValue;
                        }
                        return false;
                    }
                }
                if (operator === '>=') {
                    searchCriterion.searchFunction = function(ob) {
                        if (ob.hasProperty(key, namespace)) {
                            return +ob.getProperty(key, namespace) >= +valueInputValue;
                        }
                        return false;
                    }
                }
                searchCriteria.push(searchCriterion);
            }
        }
        // - Run the search for normal features
        if (this.#observables[0] instanceof FeatureGraph) {
            this.#searchResults = this.#observables[0].getObservables(this.#getSearchFunction(searchCriteria));
        // - Run the search for components
        } else {
            this.#searchResults = this.#observables.filter(this.#getSearchFunction(searchCriteria));
        }
        // - Only filter the layer groups if the user wants to view the search results
        let showSearchResults = document.querySelector('input[type="radio"][name="circuitDisplay"][value="displaySearch"]');
        // - If showSearchResults is null, it's because this is the first search that happens during page load
        if (showSearchResults === null) {
            showSearchResults = false;
        } else {
            showSearchResults = showSearchResults.checked;
        }
        if (this.#observables[0] instanceof FeatureGraph && showSearchResults) {
            this.filterLayerGroups();
        }
        // - Don't attach event handlers here because then I'll be adding a new event handler after every search!
        const {configs, nodes, lines} = this.#getCategorizedSearchResults();
        [
            [this.#configDropdownDiv, configs, 'Configuration objects'],
            [this.#nodeDropdownDiv, nodes, 'Nodes'],
            [this.#lineDropdownDiv, lines, 'Lines']
        ].forEach(ary => {
            ary[0].setButton(`${ary[2]}: ${ary[1].length}`, true);
            if (ary[0].isExpanded() && ary[0].contentDivElement.children.length === 0) {
                this.#appendFeatureDropdownDivs(ary[0], ary[1]);
            }
        });
    }

    /**
     * - Filter the layer groups so that only the search results are shown
     */
    filterLayerGroups() {
        LeafletLayer.nodeLayers.clearLayers();
        LeafletLayer.nodeClusterLayers.clearLayers();
        LeafletLayer.lineLayers.clearLayers();
        LeafletLayer.parentChildLineLayers.clearLayers();
        for (const observable of this.#searchResults) {
            if (observable.isNode() && !observable.isConfigurationObject()) {
                const ll = observable.getObservers().filter(observer => observer instanceof LeafletLayer)[0];
                if (LeafletLayer.clusterControl._on) {
                    LeafletLayer.nodeClusterLayers.addLayer(ll.getLayer());
                } else {
                    LeafletLayer.nodeLayers.addLayer(ll.getLayer());
                }
            } else if (observable.isLine()) {
                const ll = observable.getObservers().filter(observer => observer instanceof LeafletLayer)[0];
                if (observable.isParentChildLine()) {
                    LeafletLayer.parentChildLineLayers.addLayer(ll.getLayer());
                } else {
                    LeafletLayer.lineLayers.addLayer(ll.getLayer());
                }
            }
        }
        // - Force redraw
        for (const layer of [LeafletLayer.parentChildLineLayers, LeafletLayer.lineLayers, LeafletLayer.nodeLayers, LeafletLayer.nodeClusterLayers]) {
            LeafletLayer.map.removeLayer(layer);
            LeafletLayer.map.addLayer(layer);
        }
    }
}

/**
 * - https://www.svgrepo.com
 */
function getEyeGlassSvg() {
    const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.setAttribute('width', '22px');
    svg.setAttribute('height', '22px');
    svg.setAttribute('viewBox', '0 0 24 24');
    svg.setAttribute('fill', 'none'); 
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', "M4 11C4 7.13401 7.13401 4 11 4C14.866 4 18 7.13401 18 11C18 14.866 14.866 18 11 18C7.13401 18 4 14.866 4 11ZM11 2C6.02944 2 2 6.02944 2 11C2 15.9706 6.02944 20 11 20C13.125 20 15.078 19.2635 16.6177 18.0319L20.2929 21.7071C20.6834 22.0976 21.3166 22.0976 21.7071 21.7071C22.0976 21.3166 22.0976 20.6834 21.7071 20.2929L18.0319 16.6177C19.2635 15.078 20 13.125 20 11C20 6.02944 15.9706 2 11 2Z");
    path.setAttribute('fill-rule', 'evenodd');
    path.setAttribute('clip-rule', 'evenodd');
    path.setAttribute('fill', '#FFFFFF');
    path.setAttribute('stroke-width', '1.5');
    path.setAttribute('stroke-width', '1.5');
    path.setAttribute('stroke-linecap', 'round');
    path.setAttribute('stroke-linejoin', 'round');
    svg.appendChild(path);
    return svg
}

function getResetSvg() {
    const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.setAttribute('width', '22px');
    svg.setAttribute('height', '22px');
    svg.setAttribute('viewBox', '-4 -4 24 24');
    svg.setAttribute('fill', 'none');
    let path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', 'm4.5 1.5c-2.4138473 1.37729434-4 4.02194088-4 7 0 4.418278 3.581722 8 8 8s8-3.581722 8-8-3.581722-8-8-8');
    path.setAttribute('stroke', '#FFFFFF');
    path.setAttribute('stroke-width', '2');
    path.setAttribute('stroke-width', '2');
    path.setAttribute('stroke-linecap', 'round');
    path.setAttribute('stroke-linejoin', 'round');
    svg.appendChild(path)
    path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', 'm4.5 5.5v-4h-4');
    path.setAttribute('stroke', '#FFFFFF');
    path.setAttribute('stroke-width', '2');
    path.setAttribute('stroke-width', '2');
    path.setAttribute('stroke-linecap', 'round');
    path.setAttribute('stroke-linejoin', 'round');
    svg.appendChild(path);
    return svg;
}
</script>
<script>
"use strict";

class Nav {
    sideNav;
    sideNavNavElement;
    sideNavDivElement;
    sideNavArticleElement;
    topNav;
    topNavNavElement;

    /**
     * - Connect a SideNav and TopNav together
     */
    constructor() {
        this.sideNav = new SideNav();
        this.sideNavNavElement = this.sideNav.navElement;
        this.sideNavDivElement = this.sideNav.divElement;
        this.sideNavArticleElement = this.sideNav.articleElement;
        this.topNav = new TopNav();
        this.topNavNavElement = this.topNav.navElement;
        //const hamburger = this.topNavNavElement.getElementsByTagName('button')[0];
        //hamburger.addEventListener('click', function () {
        //});
        const that = this
        this.sideNavDivElement.addEventListener('click', function() {
            that.sideNavNavElement.classList.remove('open');
            that.sideNavDivElement.classList.remove('open');
            that.sideNavArticleElement.classList.remove('compressed');
        });
    }
}
</script>
<script>
"use strict";

// - Use voltDumpOlinBarre.csv, currDumpOlinBarre.csv and Olin Barre Fault.omd as examples

class ColorModal { // implements ModalInterface, ObserverInterface
    #colorFiles;            // - Object of ColorFiles
    #selectedColorFilename; // - The name of the file that contains the information for the currently applied coloring
    #selectedColorMapIndex; // - The 0-based index of the column in the color file for the currently applied coloring
    #controller;            // - ControllerInterface instance
    #modal;                 // - Modal instance
    #observables;           // - An array of ObservableInterface instances
    #removed;               // - Whether this ColorModal instance has already been deleted

    /**
     * @param {Array} observables - an array of ObservableInterface instances
     * @param {FeatureController} controller - a ControllerInterface instance
     */
    constructor(observables, controller) {
        if (!(observables instanceof Array)) {
            throw TypeError('"observables" argumnet must be an Array.');
        }
        if (!(controller instanceof FeatureController)) {
            throw Error('"controller" argument must be instanceof FeatureController.');
        }
        this.#colorFiles = {};
        this.#selectedColorFilename = null;
        this.#selectedColorMapIndex = null;
        this.#controller = controller;
        this.#modal = null;
        this.#observables = observables;
        this.#observables.forEach(ob => ob.registerObserver(this));
        this.#removed = false;
        this.renderContent();
        this.refreshContent();
    }

    // *******************************
    // ** ObserverInterface methods **
    // *******************************

    /**
     * - Remove this ObserverInterface instance (i.e. "this") from the ObservableInterface instance (i.e. "observable") that has been deleted, and
     *   perform other actions as needed
     * @param {Feature} observable - an ObservableInterface instance
     * @returns {undefined}
     */
    handleDeletedObservable(observable) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('"observable" argument must be instanceof Feature.');
        }
        if (!this.#removed) {
            observable.removeObserver(this);
            const index = this.#observables.indexOf(observable);
            if (index > -1) {
                this.#observables.splice(index, 1);
            } else {
                throw Error('The observable was not found in this.#observables.');
            }
            if (this.#observables.length === 0) {
                this.remove();
            } else {
                this.refreshContent();
            }
        }
    }

    /**
     *
     */
    handleNewObservable(observable) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        throw new UnsupportedOperationError();
    }

    /**
     * - Update this ObserverInterface instance (i.e. "this") based on the coordinates of the ObservableInterface instance (i.e. "observable") that
     *   have just changed and perform other actions as needed
     * @param {Feature} observable - an ObservableInterface instance
     * @param {Array} oldCoordinates - the old coordinates of the observable prior to the change in coordinates
     * @returns {undefined}
     */
    handleUpdatedCoordinates(observable, oldCoordinates) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('"observable" argument must be instanceof Feature.');
        }
        if (!(oldCoordinates instanceof Array)) {
            throw TypeError('"oldCoordinates" argument must be an array.');
        }
        this.refreshContent();
    }

    /**
     * - Update this ObserverInstance (i.e. "this") based on the property of the ObservableInterface instance (i.e. "observable") that has just
     *   changed and perform other actions as needed
     * @param {Feature} observable - an ObservableInterface instance
     * @param {string} propertyKey - the property key of the property that has been created/changed/deleted in the observable
     * @param {(string|Object)} oldPropertyValue - the previous value of the property that has been created/changed/deleted in the observable
     * @param {string} namespace - the namespace of the property that has been created/changed/deleted in the observable
     * @returns {undefined}
     */
    handleUpdatedProperty(observable, propertyKey, oldPropertyValue, namespace='treeProps') {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('"observable" argument must be instanceof Feature.');
        }
        if (typeof propertyKey !== 'string') {
            throw TypeError('"propertyKey" argument must be a string.');
        }
        if (typeof namespace !== 'string') {
            throw TypeError('"namespace" argument must be a string.');
        }
        this.refreshContent();
    }

    // ****************************
    // ** ModalInterface methods **
    // ****************************

    getDOMElement() {
        return this.#modal.divElement;
    }

    /**
     * @returns {boolean}
     */
    isRemoved() {
        return this.#removed;
    }

    /**
     * @returns {undefined}
     */
    refreshContent() {
        const fileListModal = new Modal();
        fileListModal.addStyleClasses(['colorModal'], 'divElement');
        if (Object.values(this.#colorFiles).length > 0) {
            fileListModal.insertTHeadRow(['Filename', 'Color-by Column', 'Apply Column Color on Page Load' ]);
            fileListModal.addStyleClasses(['centeredTable'], 'tableElement');
        }
        const attachments = this.#controller.observableGraph.getObservable('omd').getProperty('attachments', 'meta');
        for (const colorFile of Object.values(this.#colorFiles)) {
            const select = document.createElement('select');
            for (const [idx, cm] of Object.entries(colorFile.getColorMaps())) {
                const option = document.createElement('option');
                option.text = `${cm.getColumnName()} (column ${idx})`;
                option.value = idx;
                select.add(option);
            }
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.name = 'colorOnLoadColumnIndex';
            select.addEventListener('change', function() {
                // - Get the checkbox and check or uncheck it depending on colorOnLoad
                if (this.value === attachments.coloringFiles[colorFile.getFilename()].colorOnLoadColumnIndex) {
                    checkbox.checked = true;
                } else {
                    checkbox.checked = false;
                }
            });
            // - On load, set the select option to the equivalent colorOnLoad column, if there was one
            if (attachments.coloringFiles[colorFile.getFilename()].hasOwnProperty('colorOnLoadColumnIndex')) {
                for (const op of select.options) {
                    if (op.value === attachments.coloringFiles[colorFile.getFilename()].colorOnLoadColumnIndex) {
                        select.selectedIndex = op.index;
                        checkbox.checked = true;
                    }
                }
            }
            checkbox.addEventListener('change', function() {
                for (const [filename, obj] of Object.entries(attachments.coloringFiles)) {
                    if (filename === colorFile.getFilename()) {
                        if (this.checked) {
                            obj.colorOnLoadColumnIndex = select.value;
                        } else {
                            delete obj.colorOnLoadColumnIndex;
                        }
                    } else {
                        if (this.checked) {
                            delete obj.colorOnLoadColumnIndex;
                            for (const input of [...fileListModal.divElement.querySelectorAll('input[type="checkbox"][name="colorOnLoadColumnIndex"]')]) {
                                if (input !== this) {
                                    input.checked = false;
                                }
                            }
                        }
                    }
                }
            });
            const colorButton = document.createElement('button');
            colorButton.classList.add('horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex', 'fullWidth');
            let span = document.createElement('span');
            span.textContent = 'Color';
            colorButton.appendChild(span);
            colorButton.addEventListener('click', () => {
                const colorMap = colorFile.getColorMaps()[select.value];
                this.#applyColorMap(colorFile, colorMap);
                this.#selectedColorFilename = colorFile.getFilename();
                this.#selectedColorMapIndex = colorMap.getColumnIndex();
            });
            const removeButton = document.createElement('button');
            removeButton.classList.add('horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex', 'fullWidth', 'delete');
            span = document.createElement('span');
            span.textContent = 'Remove';
            removeButton.appendChild(span);
            removeButton.addEventListener('click', () => {
                if (attachments.hasOwnProperty('coloringFiles')) {
                    const filename = colorFile.getFilename();
                    delete attachments.coloringFiles[filename];
                    delete this.#colorFiles[filename];
                    this.refreshContent();
                    if (Object.keys(attachments.coloringFiles).length === 0) {
                        delete attachments.coloringFiles;
                    }
                    this.#selectedColorFilename = null;
                    this.#selectedColorMapIndex = null;
                }
            });
            fileListModal.insertTBodyRow([colorFile.getFilename(), select, checkbox, colorButton, removeButton])
        }
        const containerElement = this.#modal.divElement.getElementsByClassName('div--modalElementContainer')[0];
        const oldModal = containerElement.getElementsByClassName('js-div--modal');
        if (oldModal.length === 0) {
            containerElement.prepend(fileListModal.divElement);
        } else {
            oldModal[0].replaceWith(fileListModal.divElement);
        }
    }

    /**
     * @returns {undefined}
     */
    remove() {
        if (!this.#removed) {
            this.#observables.forEach(ob => ob.removeObserver(this));
            this.#observables = null;
            this.#modal.divElement.remove();
            this.#removed = true;
        }
    }

    /**
     * - Render the modal for the first time
     * @returns {undefined}
     */
    renderContent() {
        // - Build the modal
        const modal = new Modal();
        modal.addStyleClasses(['outerModal', 'fitContent'], 'divElement');
        modal.setTitle('Color Circuit');
        modal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'titleElement');
        const colorInput = document.createElement('input');
        colorInput.type = 'file';
        colorInput.accept = '.csv';
        colorInput.required = true;
        colorInput.id = 'colorInput';
        const that = this;
        colorInput.addEventListener('change', async function() {
            const file = this.files[0];
            const results = await that.#parseCsv(file);
            if (results.errors.length > 0) {
                // - Papa Parse did parse the file, but there was some kind of small problem. Make the user fix it
                that.#modal.showProgress(false, `There was an error "${results.errors[0].message}" when parsing the CSV file "${file.name}". Please double-check the CSV formatting.`, ['caution']);
                return;
            } else {
                that.#modal.setBanner('', ['hidden']);
            }
            if (!attachments.hasOwnProperty('coloringFiles')) {
                attachments.coloringFiles = {};
            }
            attachments.coloringFiles[file.name] = {
                csv: Papa.unparse(results.data)
                // - colorOnLoadColumnIndex should specify a column index if the interface should color on load by a column, otherwise it shouldn't
                //   exist
            }
            that.#createColorFilesFromAttachments();
            that.refreshContent();
        });
        const colorLabel = document.createElement('label');
        colorLabel.htmlFor = 'colorInput';
        colorLabel.innerHTML = 'Add a file containing bus names and electrical readings (.csv)';
        modal.insertTBodyRow([colorLabel, colorInput]);
        modal.addStyleClasses(['centeredTable'], 'tableElement');
        const resetButton = document.createElement('button');
        let span = document.createElement('span');
        span.textContent = 'Reset Colors';
        resetButton.appendChild(span);
        resetButton.classList.add('horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex', 'fullWidth');
        resetButton.addEventListener('click', () => this.#resetColors());
        const submitDiv = document.createElement('div');
        submitDiv.classList.add('horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex', 'halfWidth');
        submitDiv.appendChild(resetButton);
        modal.insertElement(submitDiv);
        modal.addStyleClasses(['verticalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'containerElement');
        if (this.#modal === null) {
            this.#modal = modal;
        }
        if (document.body.contains(this.#modal.divElement)) {
            this.#modal.divElement.replaceWith(modal.divElement);
            this.#modal = modal;
        }
        // - Apply any colorOnLoad colorings
        this.#createColorFilesFromAttachments();
        const attachments = that.#controller.observableGraph.getObservable('omd').getProperty('attachments', 'meta');
        if (attachments.hasOwnProperty('coloringFiles')) {
            for (const [filename, obj] of Object.entries(attachments.coloringFiles)) {
                if (obj.hasOwnProperty('colorOnLoadColumnIndex')) {
                    const colorFile = this.#colorFiles[filename];
                    const colorMap = colorFile.getColorMaps()[obj.colorOnLoadColumnIndex];
                    // - This if-statement is just in case the colorOnLoadColumnIndex value is invalid for some reason
                    if (colorMap instanceof ColorMap) {
                        this.#applyColorMap(colorFile, colorMap);
                        this.#selectedColorFilename = colorFile.getFilename();
                        this.#selectedColorMapIndex = colorMap.getColumnIndex();
                    }
                }
            }
        }
        // - Add map event listener to re-apply coloring after hide and show
        LeafletLayer.map.on('overlayadd', (layerControlEvent) => {
            if (this.#selectedColorFilename !== null && this.#selectedColorMapIndex !== null) {
                const colorFile = this.#colorFiles[this.#selectedColorFilename];
                const colorMap = this.#colorFiles[this.#selectedColorFilename].getColorMaps()[this.#selectedColorMapIndex];
                this.#applyColorMap(colorFile, colorMap);
            }
        });
    }

    // ********************
    // ** Public methods **
    // ********************

    // *********************
    // ** Private methods **
    // *********************

    /**
     * @param {ColorFile} colorFile
     * @param {ColorMap} colorMap
     * @returns {undefined}
     */
    #applyColorMap(colorFile, colorMap) {
        if (!(colorFile instanceof ColorFile)) {
            throw TypeError('The "colorFile" argument must be instanceof ColorFile.');
        }
        if (!(colorMap instanceof ColorMap)) {
            throw TypeError('The "colorMap" argument must be instanceof ColorMap.');
        }
        const notFound = [];
        // - Color everything gray to get rid of default colors
        for (const observable of this.#controller.observableGraph.getObservables()) {
            observable.getObservers().filter(observer => observer instanceof LeafletLayer).forEach(ll => {
                const path = Object.values(ll.getLayer()._layers)[0];
                if (observable.isNode()) {
                    if (!path.options.hasOwnProperty('originalFillColor')) {
                        path.options.originalFillColor = path.options.fillColor;
                    }
                    path.setStyle({
                        fillColor: 'gray'
                    });
                } else if (observable.isLine()) {
                    if (!path.options.hasOwnProperty('originalColor')) {
                        path.options.originalColor = path.options.color;
                    }
                    if (!path.options.hasOwnProperty('colorModalColor')) {
                        path.options.colorModalColor = 'gray';
                    }
                    // - The line is highlighted
                    if (path.options.color === '#7FFF00') {
                        // - pass
                    } else {
                        path.setStyle({
                            color: 'gray'
                        });
                    }
                }
            });
        }
        // - Force refresh the map so that the lines change color
        LeafletLayer.map.setZoom(LeafletLayer.map.getZoom());
        // - Actually apply colors from color map (only nodes supported right now, I don't have a CSV with lines to color)
        for (const [name, obj] of Object.entries(colorMap.getColorMapping())) {
            try {
                const key = this.#controller.observableGraph.getKeyForComponent(name);
                const observable = this.#controller.observableGraph.getObservable(key);
                observable.getObservers().filter(ob => ob instanceof LeafletLayer).forEach(ll => {
                    const path = Object.values(ll.getLayer()._layers)[0];
                    const hex = ColorModal.rgbToHex(obj.color._rgb[0], obj.color._rgb[1], obj.color._rgb[2]);
                    if (observable.isNode()) {
                        path.setStyle({
                            fillColor: hex
                        });
                    }
                    if (observable.isLine()) {
                        observable.options.colorModalColor = hex;
                        path.setStyle({
                            color: hex
                        });
                    }
                });
            } catch (e) {
                notFound.push(name);
            }
        }
        console.log(`The following names in the CSV did not match any visible object in the circuit: ${notFound}`);
        // - Display legend
        colorMap.displayLegend(colorFile.getFilename());
    }

    /**
     * @param {File} file
     * @returns {string}
     */
    #parseCsv(file) {
        if (!(file instanceof File)) {
            throw TypeError('"file" argument must be instanceof File.');
        }
        return new Promise(function(resolve, reject) {
            Papa.parse(file, {
                dynamicTyping: true,
                complete: function(results, file) {
                    resolve(results);
                },
                error: function(error, file) {
                    reject(error.message);
                }
            });
        });
    }

    /**
     * - Iterate through the strings in the attachments and create a ColorFile instance for each string
     * @returns {undefined}
     */
    #createColorFilesFromAttachments() {
        const attachments = this.#controller.observableGraph.getObservable('omd').getProperty('attachments', 'meta');
        if (attachments.hasOwnProperty('coloringFiles')) {
            for (const [filename, obj] of Object.entries(attachments.coloringFiles)) {
                // - Create a ColorFile as a container for one or more ColorMaps
                const colorFile = new ColorFile(filename);
                // - Fill the ColorFile with actual data
                try {
                    colorFile.createColorMaps(obj.csv);
                    this.#modal.setBanner('', ['hidden']);
                } catch (e) {
                    // - Papa Parse did parse the file and didn't find any errors, but I still couldn't create a good ColorFile object, so tell the
                    //   user to remove or fix the file
                    this.#modal.showProgress(false, `The CSV "${filename}" was parsed, but there was an error "${e.message}" when converting the CSV values into colors. Please double-check the CSV content.`, ['caution']);
                }
                // - Save the colorFile so that refreshContent() can access it
                this.#colorFiles[filename] = colorFile;
            }
        }
    }

    /**
     * @returns {undefined}
     */
    #resetColors() {
        this.#controller.observableGraph.getObservables().forEach(observable => {
            observable.getObservers().filter(observer => observer instanceof LeafletLayer).forEach(ll => {
                const path = Object.values(ll.getLayer()._layers)[0];
                if (observable.isNode()) {
                    path.setStyle({
                        fillColor: path.options.originalFillColor
                    });
                } else if (observable.isLine()) {
                    delete path.options.colorModalColor;
                    // - The line is highlighted
                    if (path.options.color === '#7FFF00') {
                        // - pass
                    } else {
                        path.setStyle({
                            color: path.options.originalColor
                        });
                    }
                }
            });
        });
        this.#selectedColorFilename = null;
        this.#selectedColorMapIndex = null;
        // - Force refresh the map so that the lines change color
        LeafletLayer.map.setZoom(LeafletLayer.map.getZoom());
    }

    static rgbToHex(r, g, b) {
        return '#' + [r, g, b].map(x => {
            const hex = x.toString(16)
            return hex.length === 1 ? '0' + hex : hex
        }).join('');
    }
}

class ColorFile {

    #colorMaps;
    #filename;

    /**
     * @param {string} filename - the filename of the CSV
     */
    constructor(filename) {
        if (typeof filename !== 'string') {
            throw TypeError('"filename" argument must be typeof string.');
        }
        this.#colorMaps = {};   // - While columns in a CSV can have duplicate headings, they must have unique indexes
        this.#filename = filename;
    }

    /**
     * @param {string} text - the text content of the CSV as a string
     * @returns {undefined}
     */
    createColorMaps(text) {
        if (typeof text !== 'string') {
            throw TypeError('"text" argument must be typeof string.');
        }
        const results = Papa.parse(text, {dynamicTyping: true});
        const headerRow = results.data[0];
        // - i = 1 because the first column contains names, not numeric values
        for (let i = 1; i < headerRow.length; i++) {
            const cm = new ColorMap(headerRow[i].toString(), i);
            this.#colorMaps[i] = cm;
        }
        for (let i = 1; i < results.data.length; i++) {
            const row = results.data[i];
            for (let j = 1; j < row.length; j++) {
                this.#colorMaps[j].mapNameToValue(row[0].toString(), {color: null, float: row[j]});
            }
        }
        Object.values(this.#colorMaps).forEach(cm => cm.generateColorsFromFloats());
    }

    /**
     * @returns {Object}
     */
    getColorMaps() {
        return this.#colorMaps;
    }

    /**
     * @returns {string}
     */
    getFilename() {
        return this.#filename;
    }
}

class ColorMap {

    #columnName;
    #columnIndex;
    #nameToValue;
    static viridisColors = ['#440154', '#482173', '#433e85', '#38588c', '#2d708e', '#25858e', '#1e9b8a', '#2ab07f', '#52c569', '#86d549', '#c2df23', '#fde725'];

    /**
     * @param {string} columnName
     */
    constructor(columnName, columnIndex) {
        if (typeof columnName !== 'string') {
            throw TypeError('"columnName" argument must be typeof string.');
        }
        if (typeof columnIndex !== 'number') {
            throw TypeError('"columnIndex" argument must be typeof number.');
        }
        this.#columnName = columnName;
        this.#nameToValue = {};
        this.#columnIndex = columnIndex;
    }

    // ********************
    // ** Public methods **
    // ********************

    /**
     * @param {string} filename
     * @returns {undefined}
     */
    displayLegend(filename) {
        if (typeof filename !== 'string') {
            throw TypeError('"filename" argument must be typeof string.');
        }
        const modal = new Modal();
        modal.divElement.style.width = '300px';
        // - Create titles
        const fileColumnDiv = document.createElement('div');
        fileColumnDiv.style.textAlign = 'center';
        fileColumnDiv.style.wordBreak = 'break-word';
        const filenameHeading = document.createElement('h2');
        filenameHeading.style.width = '100%';
        filenameHeading.textContent = filename;
        fileColumnDiv.appendChild(filenameHeading);
        const columnNameHeading = document.createElement('h3');
        columnNameHeading.style.width = '100%';
        columnNameHeading.textContent = this.#columnName;
        fileColumnDiv.appendChild(columnNameHeading);
        modal.setTitle(fileColumnDiv);
        // - Create color gradient
        const legendDiv = document.createElement('div');
        legendDiv.classList.add('horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex');
        const legendGradient = document.createElement('div');
        legendGradient.style.height = '400px';
        legendGradient.style.width = '50px';
        legendGradient.style.background = `linear-gradient(0deg, ${ColorMap.viridisColors.join(',')})`;
        legendDiv.appendChild(legendGradient);
        const legendValues = document.createElement('div');
        legendValues.style.height = '400px';
        const floats = Object.values(this.#nameToValue).map(obj => obj.float);
        const min = Math.min.apply(null, floats);
        let span = document.createElement('span');
        span.textContent = min.toFixed(3);
        legendValues.appendChild(span);
        const max = Math.max.apply(null, floats);
        const step = (max - min) / 6;
        for (let i = 1; i < 6; i++) {
            const span = document.createElement('span');
            span.textContent = `${ (min + (step * i)).toFixed(3)}`;
            legendValues.prepend(span);
        }
        span = document.createElement('span');
        span.textContent = max.toFixed(3);
        legendValues.prepend(span);
        legendValues.classList.add('verticalFlex');
        legendValues.style.justifyContent = 'space-between';
        legendValues.style.paddingLeft = '5px';
        legendDiv.appendChild(legendValues);
        modal.insertElement(legendDiv);
        modal.addStyleClasses(['verticalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'containerElement');
        // - Create button
        const button = document.createElement('button');
        button.classList.add('horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex', 'fullWidth');
        button.addEventListener('click', function() {
            document.getElementById('legendInsert').replaceChildren();
        });
        span = document.createElement('span');
        span.textContent = 'Close';
        button.appendChild(span);
        const buttonDiv = document.createElement('div');
        buttonDiv.classList.add('horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex', 'halfWidth');
        buttonDiv.appendChild(button);
        modal.insertElement(buttonDiv);
        document.getElementById('legendInsert').replaceChildren(modal.divElement);
        const draggable = new L.Draggable(modal.divElement)
        draggable.enable()
    }

    /**
     * - After all names have been mapped to numeric values, iterate through the colorMap again and generate color objects
     * @returns {undefined}
     */
    generateColorsFromFloats() {
        const floats = Object.values(this.#nameToValue).map(obj => obj.float);
        const min = Math.min.apply(null, floats);
        const max = Math.max.apply(null, floats);
        const func = chroma.scale(ColorMap.viridisColors).domain([min, max]);
        Object.values(this.#nameToValue).forEach(obj => {
            obj.color = func(obj.float);
            // - I round because later on I need to convert the integer values into a hex string
            obj.color._rgb = obj.color._rgb.map(float => Math.round(float));
        });
    }

    getColorMapping() {
        return this.#nameToValue;
    }

    getColumnName() {
        return this.#columnName;
    }

    getColumnIndex() {
        return this.#columnIndex;
    }

    /**
     * @param {string} name - the name of an object to color (e.g. a node name)
     * @param {string|Object} value - when iterating over a CSV for the first time, the only floats are known. Once a Chroma scale has been generated,
     *      then colors are also mapped
     * @returns {undefined}
     */
    mapNameToValue(name, value) {
        if (typeof name !== 'string') {
            throw TypeError('"name" argument must be typeof string.');
        }
        if (typeof value !== 'object') {
            throw TypeError('"value" argument must be typeof object.');
        }
        if (!value.hasOwnProperty('color')) {
            throw TypeError('"value" argument must have a "color" property.');
        }
        if (!value.hasOwnProperty('float')) {
            throw TypeError('"value" argument must have a "float" property.');
        }
        if (this.#nameToValue[name] === undefined) {
            this.#nameToValue[name] = {};
        }
        if (value.hasOwnProperty('color')) {
            this.#nameToValue[name].color = value.color;
        }
        if (value.hasOwnProperty('float')) {
            this.#nameToValue[name].float = value.float;
        }
    }

    // *********************
    // ** Private methods **
    // *********************
}
</script>
<script>
"use strict";

class FeatureGraph {
    #graph;         // - This points to the actual graph data structure. I'm using the Graphology library
    #keyToFeature;  // - Graphology graphs allow nodes and lines to have the same key. This is great for representing lines with children, but is annoying when trying to retrieve a feature by its key
    #nameToKey;     // - Names are not unique, so I potentially need to map one name to multiple keys
    #observers;     // - A FeatureGraph implements ObservableInterface

    /**
     * - Create an empty graph that will connect all Feature instances (regular features, components, parent-child lines, etc.) as Observables and
     *   Observers
     * @returns {Object} graph
     */
    constructor() {
        const options = {
            // - Do NOT allow self-loops. Even if a line starts and ends on the same node, the graph models it as two nodes connected by two edges
            //   (i.e. a multi-edge)
            allowSelfLoops: false,   
            // - Allow multiple edges between nodes (OMDs have them)
            multi: true,            
            // - Restrict to an undirected graph type
            type: 'undirected'      
        };
        this.#graph = new graphology.Graph(options);
        this.#keyToFeature = {};
        this.#nameToKey = {};
        this.#observers = [];
    }

    // *********************************
    // ** ObservableInterface methods **
    // *********************************

    deleteProperty(propertyKey, namespace='treeProps') {
        throw new UnsupportedOperationError();
    }

    // - TODO: call handleDeletedObservable() on the observers of this graph in handleDeletedObservable()
    deleteObservable() {
        throw new UnsupportedOperationError();
    }

    getCoordinates() {
        throw new UnsupportedOperationError();
    }

    /**
     * @param {string} key - the key of the ObservableInterface object that I want
     * @returns {Feature} an instance of my Feature class
     */
    getObservable(key) {
        if (typeof key !== 'string') {
            throw TypeError('The "key" argument must be a string.');
        }
        if (!this.#keyToFeature.hasOwnProperty(key)) {
            throw new FeatureNotFoundError(key);
        }
        return this.#keyToFeature[key];
    }

    /**
     * @param {Function} [func=null] - a function that filters features so that only the desired features are returned. The function should take a
     * single argument (a feature), and should return a boolean depending on whether to include the feature in the array
     * - I could argue that the logic executed in Feature.getObservableExportData() could be provided via a function argument, as it is here, so while
     *   the different method signatures violate the interface, I could make both conform to it
     * @returns {Object} a GeoJSON FeatureCollection object
     */
    getObservableExportData(func=null) {
        if (func !== null && typeof func !== 'function') {
            throw TypeError('The "func" argument must be null or a typeof "function".');
        }
        if (func === null) {
            func = function(f) {
                if (f.getProperty('treeKey', 'meta') === 'omd') {
                    return true;
                } else {
                    return isNaN(+f.getProperty('treeKey', 'meta')) ? false : true;
                }
            }
        }
        return { 
            'type': 'FeatureCollection',
            'features': this.getObservables(func).map(f => f.getObservableExportData())
        };
    }

    /**
     * @param {Function} func - a function that filters features so that only the desired features are returned. The function should take a single
     * argument (a feature), and should return a boolean depending on whether to include the feature in the array
     * @returns {Array} - an array of ObservableInterface instances, where each instance met the filtering criteria
     */
    getObservables(func) {
        if (typeof func !== 'undefined') {
            return Object.values(this.#keyToFeature).filter(f => func(f));
        }
        return Object.values(this.#keyToFeature);
    }

    getObservers() {
        throw new UnsupportedOperationError();
    }

    getProperties(namespace) {
        throw new UnsupportedOperationError();
    }

    getProperty(propertyKey, namespace='treeProps') {
        throw new UnsupportedOperationError();
    }

    hasCoordinates() {
        throw new UnsupportedOperationError();
    }

    hasGraph() {
        throw new UnsupportedOperationError();
    }

    hasProperty(propertyKey, namespace='treeProps') {
        throw new UnsupportedOperationError();
    }

    /**
     * @param {Feature} observable - the observable that was just added to this graph
     * @returns {undefined}
     */
    notifyObserversOfNewObservable(observable) {
        if (!(observable instanceof Feature)) {
            throw TypeError('The "observable" argument must be an instance of my Feature class.');
        }
        this.#observers.forEach(ob => ob.handleNewObservable(observable));
    }

    /**
     * @param {Object} observer - an instance of ObserverInterface that wants to observer this ObservableInterface instance
     *  - E.g. a SearchModal wants to observe this FeatureGraph
     * @returns {undefined}
     */
    registerObserver(observer) {
        // - The function signature above is part of the ObservableInterface API. The implementation below is not
        if (observer instanceof Feature) {
            throw new ObserverError();
        }
        this.#observers.push(observer);
    }

    /**
     * @param {Object} observer - an instance of ObserverInterface that no longer should observe this ObservableInterface instance
     * @returns {undefined}
     */
    removeObserver(observer) {
        // - The function signature above is part of the ObservableInterface API. The implementation below is not
        if (observer instanceof Feature) {
            throw new ObserverError();
        }
        const index = this.#observers.indexOf(observer);
        if (index > -1) {
            this.#observers.splice(index, 1);
        } else {
            throw Error('The observer was not found in this.#observers');
        }
    }

    setCoordinates(coordinates) {
        throw new UnsupportedOperationError();
    }

    setGraph(graph) {
        throw new UnsupportedOperationError();
    }

    setProperty(propertyKey, propertyValue, namespace='treeProps') {
        throw new UnsupportedOperationError();
    }

    /**
     *
     */
    updateCoordinatesOfObservers(oldCoordinates) {
        this.#observers.forEach(ob => ob.handleUpdatedCoordinates(this, oldCoordinates))
    }

    /**
     *
     */
    updatePropertyOfObservers(propertyKey, oldPropertyValue, namespace='treeProps') {
        this.#observers.forEach(ob => ob.handleUpdatedProperty(this, propertyKey, oldPropertyValue, namespace));
    }

    // *******************************
    // ** ObserverInterface methods ** 
    // *******************************

    /**
     * - Remove this ObserverInterface instance (i.e. "this") from the ObservableInterface instance (i.e. "observable") that has been deleted, and
     *   perform other actions as needed
     * @param {Feature} observable - an ObservableInterface instance
     * @returns {undefined}
     */
    handleDeletedObservable(observable) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('The "observable" argument must be instanceof Feature.');
        }
        const observableKey = observable.getProperty('treeKey', 'meta');
        if (this.#graph.hasNode(observableKey)) {
            this.#graph.setNodeAttribute(observableKey, 'visited', true);
            // - If a node is deleted, all of its attached lines need to be deleted too
            if (observable.isNode()) {
                this.#graph.edges(observableKey).forEach(edgeKey => {
                    const observerKey = this.#getObserverKey(observableKey, edgeKey);
                    const observer = this.getObservable(observerKey);
                    if (observer.isLine()) {
                        if (this.#graph.getNodeAttribute(observerKey, 'visited') !== true) {
                            observer.deleteObservable();
                        }
                    } else {
                        throw new GraphNodeEdgeError(observableKey, observerKey);
                    }
                });
            // - If a line is deleted, any attached lines also need to be deleted
            //  - TODO: only the line(s) that have a "from" or "to" value that matches the name of the line being deleted should also be deleted,
            //    otherwise creating a triangle of lines and deleting the bracing line deletes the other two lines
            } else if (observable.isLine()) {
                this.#graph.edges(observableKey).forEach(edgeKey => {
                    const observerKey = this.#getObserverKey(observableKey, edgeKey);
                    const observer = this.getObservable(observerKey);
                    // - If the observable is a parent-child line, delete the child and any attached lines
                    if (observable.isParentChildLine()) {
                        const childName = observable.getProperty('to');
                        if (observer.getProperty('name') === childName) { 
                            if (this.#graph.getNodeAttribute(observerKey, 'visited') !== true) {
                                observer.deleteObservable();
                            }
                        }
                    // - If the observable is not a parent-child line, just delete any attached lines
                    } else if (observer.isLine()) { 
                        if (this.#graph.getNodeAttribute(observerKey, 'visited') !== true) {
                            observer.deleteObservable();
                        }
                    }
                });
            }
            this.#graph.dropNode(observableKey);
            this.#removeObservableFromNameToKey(observable, observable.getProperty('name'));
            this.#removeObservableFromKeytoFeature(observable);
            this.#observers.forEach(ob => ob.handleDeletedObservable(observable));
        } else {
            // - No need to throw error. It's probably the case that a parent child line has already been deleted and the code is trying to delete it again
            //throw new FeatureNotFoundError(observableKey);
        }
    }

    /**
     *
     */
    handleNewObservable(observable) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        throw new UnsupportedOperationError();
    }

    /**
     * - Update this ObserverInterface instance (i.e. "this") based on the coordinates of the ObservableInterface instance (i.e. "observable") that
     *   have just changed and perform other actions as needed
     *  - E.g. update the line observer's coordinates to match the node observable's coordinates if the line was connected to the node
     * @param {Object} observable - an instance of ObservableInterface that this Observer is observing
     * @param {Array} oldCoordinates - the old coordinates of the observable prior to the change in coordinates
     * @returns {undefined}
     */
    handleUpdatedCoordinates(observable, oldCoordinates) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(oldCoordinates instanceof Array)) {
            throw TypeError('The "oldCoordinates" argument must be an array.')
        }
        const observableKey = observable.getProperty('treeKey', 'meta');
        // - Mark this node as visited to prevent infinite recursion
        this.#graph.setNodeAttribute(observableKey, 'visited', true);
        // - Redraw attached lines. That's all I need to do for now
        if (this.#graph.hasNode(observableKey)) {
            this.#graph.edges(observableKey).forEach(edgeKey => {
                const observerKey = this.#getObserverKey(observableKey, edgeKey);                
                const observer = this.getObservable(observerKey);
                if (this.#graph.getNodeAttribute(observerKey, 'visited') !== true) {
                    if (observer.isLine()) {
                        observer.handleUpdatedCoordinates(observable, oldCoordinates);
                    } else if (observable.isNode() && observer.isNode()) {
                        throw new GraphNodeEdgeError(observableKey, observerKey);
                    }
                }
            });
            this.updateCoordinatesOfObservers(oldCoordinates);
        } else {
            throw new FeatureNotFoundError(observableKey);
        }
    }

    /**
     * - Update this ObserverInstance (i.e. "this") based on the property of the ObservableInterface instance (i.e. "observable") that has just
     *   changed and perform other actions as needed
     *  - E.g. update this line's "to" and/or "from" property to match the "name" property of the node that was just changed
     * @param {Object} observable - the observable that this observer is observing
     * @param {string} propertyKey - the property key of the property that has been created/changed/deleted in the observable
     * @param {(string|Object)} oldPropertyValue - the previous value of the property that has been created/changed/deleted in the observable
     * @param {string} namespace - the namespace of the property that has been created/changed/deleted in the observable
     * @returns {undefined}
     */
    handleUpdatedProperty(observable, propertyKey, oldPropertyValue, namespace='treeProps') {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (typeof propertyKey !== 'string') {
            throw TypeError('The "propertyKey" argument must be a string.');
        }
        if (typeof namespace !== 'string') {
            throw TypeError('The "namespace" argument must be a string.');
        }
        const observableKey = observable.getProperty('treeKey', 'meta');
        // - I don't think I need to mark nodes as visited since there's no recursion
        //this.#graph.setNodeAttribute(observableKey, 'visited', true);
        if (this.#graph.hasNode(observableKey)) {
            // - Deal with property updates that don't affect the connectivity of the graph
            if (propertyKey === 'name') {
                this.#removeObservableFromNameToKey(observable, oldPropertyValue);
                this.#insertObservableIntoNameToKey(observable);
                this.#graph.forEachNode((node, attributes) => {
                    this.getObservable(node).handleUpdatedProperty(observable, propertyKey, oldPropertyValue, namespace);
                });    
            // - Deal with property updates that affect the connectivity of the graph
            } else if (['from', 'to', 'parent'].includes(propertyKey)) {
                for (const edgeKey of this.#graph.edges(observableKey)) {
                    const observer1Key = this.#getObserverKey(observableKey, edgeKey);
                    const observer1 = this.getObservable(observer1Key);
                    // - If true, observable is a line and observer1 is one of the two nodes that is connected to it
                    if (['from', 'to'].includes(propertyKey)) {
                        if (oldPropertyValue === observer1.getProperty('name')) {
                            this.#graph.dropEdge(edgeKey);
                            this.#graph.addEdge(observableKey, this.getKey(observable.getProperty(propertyKey), observableKey));
                            // - For most lines, this break won't do anything since "from" and "to" are not the same so only one observer's name will
                            //   match the oldPropertyValue
                            // - For lines whose "from" and "to" values are the same, this break is necessary because without it, changing either "from"
                            //   or "to" of the looped line will make the graph drop all edges between the line and the node when only one edge should be
                            //   dropped
                            break;
                        }
                    }
                    // - If true, observable is a child node and observer1 is the line that connects the child and the parent
                    if (propertyKey === 'parent') {
                        // - Currently, nodes can only have a single parent, so I don't have to deal with multiple parent-child lines going to one
                        //   (child) node. That means that this entire if-statement below should only execute one time even though the outer for-loop
                        //   continues to run once edges are dropped and added
                        if (observer1.isParentChildLine()) {
                            for (const edgeKey2 of this.#graph.edges(observer1Key)) {
                                const observer2Key = this.#getObserverKey(observer1Key, edgeKey2);
                                const observer2 = this.getObservable(observer2Key);
                                // - If true, observer2 is the old parent node
                                if (oldPropertyValue === observer2.getProperty('name')) {
                                    this.#graph.dropEdge(edgeKey2);
                                    this.#graph.addEdge(observer1Key, this.getKey(observable.getProperty(propertyKey), observer1Key));
                                    // - I need to update the parent-child line to have the correct "from" and "to" treeProps properties 
                                    ['from', 'to'].forEach(prop => {
                                        if (observer1.getProperty(prop) === oldPropertyValue) {
                                            observer1.setProperty(prop, observable.getProperty(propertyKey));
                                        }
                                    });
                                    // - Break in case a node has its own name as a parent and I just changed the "parent" value?
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            this.updatePropertyOfObservers(propertyKey, oldPropertyValue, namespace);
        } else {
            throw new FeatureNotFoundError(observableKey);
        }
    }

    // ********************
    // ** Public methods ** 
    // ********************

    /**
     * - TODO: could I have a single getKey() function for features and components that takes the "object" property of the requesting feature, instead
     *   of requesting the entire feature?
     * @param {string} name - the name of the feature that I want to retrieve the key for
     * @param {string} featureKey - the key of an instance of my Feature class that is requesting the key
     * @returns {string} The correct tree key of the feature with the given name, depending on which object requested it, else throw an exception if
     *      there is no matching tree key
     */
    getKey(name, featureKey) {
        if (typeof name !== 'string') {
            throw TypeError('The "name" argument must be typeof string.');
        }
        if (typeof featureKey !== 'string') {
            throw TypeError('The "feature" argument must be typeof string.');
        }
        const feature = this.getObservable(featureKey);
        const keys = this.#nameToKey[name];
        if (keys === undefined) {
            throw new FeatureNameNotFoundError(name);
        } else if (keys.length === 1) {
            return keys[0];
        }
        // - For recorders, return the first line with the given name. Is this right?
        const objectsWithLineParents = ['recorder'];
        if (objectsWithLineParents.includes(feature.getProperty('object'))) {
            const lineKeys = keys.filter(k => this.getObservable(k).isLine());
            if (lineKeys.length === 1) {
                return lineKeys[0];
            } else {
                throw Error(`This FeatureGraph could not unambiguously find a line for the object named "${feature.getProperty('name')}".`);
            }
        } else {
            const nodeKeys = keys.filter(k => this.getObservable(k).isNode());
            if (nodeKeys.length === 1) {
                return nodeKeys[0];
            } else {
                //throw Error(`This FeatureGraph could not unambiguously find a node for the object named "${feature.getProperty('name')}".`);
                // - HACK (David): How to deal with circuit vs. bus object with same name, or duplicate bus objects with same name?
                //  - Always assume that the line or child wants the "bus" object, not the "circuit" object
                //  - If two buses have identical names, just choose the first bus arbitrarily
                const busKeys = nodeKeys.filter(k => this.getObservable(k).getProperty('object') === 'bus');
                if (busKeys.length > 0) {
                    return busKeys[0];
                } else {
                    // - In really weird situations, such as a case of multiple circuit objects with the same name, just return the first object
                    return nodeKeys[0];
                }
            }
        }
    }

    /**
     * @param {string} name - the name of the feature that I want to retrieve the key for
     * @returns {string} The correct tree key of the feature with the given name. If there are multiple keys, return the first one. Throw an exception
     * if there is no matching tree key.
     */
    getKeyForComponent(name) {
        if (typeof name !== 'string') {
            throw TypeError('The "name" argument must be a string.');
        }
        const keys = this.#nameToKey[name];
        if (keys === undefined) {
            throw new FeatureNameNotFoundError(name);
        } else {
            return keys[0];
        }
    }

    /**
     * @param {string} sourceKey - the key of an instance of my Feature class that has a line going from it (i.e. the parent)
     * @param {string} targetKey - the key of an instance of my Feature class that has a line going to it (i.e. the child)
     * @returns {Object} An object containing floating-point values for "sourceLat", "sourceLon", "targetLat", "targetLon"
     */
    getLineLatLon(sourceKey, targetKey) {
        let sourceLon, sourceLat, targetLon, targetLat;
        for (let i = 0; i < arguments.length; i++) {
            const observable = this.getObservable(arguments[i]);
            const coordinates = observable.getCoordinates();
            // - TODO: round coordinates?
            let lon, lat;
            if (observable.isLine()) {
                lon = (coordinates[0][0] + coordinates[1][0]) / 2;
                lat = (coordinates[0][1] + coordinates[1][1]) / 2;
            } else if (observable.isNode()) {
                lon = coordinates[0];
                lat = coordinates[1];
            } else {
                throw TypeError(`The feature "${observable.getProperty('name')}" is neither a line nor a node.`);
            }
            if (i === 0) {
                sourceLon = lon;
                sourceLat = lat;
            } else if (i === 1) {
                targetLon = lon;
                targetLat = lat;
            }
        }
        return {
            'sourceLat': sourceLat,
            'sourceLon': sourceLon,
            'targetLat': targetLat,
            'targetLon': targetLon
        }
    }

    /**
     * @param {string} namespace - the namespace of keys I'm interested in (e.g. "default" for normal keys and "parentChild" for parent-child lines)
     * @returns {number} the current maximum tree key in this FeatureGraph
     */
    getMaxKey(namespace='default') {
        let keys = [];
        for (let k of Object.keys(this.#keyToFeature)) {
            if (namespace === 'default') {
                k = +k;
                if (!isNaN(k)) {
                    keys.push(k);
                }
            } else if (['parentChild'].includes(namespace)) {
                if (k.startsWith(namespace)) {
                    k = +k.split(':')[1];
                    if (!isNaN(k)) {
                        keys.push(k);
                    }
                }
            } else {
                throw ReferenceError(`The key namespace "${namespace}" does not exist in this FeatureGraph. Leave the "namespace" argument empty to use the "default" key namespace.`);
            }
        }
        // Math.max.apply(null, []) === -Infinity, so I start with 0
        if (keys.length === 0) {
            keys = [0];
        }
        return Math.max.apply(null, keys);
    }

    /**
     * @param {string} childKey - the treeKey of the child that I want the line for
     * @returns {Feature} - the parent-child line of the child
     */
    getParentChildLine(childKey) {
        if (this.#graph.hasNode(childKey)) {
            for (const edgeKey of this.#graph.edges(childKey)) {
                const observerKey = this.#getObserverKey(childKey, edgeKey);
                const observer = this.getObservable(observerKey);
                if (observer.isLine()) {
                    // - Currently, a node can only have a single parent, so I don't need to check any other properties of either object to confirm
                    //   that this is the correct parent-child line
                    if (observer.isParentChildLine()) {
                        return observer;
                    }
                } else {
                    throw new GraphNodeEdgeError(childKey, observerKey);
                }
            }
        } else {
            throw new FeatureNotFoundError(childKey);
        }
        throw Error(`A parent-child line could not be found for the feature "${childKey}".`);
    }

    /**
     * @param {string} parentKey - the key of an instance of my Feature class
     * @param {string} childKey - the key of an instance of my Feature class
     * @returns {Feature} - an instance of my Feature class
     */
    getParentChildLineFeature(parentKey, childKey) {
        const {sourceLat, sourceLon, targetLat, targetLon} = this.getLineLatLon(parentKey, childKey);
        const parentChildLineKey = `parentChild:${this.getMaxKey('parentChild') + 1}`;
        const parentName = this.getObservable(parentKey).getProperty('name');
        const childName = this.getObservable(childKey).getProperty('name');
        const parentChildLineFeature = new Feature({
            geometry: {
                coordinates: [[sourceLon, sourceLat], [targetLon, targetLat]],
                type: 'LineString'
            },
            properties: {
                treeKey: parentChildLineKey,
                treeProps: {
                    object: 'line',
                    name: parentChildLineKey,
                    phases: 1,
                    type: 'parentChild',
                    from: parentName,
                    to: childName
                }
            },
            type: 'Feature'
        });
        return parentChildLineFeature;
    }

    /**
     * - This function accepts an ObservableInterface instance, rather than a basic GeoJSON feature, because I need to rely on the ObservableInterface
     *   API for getting properties. I don't want to assume I'll always be working with true GeoJSON features. All nodes must be inserted before all
     *   lines. If a line is inserted and its nodes don't exist, a ReferencError is thrown.
     * @param {Feature} observable - an ObservableInterface instance
     * @returns {undefined}
     */
    insertObservable(observable) {
        if (!(observable instanceof Feature)) {
            throw TypeError('The "observable" argument must be an instance of Feature class.');
        }
        this.#insertObservableIntoKeyToFeature(observable);
        const observableKey = observable.getProperty('treeKey', 'meta');
        this.#graph.addNode(observableKey);
        // - Insert the feature into the nameToKey map
        // - The following objects SOMETIMES lack the "name" property: recorder, player, and sometimes other regular objects!
        //  - By far, the easiest thing to do is give them a name. I can strip it out on export if needed
        if (!observable.hasProperty('name')) {
            if (observable.hasProperty('object')) {
                const object = observable.getProperty('object');
                if (['recorder', 'player'].includes(object) || !observable.isConfigurationObject()) {
                    const name = `${object}:${observableKey}:addedName`;
                    observable.setProperty('name', name);
                }
            }
        }
        // - !CMD objects need to be able to have the same command, but the name of the !CMD object is the command. Get around this by creating a new
        //   "CMD_command" property whose value replaces the "name" property value on export
        if (observable.hasProperty('object')) {
            const object = observable.getProperty('object');
            if (object === '!CMD') {
                observable.setProperty('CMD_command', observable.getProperty('name'));
                const name = `${object}:${observableKey}:addedName`;
                observable.setProperty('name', name);
            }
        }
        // - Give the feature a pointer to this graph, which effectively makes the feature Observable to all other features and an Observer of all
        //   other features. This needs to be set after recorders and players are given names
        observable.setGraph(this);
        // - Configuration objects aren't pointed to by "to", "from", or "parent", so they don't need names
        this.#insertObservableIntoNameToKey(observable);
        // - Insert the feature into the actual graph
        //  - This logic assumes the following insertion order: (1) all nodes nodes, (2) all lines
        //  - Parent-child lines must be created and inserted with the other lines. They are not automatically created here
        // - All nodes and all lines are treated as nodes in the graph.
        //  - E.g. a node and two lines are modeled as three nodes, one of which (the actual node) is connected via edges to the other two (line)
        //    nodes
        if (observable.isLine()) {
            const sourceName = observable.getProperty('from');
            const sourceKey = this.getKey(sourceName, observableKey);
            // - <Graph>.addEdge() does throw an error for non-existent nodes, which is what I want
            this.#graph.addEdge(sourceKey, observableKey);
            const targetName = observable.getProperty('to');
            const targetKey = this.getKey(targetName, observableKey);
            this.#graph.addEdge(observableKey, targetKey);
            const sourceObservable = this.getObservable(sourceKey);
            //const targetObservable = this.getObservable(targetKey);
            if (sourceObservable.isChild()) {
                if (sourceObservable.getProperty('parent') === targetName) {
                    // - If these conditions are met, this line (which is modeled as a node in this graph) has "from" and "to" mixed up and I need to
                    //   check my parent-child line creation code
                    throw Error(`Parent-child lines should always go from parent (source) to child (target), but the line "${observableKey}" has a source node "${sourceKey}" that is a child.`);
                }
                // - If both conditions are not met, then this line is not a parent-child line, but it is connected to a node that is also a child
                //   node (with a separate parent-child line). This is weird but valid.
            }
            // - I don't need to add a special "isParentChild" attribute to edges anymore. When I inspect the node neighbors of a graph node, all the
            //   information about whether the neighbor node is a another node, a line, a parent-child line, etc. is already present in the
            //   ObservableInterface instance
        }
        this.notifyObserversOfNewObservable(observable);
    }

    /**
     * - Mark all nodes as unvisted. The ObservableController instance needs to call this function after calling <Observable>.setCoordinates()
     * @returns {undefined}
     */
    markNodesAsUnvisited() {
        this.#graph.forEachNode((node, attrs) => {
            this.#graph.setNodeAttribute(node, 'visited', false);
        });
    }

    // *********************
    // ** Private methods ** 
    // *********************

    /**
     * - Return the ID of the graph node attached to the edge, as long as the ID != observableKey
     *  - E.g. if I'm examining the edge between a node and a line, and the node was changed, I don't want to be given back the node ID. I want the
     *    line ID
     * @param {string} observableKey - the ID of the ObservableInterface instance that changed in some way
     * @param {string} edgeKey - The edge ID of one edge that is connected to the graph node that represents the ObservableInterface instance
     */
    #getObserverKey(observableKey, edgeKey) {
        const sourceKey = this.#graph.source(edgeKey);
        const targetKey = this.#graph.target(edgeKey);
        if (sourceKey === targetKey) {
            throw Error(`This FeatureGraph instance does not allow self-loops, but one exists on node "${sourceKey}".`);
        }
        if (sourceKey !== observableKey) {
            return sourceKey;
        } else {
            return targetKey;
        }
    }

    /**
     * 
     */
    #insertObservableIntoKeyToFeature(observable) {
        const observableKey = observable.getProperty('treeKey', 'meta');
        if (this.#keyToFeature.hasOwnProperty(observableKey)) {
            throw Error(`The key "${observableKey}" already exists in this.#keyToFeature.`);
        }
        this.#keyToFeature[observableKey] = observable;
    }

    /**
     * - Insert an ObservableInterface instance into the nameToKey map
     * @param {Feature} observable - an ObservableInterface instance
     * @returns {undefined}
     */
    #insertObservableIntoNameToKey(observable) {
        const key = observable.getProperty('treeKey', 'meta');
        if (observable.hasProperty('name')) {
            const name = observable.getProperty('name');
            if (!this.#nameToKey.hasOwnProperty(name)) {
                this.#nameToKey[name] = [key];
            } else {
                if (this.#nameToKey[name].includes(key)) {
                    throw Error(`The key "${key}" is already mapped to the name "${name}".`);
                }
                this.#nameToKey[name].push(key);
            }
        }
    }

    /**
     *
     */
    #removeObservableFromKeytoFeature(observable) {
        const observableKey = observable.getProperty('treeKey', 'meta');
        if (this.#keyToFeature.hasOwnProperty(observableKey)) {
            delete this.#keyToFeature[observableKey];
        } else {
            throw Error(`The key "${observableKey}" does not exist in this.#keyToFeature.`);
        }
    }

    /**
     * - Remove an ObservableInterface instance from the nameToKey map
     * @param {Feature} observable - an ObservableInterface instance
     * @param {string} oldName - the previous name of the ObservableInterface instance
     * @returns {undefined}
     */
    #removeObservableFromNameToKey(observable, oldName) {
        if (!(observable instanceof Feature)) {
            throw TypeError('The "observable" argument must be an instanceof Feature');
        }
        if (typeof oldName !== 'string') {
            throw TypeError('The "oldName" argument must be a string.');
        }
        const key = observable.getProperty('treeKey', 'meta');
        // - The "name" property cannot be deleted from ObservableInterface instances, so I shouldn't have to deal with a situation where an
        //   observable no longer has a name but its old name is still in this.#nameToKey
        if (observable.hasProperty('name')) {
            if (!this.#nameToKey.hasOwnProperty(oldName)) { 
                // - This function should throw an exception if the ObservableInterface instance's name never existed in this.#nameToKey because that
                //   would only happen if an object that never had a name has been given a name, which isn't allowed (actually recorders and players
                //   are given names
                throw Error(`The name "${oldName}" does not exist in the this.#nameToKey.`);
            }
            if (this.#nameToKey[oldName].includes(key)) {
                this.#nameToKey[oldName] = this.#nameToKey[oldName].filter(k => k !== key);
                if (this.#nameToKey[oldName].length === 0) {
                    delete this.#nameToKey[oldName];
                }
            } else {
                throw Error(`The name "${oldName}" exists in this.#nameToKey, but the key "${key}" does not exist in the array for that name.`);
            }
        }
    }
}

class FeatureNotFoundError extends Error {

    constructor(key) {
        // - After this call to the Error constructor, "message" is undefined but that's okay because I set it immediately after
        super();
        this.message = `This FeatureGraph instance does not have a graph node with the key "${key}".`;
        this.name = 'FeatureNotFoundError';
    }
}

class FeatureNameNotFoundError extends Error {

    constructor(name) {
        super();
        this.message = `This FeatureGraph instance could not find a key for the object named "${name}".`;
        this.name = 'FeatureNameNotFoundError';
    }
}

class GraphNodeEdgeError extends Error {
    
    constructor(node1Key, node2Key) {
        super();
        this.message = `This FeatureGraph instance does not currently support edges between nodes, but an edge exists between nodes "${node1Key}" and "${node2Key}".`;
        this.name = 'GraphNodeEdgeError';
    }
}
</script>
<script>
"use strict";

// - Test data can be found at omf/scratch/CIGAR/geoJsonLeaflet

class GeojsonModal { // implements ModalInterface, ObserverInterface
    #controller;            // - ControllerInterface instance
    #filenameToLayerGroup;  // - Container for LayerGroups
    #modal;                 // - Modal instance
    #observables;           // - An array of ObservableInterface instances
    #removed;               // - Whether this ColorModal instance has already been deleted

    /**
     * @param {Array} observables - an array of ObservableInterface instances 
     * @param {FeatureController} controller - a ControllerInterface instance
     */
    constructor(observables, controller) {
        if (!(observables instanceof Array)) {
            throw TypeError('The "observables" argumnet must be instanceof Array.');
        }
        if (!(controller instanceof FeatureController)) {
            throw Error('The "controller" argument must be instanceof FeatureController.');
        }
        this.#controller = controller;
        this.#filenameToLayerGroup = {};
        this.#modal = null;
        this.#observables = observables;
        this.#observables.forEach(ob => ob.registerObserver(this));
        this.#removed = false;
        this.renderContent();
        this.refreshContent();
    }

    // *******************************
    // ** ObserverInterface methods **
    // *******************************

    /**
     * - Remove this ObserverInterface instance (i.e. "this") from the ObservableInterface instance (i.e. "observable") that has been deleted, and
     *   perform other actions as needed
     * @param {Feature} observable - an ObservableInterface instance
     * @returns {undefined}
     */
    handleDeletedObservable(observable) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('The "observable" argument must be instanceof Feature.');
        }
        if (!this.#removed) {
            observable.removeObserver(this);
            const index = this.#observables.indexOf(observable);
            if (index > -1) {
                this.#observables.splice(index, 1);
            } else {
                throw Error('The observable was not found in this.#observables.');
            }
            if (this.#observables.length === 0) {
                this.remove();
            } else {
                this.#updateLayerGroups();
                this.refreshContent();
            }
        }
    }

    /**
     *
     */
    handleNewObservable(observable) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        throw new UnsupportedOperationError();
    }

    /**
     * - Update this ObserverInterface instance (i.e. "this") based on the coordinates of the ObservableInterface instance (i.e. "observable") that
     *   have just changed and perform other actions as needed
     * @param {Feature} observable - an ObservableInterface instance
     * @param {Array} oldCoordinates - the old coordinates of the observable prior to the change in coordinates
     * @returns {undefined}
     */
    handleUpdatedCoordinates(observable, oldCoordinates) {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('The "observable" argument must be instanceof Feature.');
        }
        if (!(oldCoordinates instanceof Array)) {
            throw TypeError('The "oldCoordinates" argument must be an array.');
        }
        this.#updateLayerGroups();
        this.refreshContent();
    }

    /**
     * - Update this ObserverInstance (i.e. "this") based on the property of the ObservableInterface instance (i.e. "observable") that has just
     *   changed and perform other actions as needed
     * @param {Feature} observable - an ObservableInterface instance
     * @param {string} propertyKey - the property key of the property that has been created/changed/deleted in the observable
     * @param {(string|Object)} oldPropertyValue - the previous value of the property that has been created/changed/deleted in the observable
     * @param {string} namespace - the namespace of the property that has been created/changed/deleted in the observable
     * @returns {undefined}
     */
    handleUpdatedProperty(observable, propertyKey, oldPropertyValue, namespace='treeProps') {
        // - The function signature above is part of the ObserverInterface API. The implementation below is not
        if (!(observable instanceof Feature)) {
            throw TypeError('The "observable" argument must be instanceof Feature.');
        }
        if (typeof propertyKey !== 'string') {
            throw TypeError('The "propertyKey" argument must be a string.');
        }
        if (typeof namespace !== 'string') {
            throw TypeError('The "namespace" argument must be a string.');
        }
        this.#updateLayerGroups();
        this.refreshContent();
    }

    // ****************************
    // ** ModalInterface methods **
    // ****************************

    getDOMElement() {
        return this.#modal.divElement;
    }

    /**
     * @returns {boolean}
     */
    isRemoved() {
        return this.#removed;
    }

    // - Go through the attachments object and display existing GeoJSON files

    /**
     * @returns {undefined}
     */
    refreshContent() {
        const fileListModal = new Modal();
        fileListModal.addStyleClasses(['colorModal'], 'divElement');
        if (Object.values(this.#filenameToLayerGroup).length > 0) {
            fileListModal.insertTHeadRow(['Filename', 'Show GeoJSON on Page Load']);
            fileListModal.addStyleClasses(['centeredTable'], 'tableElement');
        }
        const that = this;
        const attachments = this.#controller.observableGraph.getObservable('omd').getProperty('attachments', 'meta');
        for (const filename of Object.keys(this.#filenameToLayerGroup)) {
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.name = 'displayOnLoad';
            checkbox.addEventListener('change', function() {
                for (const [fname, obj] of Object.entries(attachments.geojsonFiles)) {
                    if (fname === filename) {
                        if (this.checked) {
                            obj.displayOnLoad = true;
                        } else {
                            delete obj.displayOnLoad
                        }
                    } else {
                        // - Do nothing
                    }
                }
            });
            if (attachments.geojsonFiles[filename].displayOnLoad) {
                checkbox.checked = true;
            }
            const removeButton = document.createElement('button');
            removeButton.classList.add('horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex', 'fullWidth', 'delete');
            const span = document.createElement('span');
            span.textContent = 'Remove';
            removeButton.appendChild(span);
            removeButton.addEventListener('click', function() {
                if (attachments.hasOwnProperty('geojsonFiles')) {
                    delete attachments.geojsonFiles[filename];
                    LeafletLayer.map.removeLayer(that.#filenameToLayerGroup[filename].layerGroup);
                    LeafletLayer.control.removeLayer(that.#filenameToLayerGroup[filename].layerGroup);
                    delete that.#filenameToLayerGroup[filename];
                    if (Object.keys(attachments.geojsonFiles).length === 0) {
                        delete attachments.geojsonFiles;
                    }
                    that.refreshContent();
                }
            });
            fileListModal.insertTBodyRow([filename, checkbox, removeButton]);
        }
        const containerElement = this.#modal.divElement.getElementsByClassName('div--modalElementContainer')[0];
        const oldModal = containerElement.getElementsByClassName('js-div--modal');
        if (oldModal.length === 0) {
            containerElement.prepend(fileListModal.divElement);
        } else {
            oldModal[0].replaceWith(fileListModal.divElement);
        }
    }

    /**
     * @returns {undefined}
     */
    remove() {
        if (!this.#removed) {
            this.#observables.forEach(ob => ob.removeObserver(this));
            this.#observables = null;
            this.#modal.divElement.remove();
            this.#removed = true;
        }
    }

    /**
     * - Render the modal for the first time
     * @returns {undefined}
     */
    renderContent() {
        const modal = new Modal();
        modal.addStyleClasses(['outerModal', 'fitContent'], 'divElement');
        modal.setTitle('Add GeoJSON');
        modal.addStyleClasses(['horizontalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'titleElement');
        const geojsonInput = document.createElement('input');
        geojsonInput.type = 'file';
        geojsonInput.accept = '.geojson';
        geojsonInput.required = true;
        geojsonInput.id = 'geojsonInput';
        const that = this;
        const attachments = this.#controller.observableGraph.getObservable('omd').getProperty('attachments', 'meta');
        geojsonInput.addEventListener('change', async function() {
            const file = this.files[0];
            const text = await file.text();
            let featureCollection;
            try {
                featureCollection = JSON.parse(text);
                that.#modal.setBanner('', ['hidden']);
                if (!attachments.hasOwnProperty('geojsonFiles')) {
                    attachments.geojsonFiles = {};
                }
                attachments.geojsonFiles[file.name] = {
                    json: JSON.stringify(featureCollection)
                }
                that.#updateLayerGroups();
                that.refreshContent();
            } catch (e) {
                that.#modal.showProgress(false, `There was an error "${e.message}" when parsing the JSON file "${file.name}". Please double-check the JSON formatting.`, ['caution']);
            }
        });
        const geojsonLabel = document.createElement('label');
        geojsonLabel.htmlFor = 'geojsonInput';
        geojsonLabel.innerHTML = 'Add a file containing a GeoJSON feature collection (.geojson)';
        modal.insertTBodyRow([geojsonLabel, geojsonInput]);
        modal.addStyleClasses(['centeredTable'], 'tableElement');
        // - Append an empty div so the containerElement isn't null
        const submitDiv = document.createElement('div');
        modal.insertElement(submitDiv);
        if (this.#modal === null) {
            this.#modal = modal;
        }
        if (document.body.contains(this.#modal.divElement)) {
            this.#modal.divElement.replaceWith(modal.divElement);
            this.#modal = modal;
        }
        this.#updateLayerGroups(true);
    }

    // ********************
    // ** Public methods **
    // ********************

    // *********************
    // ** Private methods **
    // *********************

    /**
     * - Iterate through the attachments.geojsonFiles object. For each file, do the following:
     *  - Parse the json string into a GeoJSON featureCollection
     *  - Iterate through the features of the feature collection and create Feature instances and LeafletLayer instances
     *  - Add the LeafletLayer instances to a new LayerGroup that has the same name as the file
     *  - Do not add the Feature instances to a FeatureGraph (at least, not yet)
     *  - Add the LayerGroup to the map
     *      - In order to not keep adding the same features over and over again, here's what I'll do:
     *          - I consider filenames to be unique identifiers for a set of Features/LeafletLayers
     *          - Have a "geojsonFiles" object as a property of this GeojsonModal. Keys are filenames and values are LayerGroup instances. If a file
     *            is deleted, modify the attachments object, remove the LayerGroup from the map, and delete the LayerGroup from the geojsonFiles
     *            object. If a file is added, modify the attachments object, create a new LayerGroup object, add the LeafletLayers to the LayerGroup,
     *            overwrite the geojsonFiles object with the new layer group (and remove the matching LayerGroup from the map if there was one), and
     *            add the new LayerGroup to the map
     * - In this way, the attachments object will be synchronized with the geojsonFiles object. The user will be able to show/hide the LayerGroups via
     *   the normal Leaflet controls
     * - When is this function called? On renderContent(), in response to a file upload, and if a GeoJSON file is edited in the attachments modal
     * @param {boolean} renderContent - whether this function was called on the initial renderContent() call
     * @returns {undefined}
     */
    #updateLayerGroups(renderContent=false) {
        const attachments = this.#controller.observableGraph.getObservable('omd').getProperty('attachments', 'meta');
        if (attachments.hasOwnProperty('geojsonFiles')) {
            const that = this;
            for (const [filename, obj] of Object.entries(attachments.geojsonFiles)) {
                try {
                    const featureCollection = JSON.parse(obj.json);
                    const layerGroup = L.featureGroup();
                    featureCollection.features.map(f => new Feature(f)).map(f => new LeafletLayer(f, that.#controller)).forEach(ll => layerGroup.addLayer(ll.getLayer()));
                    if (this.#filenameToLayerGroup.hasOwnProperty(filename)) {
                        LeafletLayer.map.removeLayer(that.#filenameToLayerGroup[filename].layerGroup);
                        LeafletLayer.control.removeLayer(that.#filenameToLayerGroup[filename].layerGroup);
                    }
                    this.#filenameToLayerGroup[filename] = {
                        layerGroup: layerGroup,
                    };
                    LeafletLayer.control.addOverlay(layerGroup, filename);
                    if (renderContent) {
                        if (obj.displayOnLoad) {
                            layerGroup.addTo(LeafletLayer.map);
                        }
                    } else {
                        layerGroup.addTo(LeafletLayer.map);
                    }
                } catch (e) {
                    console.log(`The GeoJSON in the attachments object could not be parsed: ${e}`);
                }
            }
        }
    }
}
</script>
<script>
"use strict";

class TopNav {
    navElement;
    #anchor;
    #span;

    constructor(homepageName='<Site Name>', homepageUrl='/') {
        this.navElement = document.createElement('nav');
        this.navElement.classList.add('js-nav--topNav');
        //const button = document.createElement('button');
        //const svg = this.#getHamburgerSvg();
        //button.appendChild(svg);
        //this.navElement.appendChild(button);
        const divPlaceholder = document.createElement('div');
        this.navElement.appendChild(divPlaceholder);
        const div = document.createElement('div');
        this.#anchor = document.createElement('a');
        this.#anchor.setAttribute('href', homepageUrl);
        this.#span = document.createElement('span');
        this.#span.textContent = homepageName;
        this.#anchor.appendChild(this.#span);
        div.appendChild(this.#anchor);
        this.navElement.appendChild(div)
    }

    setHomepageName(val) {
        this.#span.textContent = val;
    }

    setHomepageUrl(val) {
        this.#anchor.setAttribute('href', val);
    }

    #getHamburgerSvg() {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('viewBox', '-2.5 -2.5 15 15');
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M0,1L10,1v1h-10v-1M0,5.5L10,5.5v-1h-10v1M0,9L10,9v-1h-10v1');
        svg.appendChild(path);
        return svg;
    }
}
</script>
<script>
"use strict";
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.graphology = factory());
})(this, (function () { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };
    return _wrapNativeSuper(Class);
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }

  /**
   * Graphology Utilities
   * =====================
   *
   * Collection of helpful functions used by the implementation.
   */

  /**
   * Object.assign-like polyfill.
   *
   * @param  {object} target       - First object.
   * @param  {object} [...objects] - Objects to merge.
   * @return {object}
   */
  function assignPolyfill() {
    var target = arguments[0];
    for (var i = 1, l = arguments.length; i < l; i++) {
      if (!arguments[i]) continue;
      for (var k in arguments[i]) {
        target[k] = arguments[i][k];
      }
    }
    return target;
  }
  var assign = assignPolyfill;
  if (typeof Object.assign === 'function') assign = Object.assign;

  /**
   * Function returning the first matching edge for given path.
   * Note: this function does not check the existence of source & target. This
   * must be performed by the caller.
   *
   * @param  {Graph}  graph  - Target graph.
   * @param  {any}    source - Source node.
   * @param  {any}    target - Target node.
   * @param  {string} type   - Type of the edge (mixed, directed or undirected).
   * @return {string|null}
   */
  function getMatchingEdge(graph, source, target, type) {
    var sourceData = graph._nodes.get(source);
    var edge = null;
    if (!sourceData) return edge;
    if (type === 'mixed') {
      edge = sourceData.out && sourceData.out[target] || sourceData.undirected && sourceData.undirected[target];
    } else if (type === 'directed') {
      edge = sourceData.out && sourceData.out[target];
    } else {
      edge = sourceData.undirected && sourceData.undirected[target];
    }
    return edge;
  }

  /**
   * Checks whether the given value is a plain object.
   *
   * @param  {mixed}   value - Target value.
   * @return {boolean}
   */
  function isPlainObject(value) {
    // NOTE: as per https://github.com/graphology/graphology/issues/149
    // this function has been loosened not to reject object instances
    // coming from other JavaScript contexts. It has also been chosen
    // not to improve it to avoid obvious false positives and avoid
    // taking a performance hit. People should really use TypeScript
    // if they want to avoid feeding subtly irrelvant attribute objects.
    return _typeof(value) === 'object' && value !== null;
  }

  /**
   * Checks whether the given object is empty.
   *
   * @param  {object}  o - Target Object.
   * @return {boolean}
   */
  function isEmpty(o) {
    var k;
    for (k in o) {
      return false;
    }
    return true;
  }

  /**
   * Creates a "private" property for the given member name by concealing it
   * using the `enumerable` option.
   *
   * @param {object} target - Target object.
   * @param {string} name   - Member name.
   */
  function privateProperty(target, name, value) {
    Object.defineProperty(target, name, {
      enumerable: false,
      configurable: false,
      writable: true,
      value: value
    });
  }

  /**
   * Creates a read-only property for the given member name & the given getter.
   *
   * @param {object}   target - Target object.
   * @param {string}   name   - Member name.
   * @param {mixed}    value  - The attached getter or fixed value.
   */
  function readOnlyProperty(target, name, value) {
    var descriptor = {
      enumerable: true,
      configurable: true
    };
    if (typeof value === 'function') {
      descriptor.get = value;
    } else {
      descriptor.value = value;
      descriptor.writable = false;
    }
    Object.defineProperty(target, name, descriptor);
  }

  /**
   * Returns whether the given object constitute valid hints.
   *
   * @param {object} hints - Target object.
   */
  function validateHints(hints) {
    if (!isPlainObject(hints)) return false;
    if (hints.attributes && !Array.isArray(hints.attributes)) return false;
    return true;
  }

  /**
   * Creates a function generating incremental ids for edges.
   *
   * @return {function}
   */
  function incrementalIdStartingFromRandomByte() {
    var i = Math.floor(Math.random() * 256) & 0xff;
    return function () {
      return i++;
    };
  }

  var events = {exports: {}};

  var R = typeof Reflect === 'object' ? Reflect : null;
  var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };
  var ReflectOwnKeys;
  if (R && typeof R.ownKeys === 'function') {
    ReflectOwnKeys = R.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
      return Object.getOwnPropertyNames(target);
    };
  }
  function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
  }
  var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
  };
  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  events.exports = EventEmitter;
  events.exports.once = once;

  // Backwards-compat with node 0.10.x
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._eventsCount = 0;
  EventEmitter.prototype._maxListeners = undefined;

  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  var defaultMaxListeners = 10;
  function checkListener(listener) {
    if (typeof listener !== 'function') {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  }
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function () {
      return defaultMaxListeners;
    },
    set: function (arg) {
      if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
      }
      defaultMaxListeners = arg;
    }
  });
  EventEmitter.init = function () {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
  };

  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
    }
    this._maxListeners = n;
    return this;
  };
  function _getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }
  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  };
  EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
    var doError = type === 'error';
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;

    // If there is no 'error' event listener then throw.
    if (doError) {
      var er;
      if (args.length > 0) er = args[0];
      if (er instanceof Error) {
        // Note: The comments on the `throw` lines are intentional, they show
        // up in Node's output if this results in an unhandled exception.
        throw er; // Unhandled 'error' event
      }
      // At least give some kind of context to the user
      var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
      err.context = er;
      throw err; // Unhandled 'error' event
    }

    var handler = events[type];
    if (handler === undefined) return false;
    if (typeof handler === 'function') {
      ReflectApply(handler, this, args);
    } else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
    }
    return true;
  };
  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
      events = target._events = Object.create(null);
      target._eventsCount = 0;
    } else {
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (events.newListener !== undefined) {
        target.emit('newListener', type, listener.listener ? listener.listener : listener);

        // Re-assign `events` because a newListener handler could have caused the
        // this._events to be assigned to a new object
        events = target._events;
      }
      existing = events[type];
    }
    if (existing === undefined) {
      // Optimize the case of one listener. Don't need the extra array object.
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === 'function') {
        // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        // If we've already got an array, just append.
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }

      // Check for listener leak
      m = _getMaxListeners(target);
      if (m > 0 && existing.length > m && !existing.warned) {
        existing.warned = true;
        // No error code for this since it is a Warning
        // eslint-disable-next-line no-restricted-syntax
        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        ProcessEmitWarning(w);
      }
    }
    return target;
  }
  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
  };
  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0) return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }
  function _onceWrap(target, type, listener) {
    var state = {
      fired: false,
      wrapFn: undefined,
      target: target,
      type: type,
      listener: listener
    };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
  }
  EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  };

  // Emits a 'removeListener' event if and only if the listener was removed.
  EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;
    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else {
        delete events[type];
        if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
      }
    } else if (typeof list !== 'function') {
      position = -1;
      for (i = list.length - 1; i >= 0; i--) {
        if (list[i] === listener || list[i].listener === listener) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }
      if (position < 0) return this;
      if (position === 0) list.shift();else {
        spliceOne(list, position);
      }
      if (list.length === 1) events[type] = list[0];
      if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this;

    // not listening for removeListener, no need to emit
    if (events.removeListener === undefined) {
      if (arguments.length === 0) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      } else if (events[type] !== undefined) {
        if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
      }
      return this;
    }

    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
      var keys = Object.keys(events);
      var key;
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        if (key === 'removeListener') continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners('removeListener');
      this._events = Object.create(null);
      this._eventsCount = 0;
      return this;
    }
    listeners = events[type];
    if (typeof listeners === 'function') {
      this.removeListener(type, listeners);
    } else if (listeners !== undefined) {
      // LIFO order
      for (i = listeners.length - 1; i >= 0; i--) {
        this.removeListener(type, listeners[i]);
      }
    }
    return this;
  };
  function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }
  EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
  };
  EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
  };
  EventEmitter.listenerCount = function (emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };
  EventEmitter.prototype.listenerCount = listenerCount;
  function listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
      var evlistener = events[type];
      if (typeof evlistener === 'function') {
        return 1;
      } else if (evlistener !== undefined) {
        return evlistener.length;
      }
    }
    return 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };
  function arrayClone(arr, n) {
    var copy = new Array(n);
    for (var i = 0; i < n; ++i) copy[i] = arr[i];
    return copy;
  }
  function spliceOne(list, index) {
    for (; index + 1 < list.length; index++) list[index] = list[index + 1];
    list.pop();
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }
  function once(emitter, name) {
    return new Promise(function (resolve, reject) {
      function errorListener(err) {
        emitter.removeListener(name, resolver);
        reject(err);
      }
      function resolver() {
        if (typeof emitter.removeListener === 'function') {
          emitter.removeListener('error', errorListener);
        }
        resolve([].slice.call(arguments));
      }
      eventTargetAgnosticAddListener(emitter, name, resolver, {
        once: true
      });
      if (name !== 'error') {
        addErrorHandlerIfEventEmitter(emitter, errorListener, {
          once: true
        });
      }
    });
  }
  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === 'function') {
      eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
    }
  }
  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === 'function') {
      if (flags.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === 'function') {
      // EventTarget does not have `error` event semantics like Node
      // EventEmitters, we do not listen for `error` events here.
      emitter.addEventListener(name, function wrapListener(arg) {
        // IE does not have builtin `{ once: true }` support so we
        // have to do it manually.
        if (flags.once) {
          emitter.removeEventListener(name, wrapListener);
        }
        listener(arg);
      });
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
  }

  /**
   * Obliterator Iterator Class
   * ===========================
   *
   * Simple class representing the library's iterators.
   */

  /**
   * Iterator class.
   *
   * @constructor
   * @param {function} next - Next function.
   */
  function Iterator$2(next) {
    if (typeof next !== 'function') throw new Error('obliterator/iterator: expecting a function!');
    this.next = next;
  }

  /**
   * If symbols are supported, we add `next` to `Symbol.iterator`.
   */
  if (typeof Symbol !== 'undefined') Iterator$2.prototype[Symbol.iterator] = function () {
    return this;
  };

  /**
   * Returning an iterator of the given values.
   *
   * @param  {any...} values - Values.
   * @return {Iterator}
   */
  Iterator$2.of = function () {
    var args = arguments,
      l = args.length,
      i = 0;
    return new Iterator$2(function () {
      if (i >= l) return {
        done: true
      };
      return {
        done: false,
        value: args[i++]
      };
    });
  };

  /**
   * Returning an empty iterator.
   *
   * @return {Iterator}
   */
  Iterator$2.empty = function () {
    var iterator = new Iterator$2(function () {
      return {
        done: true
      };
    });
    return iterator;
  };

  /**
   * Returning an iterator over the given indexed sequence.
   *
   * @param  {string|Array} sequence - Target sequence.
   * @return {Iterator}
   */
  Iterator$2.fromSequence = function (sequence) {
    var i = 0,
      l = sequence.length;
    return new Iterator$2(function () {
      if (i >= l) return {
        done: true
      };
      return {
        done: false,
        value: sequence[i++]
      };
    });
  };

  /**
   * Returning whether the given value is an iterator.
   *
   * @param  {any} value - Value.
   * @return {boolean}
   */
  Iterator$2.is = function (value) {
    if (value instanceof Iterator$2) return true;
    return typeof value === 'object' && value !== null && typeof value.next === 'function';
  };

  /**
   * Exporting.
   */
  var iterator = Iterator$2;

  var support$1 = {};

  support$1.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== 'undefined';
  support$1.SYMBOL_SUPPORT = typeof Symbol !== 'undefined';

  /**
   * Obliterator Iter Function
   * ==========================
   *
   * Function coercing values to an iterator. It can be quite useful when needing
   * to handle iterables and iterators the same way.
   */
  var Iterator$1 = iterator;
  var support = support$1;
  var ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;
  var SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;
  function iterOrNull(target) {
    // Indexed sequence
    if (typeof target === 'string' || Array.isArray(target) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(target)) return Iterator$1.fromSequence(target);

    // Invalid value
    if (typeof target !== 'object' || target === null) return null;

    // Iterable
    if (SYMBOL_SUPPORT && typeof target[Symbol.iterator] === 'function') return target[Symbol.iterator]();

    // Iterator duck-typing
    if (typeof target.next === 'function') return target;

    // Invalid object
    return null;
  }
  var iter$2 = function iter(target) {
    var iterator = iterOrNull(target);
    if (!iterator) throw new Error('obliterator: target is not iterable nor a valid iterator.');
    return iterator;
  };

  /* eslint no-constant-condition: 0 */

  /**
   * Obliterator Take Function
   * ==========================
   *
   * Function taking n or every value of the given iterator and returns them
   * into an array.
   */
  var iter$1 = iter$2;

  /**
   * Take.
   *
   * @param  {Iterable} iterable - Target iterable.
   * @param  {number}   [n]      - Optional number of items to take.
   * @return {array}
   */
  var take = function take(iterable, n) {
    var l = arguments.length > 1 ? n : Infinity,
      array = l !== Infinity ? new Array(l) : [],
      step,
      i = 0;
    var iterator = iter$1(iterable);
    while (true) {
      if (i === l) return array;
      step = iterator.next();
      if (step.done) {
        if (i !== n) array.length = i;
        return array;
      }
      array[i++] = step.value;
    }
  };

  /**
   * Graphology Custom Errors
   * =========================
   *
   * Defining custom errors for ease of use & easy unit tests across
   * implementations (normalized typology rather than relying on error
   * messages to check whether the correct error was found).
   */
  var GraphError = /*#__PURE__*/function (_Error) {
    _inheritsLoose(GraphError, _Error);
    function GraphError(message) {
      var _this;
      _this = _Error.call(this) || this;
      _this.name = 'GraphError';
      _this.message = message;
      return _this;
    }
    return GraphError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  var InvalidArgumentsGraphError = /*#__PURE__*/function (_GraphError) {
    _inheritsLoose(InvalidArgumentsGraphError, _GraphError);
    function InvalidArgumentsGraphError(message) {
      var _this2;
      _this2 = _GraphError.call(this, message) || this;
      _this2.name = 'InvalidArgumentsGraphError';

      // This is V8 specific to enhance stack readability
      if (typeof Error.captureStackTrace === 'function') Error.captureStackTrace(_assertThisInitialized(_this2), InvalidArgumentsGraphError.prototype.constructor);
      return _this2;
    }
    return InvalidArgumentsGraphError;
  }(GraphError);
  var NotFoundGraphError = /*#__PURE__*/function (_GraphError2) {
    _inheritsLoose(NotFoundGraphError, _GraphError2);
    function NotFoundGraphError(message) {
      var _this3;
      _this3 = _GraphError2.call(this, message) || this;
      _this3.name = 'NotFoundGraphError';

      // This is V8 specific to enhance stack readability
      if (typeof Error.captureStackTrace === 'function') Error.captureStackTrace(_assertThisInitialized(_this3), NotFoundGraphError.prototype.constructor);
      return _this3;
    }
    return NotFoundGraphError;
  }(GraphError);
  var UsageGraphError = /*#__PURE__*/function (_GraphError3) {
    _inheritsLoose(UsageGraphError, _GraphError3);
    function UsageGraphError(message) {
      var _this4;
      _this4 = _GraphError3.call(this, message) || this;
      _this4.name = 'UsageGraphError';

      // This is V8 specific to enhance stack readability
      if (typeof Error.captureStackTrace === 'function') Error.captureStackTrace(_assertThisInitialized(_this4), UsageGraphError.prototype.constructor);
      return _this4;
    }
    return UsageGraphError;
  }(GraphError);

  /**
   * Graphology Internal Data Classes
   * =================================
   *
   * Internal classes hopefully reduced to structs by engines & storing
   * necessary information for nodes & edges.
   *
   * Note that those classes don't rely on the `class` keyword to avoid some
   * cruft introduced by most of ES2015 transpilers.
   */

  /**
   * MixedNodeData class.
   *
   * @constructor
   * @param {string} string     - The node's key.
   * @param {object} attributes - Node's attributes.
   */
  function MixedNodeData(key, attributes) {
    // Attributes
    this.key = key;
    this.attributes = attributes;
    this.clear();
  }
  MixedNodeData.prototype.clear = function () {
    // Degrees
    this.inDegree = 0;
    this.outDegree = 0;
    this.undirectedDegree = 0;
    this.undirectedLoops = 0;
    this.directedLoops = 0;

    // Indices
    this["in"] = {};
    this.out = {};
    this.undirected = {};
  };

  /**
   * DirectedNodeData class.
   *
   * @constructor
   * @param {string} string     - The node's key.
   * @param {object} attributes - Node's attributes.
   */
  function DirectedNodeData(key, attributes) {
    // Attributes
    this.key = key;
    this.attributes = attributes;
    this.clear();
  }
  DirectedNodeData.prototype.clear = function () {
    // Degrees
    this.inDegree = 0;
    this.outDegree = 0;
    this.directedLoops = 0;

    // Indices
    this["in"] = {};
    this.out = {};
  };

  /**
   * UndirectedNodeData class.
   *
   * @constructor
   * @param {string} string     - The node's key.
   * @param {object} attributes - Node's attributes.
   */
  function UndirectedNodeData(key, attributes) {
    // Attributes
    this.key = key;
    this.attributes = attributes;
    this.clear();
  }
  UndirectedNodeData.prototype.clear = function () {
    // Degrees
    this.undirectedDegree = 0;
    this.undirectedLoops = 0;

    // Indices
    this.undirected = {};
  };

  /**
   * EdgeData class.
   *
   * @constructor
   * @param {boolean} undirected   - Whether the edge is undirected.
   * @param {string}  string       - The edge's key.
   * @param {string}  source       - Source of the edge.
   * @param {string}  target       - Target of the edge.
   * @param {object}  attributes   - Edge's attributes.
   */
  function EdgeData(undirected, key, source, target, attributes) {
    // Attributes
    this.key = key;
    this.attributes = attributes;
    this.undirected = undirected;

    // Extremities
    this.source = source;
    this.target = target;
  }
  EdgeData.prototype.attach = function () {
    var outKey = 'out';
    var inKey = 'in';
    if (this.undirected) outKey = inKey = 'undirected';
    var source = this.source.key;
    var target = this.target.key;

    // Handling source
    this.source[outKey][target] = this;
    if (this.undirected && source === target) return;

    // Handling target
    this.target[inKey][source] = this;
  };
  EdgeData.prototype.attachMulti = function () {
    var outKey = 'out';
    var inKey = 'in';
    var source = this.source.key;
    var target = this.target.key;
    if (this.undirected) outKey = inKey = 'undirected';

    // Handling source
    var adj = this.source[outKey];
    var head = adj[target];
    if (typeof head === 'undefined') {
      adj[target] = this;

      // Self-loop optimization
      if (!(this.undirected && source === target)) {
        // Handling target
        this.target[inKey][source] = this;
      }
      return;
    }

    // Prepending to doubly-linked list
    head.previous = this;
    this.next = head;

    // Pointing to new head
    // NOTE: use mutating swap later to avoid lookup?
    adj[target] = this;
    this.target[inKey][source] = this;
  };
  EdgeData.prototype.detach = function () {
    var source = this.source.key;
    var target = this.target.key;
    var outKey = 'out';
    var inKey = 'in';
    if (this.undirected) outKey = inKey = 'undirected';
    delete this.source[outKey][target];

    // No-op delete in case of undirected self-loop
    delete this.target[inKey][source];
  };
  EdgeData.prototype.detachMulti = function () {
    var source = this.source.key;
    var target = this.target.key;
    var outKey = 'out';
    var inKey = 'in';
    if (this.undirected) outKey = inKey = 'undirected';

    // Deleting from doubly-linked list
    if (this.previous === undefined) {
      // We are dealing with the head

      // Should we delete the adjacency entry because it is now empty?
      if (this.next === undefined) {
        delete this.source[outKey][target];

        // No-op delete in case of undirected self-loop
        delete this.target[inKey][source];
      } else {
        // Detaching
        this.next.previous = undefined;

        // NOTE: could avoid the lookups by creating a #.become mutating method
        this.source[outKey][target] = this.next;

        // No-op delete in case of undirected self-loop
        this.target[inKey][source] = this.next;
      }
    } else {
      // We are dealing with another list node
      this.previous.next = this.next;

      // If not last
      if (this.next !== undefined) {
        this.next.previous = this.previous;
      }
    }
  };

  /**
   * Graphology Node Attributes methods
   * ===================================
   */
  var NODE = 0;
  var SOURCE = 1;
  var TARGET = 2;
  var OPPOSITE = 3;
  function findRelevantNodeData(graph, method, mode, nodeOrEdge, nameOrEdge, add1, add2) {
    var nodeData, edgeData, arg1, arg2;
    nodeOrEdge = '' + nodeOrEdge;
    if (mode === NODE) {
      nodeData = graph._nodes.get(nodeOrEdge);
      if (!nodeData) throw new NotFoundGraphError("Graph.".concat(method, ": could not find the \"").concat(nodeOrEdge, "\" node in the graph."));
      arg1 = nameOrEdge;
      arg2 = add1;
    } else if (mode === OPPOSITE) {
      nameOrEdge = '' + nameOrEdge;
      edgeData = graph._edges.get(nameOrEdge);
      if (!edgeData) throw new NotFoundGraphError("Graph.".concat(method, ": could not find the \"").concat(nameOrEdge, "\" edge in the graph."));
      var source = edgeData.source.key;
      var target = edgeData.target.key;
      if (nodeOrEdge === source) {
        nodeData = edgeData.target;
      } else if (nodeOrEdge === target) {
        nodeData = edgeData.source;
      } else {
        throw new NotFoundGraphError("Graph.".concat(method, ": the \"").concat(nodeOrEdge, "\" node is not attached to the \"").concat(nameOrEdge, "\" edge (").concat(source, ", ").concat(target, ")."));
      }
      arg1 = add1;
      arg2 = add2;
    } else {
      edgeData = graph._edges.get(nodeOrEdge);
      if (!edgeData) throw new NotFoundGraphError("Graph.".concat(method, ": could not find the \"").concat(nodeOrEdge, "\" edge in the graph."));
      if (mode === SOURCE) {
        nodeData = edgeData.source;
      } else {
        nodeData = edgeData.target;
      }
      arg1 = nameOrEdge;
      arg2 = add1;
    }
    return [nodeData, arg1, arg2];
  }
  function attachNodeAttributeGetter(Class, method, mode) {
    Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
      var _findRelevantNodeData = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge, add1),
        data = _findRelevantNodeData[0],
        name = _findRelevantNodeData[1];
      return data.attributes[name];
    };
  }
  function attachNodeAttributesGetter(Class, method, mode) {
    Class.prototype[method] = function (nodeOrEdge, nameOrEdge) {
      var _findRelevantNodeData2 = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge),
        data = _findRelevantNodeData2[0];
      return data.attributes;
    };
  }
  function attachNodeAttributeChecker(Class, method, mode) {
    Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
      var _findRelevantNodeData3 = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge, add1),
        data = _findRelevantNodeData3[0],
        name = _findRelevantNodeData3[1];
      return data.attributes.hasOwnProperty(name);
    };
  }
  function attachNodeAttributeSetter(Class, method, mode) {
    Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {
      var _findRelevantNodeData4 = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge, add1, add2),
        data = _findRelevantNodeData4[0],
        name = _findRelevantNodeData4[1],
        value = _findRelevantNodeData4[2];
      data.attributes[name] = value;

      // Emitting
      this.emit('nodeAttributesUpdated', {
        key: data.key,
        type: 'set',
        attributes: data.attributes,
        name: name
      });
      return this;
    };
  }
  function attachNodeAttributeUpdater(Class, method, mode) {
    Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {
      var _findRelevantNodeData5 = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge, add1, add2),
        data = _findRelevantNodeData5[0],
        name = _findRelevantNodeData5[1],
        updater = _findRelevantNodeData5[2];
      if (typeof updater !== 'function') throw new InvalidArgumentsGraphError("Graph.".concat(method, ": updater should be a function."));
      var attributes = data.attributes;
      var value = updater(attributes[name]);
      attributes[name] = value;

      // Emitting
      this.emit('nodeAttributesUpdated', {
        key: data.key,
        type: 'set',
        attributes: data.attributes,
        name: name
      });
      return this;
    };
  }
  function attachNodeAttributeRemover(Class, method, mode) {
    Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
      var _findRelevantNodeData6 = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge, add1),
        data = _findRelevantNodeData6[0],
        name = _findRelevantNodeData6[1];
      delete data.attributes[name];

      // Emitting
      this.emit('nodeAttributesUpdated', {
        key: data.key,
        type: 'remove',
        attributes: data.attributes,
        name: name
      });
      return this;
    };
  }
  function attachNodeAttributesReplacer(Class, method, mode) {
    Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
      var _findRelevantNodeData7 = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge, add1),
        data = _findRelevantNodeData7[0],
        attributes = _findRelevantNodeData7[1];
      if (!isPlainObject(attributes)) throw new InvalidArgumentsGraphError("Graph.".concat(method, ": provided attributes are not a plain object."));
      data.attributes = attributes;

      // Emitting
      this.emit('nodeAttributesUpdated', {
        key: data.key,
        type: 'replace',
        attributes: data.attributes
      });
      return this;
    };
  }
  function attachNodeAttributesMerger(Class, method, mode) {
    Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
      var _findRelevantNodeData8 = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge, add1),
        data = _findRelevantNodeData8[0],
        attributes = _findRelevantNodeData8[1];
      if (!isPlainObject(attributes)) throw new InvalidArgumentsGraphError("Graph.".concat(method, ": provided attributes are not a plain object."));
      assign(data.attributes, attributes);

      // Emitting
      this.emit('nodeAttributesUpdated', {
        key: data.key,
        type: 'merge',
        attributes: data.attributes,
        data: attributes
      });
      return this;
    };
  }
  function attachNodeAttributesUpdater(Class, method, mode) {
    Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
      var _findRelevantNodeData9 = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge, add1),
        data = _findRelevantNodeData9[0],
        updater = _findRelevantNodeData9[1];
      if (typeof updater !== 'function') throw new InvalidArgumentsGraphError("Graph.".concat(method, ": provided updater is not a function."));
      data.attributes = updater(data.attributes);

      // Emitting
      this.emit('nodeAttributesUpdated', {
        key: data.key,
        type: 'update',
        attributes: data.attributes
      });
      return this;
    };
  }

  /**
   * List of methods to attach.
   */
  var NODE_ATTRIBUTES_METHODS = [{
    name: function name(element) {
      return "get".concat(element, "Attribute");
    },
    attacher: attachNodeAttributeGetter
  }, {
    name: function name(element) {
      return "get".concat(element, "Attributes");
    },
    attacher: attachNodeAttributesGetter
  }, {
    name: function name(element) {
      return "has".concat(element, "Attribute");
    },
    attacher: attachNodeAttributeChecker
  }, {
    name: function name(element) {
      return "set".concat(element, "Attribute");
    },
    attacher: attachNodeAttributeSetter
  }, {
    name: function name(element) {
      return "update".concat(element, "Attribute");
    },
    attacher: attachNodeAttributeUpdater
  }, {
    name: function name(element) {
      return "remove".concat(element, "Attribute");
    },
    attacher: attachNodeAttributeRemover
  }, {
    name: function name(element) {
      return "replace".concat(element, "Attributes");
    },
    attacher: attachNodeAttributesReplacer
  }, {
    name: function name(element) {
      return "merge".concat(element, "Attributes");
    },
    attacher: attachNodeAttributesMerger
  }, {
    name: function name(element) {
      return "update".concat(element, "Attributes");
    },
    attacher: attachNodeAttributesUpdater
  }];

  /**
   * Attach every attributes-related methods to a Graph class.
   *
   * @param {function} Graph - Target class.
   */
  function attachNodeAttributesMethods(Graph) {
    NODE_ATTRIBUTES_METHODS.forEach(function (_ref) {
      var name = _ref.name,
        attacher = _ref.attacher;
      // For nodes
      attacher(Graph, name('Node'), NODE);

      // For sources
      attacher(Graph, name('Source'), SOURCE);

      // For targets
      attacher(Graph, name('Target'), TARGET);

      // For opposites
      attacher(Graph, name('Opposite'), OPPOSITE);
    });
  }

  /**
   * Graphology Edge Attributes methods
   * ===================================
   */

  /**
   * Attach an attribute getter method onto the provided class.
   *
   * @param {function} Class         - Target class.
   * @param {string}   method        - Method name.
   * @param {string}   type          - Type of the edge to find.
   */
  function attachEdgeAttributeGetter(Class, method, type) {
    /**
     * Get the desired attribute for the given element (node or edge).
     *
     * Arity 2:
     * @param  {any}    element - Target element.
     * @param  {string} name    - Attribute's name.
     *
     * Arity 3 (only for edges):
     * @param  {any}     source - Source element.
     * @param  {any}     target - Target element.
     * @param  {string}  name   - Attribute's name.
     *
     * @return {mixed}          - The attribute's value.
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function (element, name) {
      var data;
      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new UsageGraphError("Graph.".concat(method, ": cannot find this type of edges in your ").concat(this.type, " graph."));
      if (arguments.length > 2) {
        if (this.multi) throw new UsageGraphError("Graph.".concat(method, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
        var source = '' + element;
        var target = '' + name;
        name = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find an edge for the given path (\"").concat(source, "\" - \"").concat(target, "\")."));
      } else {
        if (type !== 'mixed') throw new UsageGraphError("Graph.".concat(method, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
        element = '' + element;
        data = this._edges.get(element);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find the \"").concat(element, "\" edge in the graph."));
      }
      return data.attributes[name];
    };
  }

  /**
   * Attach an attributes getter method onto the provided class.
   *
   * @param {function} Class       - Target class.
   * @param {string}   method      - Method name.
   * @param {string}   type        - Type of the edge to find.
   */
  function attachEdgeAttributesGetter(Class, method, type) {
    /**
     * Retrieves all the target element's attributes.
     *
     * Arity 2:
     * @param  {any}    element - Target element.
     *
     * Arity 3 (only for edges):
     * @param  {any}     source - Source element.
     * @param  {any}     target - Target element.
     *
     * @return {object}          - The element's attributes.
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function (element) {
      var data;
      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new UsageGraphError("Graph.".concat(method, ": cannot find this type of edges in your ").concat(this.type, " graph."));
      if (arguments.length > 1) {
        if (this.multi) throw new UsageGraphError("Graph.".concat(method, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
        var source = '' + element,
          target = '' + arguments[1];
        data = getMatchingEdge(this, source, target, type);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find an edge for the given path (\"").concat(source, "\" - \"").concat(target, "\")."));
      } else {
        if (type !== 'mixed') throw new UsageGraphError("Graph.".concat(method, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
        element = '' + element;
        data = this._edges.get(element);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find the \"").concat(element, "\" edge in the graph."));
      }
      return data.attributes;
    };
  }

  /**
   * Attach an attribute checker method onto the provided class.
   *
   * @param {function} Class       - Target class.
   * @param {string}   method      - Method name.
   * @param {string}   type        - Type of the edge to find.
   */
  function attachEdgeAttributeChecker(Class, method, type) {
    /**
     * Checks whether the desired attribute is set for the given element (node or edge).
     *
     * Arity 2:
     * @param  {any}    element - Target element.
     * @param  {string} name    - Attribute's name.
     *
     * Arity 3 (only for edges):
     * @param  {any}     source - Source element.
     * @param  {any}     target - Target element.
     * @param  {string}  name   - Attribute's name.
     *
     * @return {boolean}
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function (element, name) {
      var data;
      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new UsageGraphError("Graph.".concat(method, ": cannot find this type of edges in your ").concat(this.type, " graph."));
      if (arguments.length > 2) {
        if (this.multi) throw new UsageGraphError("Graph.".concat(method, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
        var source = '' + element;
        var target = '' + name;
        name = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find an edge for the given path (\"").concat(source, "\" - \"").concat(target, "\")."));
      } else {
        if (type !== 'mixed') throw new UsageGraphError("Graph.".concat(method, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
        element = '' + element;
        data = this._edges.get(element);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find the \"").concat(element, "\" edge in the graph."));
      }
      return data.attributes.hasOwnProperty(name);
    };
  }

  /**
   * Attach an attribute setter method onto the provided class.
   *
   * @param {function} Class         - Target class.
   * @param {string}   method        - Method name.
   * @param {string}   type          - Type of the edge to find.
   */
  function attachEdgeAttributeSetter(Class, method, type) {
    /**
     * Set the desired attribute for the given element (node or edge).
     *
     * Arity 2:
     * @param  {any}    element - Target element.
     * @param  {string} name    - Attribute's name.
     * @param  {mixed}  value   - New attribute value.
     *
     * Arity 3 (only for edges):
     * @param  {any}     source - Source element.
     * @param  {any}     target - Target element.
     * @param  {string}  name   - Attribute's name.
     * @param  {mixed}  value   - New attribute value.
     *
     * @return {Graph}          - Returns itself for chaining.
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function (element, name, value) {
      var data;
      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new UsageGraphError("Graph.".concat(method, ": cannot find this type of edges in your ").concat(this.type, " graph."));
      if (arguments.length > 3) {
        if (this.multi) throw new UsageGraphError("Graph.".concat(method, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
        var source = '' + element;
        var target = '' + name;
        name = arguments[2];
        value = arguments[3];
        data = getMatchingEdge(this, source, target, type);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find an edge for the given path (\"").concat(source, "\" - \"").concat(target, "\")."));
      } else {
        if (type !== 'mixed') throw new UsageGraphError("Graph.".concat(method, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
        element = '' + element;
        data = this._edges.get(element);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find the \"").concat(element, "\" edge in the graph."));
      }
      data.attributes[name] = value;

      // Emitting
      this.emit('edgeAttributesUpdated', {
        key: data.key,
        type: 'set',
        attributes: data.attributes,
        name: name
      });
      return this;
    };
  }

  /**
   * Attach an attribute updater method onto the provided class.
   *
   * @param {function} Class         - Target class.
   * @param {string}   method        - Method name.
   * @param {string}   type          - Type of the edge to find.
   */
  function attachEdgeAttributeUpdater(Class, method, type) {
    /**
     * Update the desired attribute for the given element (node or edge) using
     * the provided function.
     *
     * Arity 2:
     * @param  {any}      element - Target element.
     * @param  {string}   name    - Attribute's name.
     * @param  {function} updater - Updater function.
     *
     * Arity 3 (only for edges):
     * @param  {any}      source  - Source element.
     * @param  {any}      target  - Target element.
     * @param  {string}   name    - Attribute's name.
     * @param  {function} updater - Updater function.
     *
     * @return {Graph}            - Returns itself for chaining.
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function (element, name, updater) {
      var data;
      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new UsageGraphError("Graph.".concat(method, ": cannot find this type of edges in your ").concat(this.type, " graph."));
      if (arguments.length > 3) {
        if (this.multi) throw new UsageGraphError("Graph.".concat(method, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
        var source = '' + element;
        var target = '' + name;
        name = arguments[2];
        updater = arguments[3];
        data = getMatchingEdge(this, source, target, type);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find an edge for the given path (\"").concat(source, "\" - \"").concat(target, "\")."));
      } else {
        if (type !== 'mixed') throw new UsageGraphError("Graph.".concat(method, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
        element = '' + element;
        data = this._edges.get(element);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find the \"").concat(element, "\" edge in the graph."));
      }
      if (typeof updater !== 'function') throw new InvalidArgumentsGraphError("Graph.".concat(method, ": updater should be a function."));
      data.attributes[name] = updater(data.attributes[name]);

      // Emitting
      this.emit('edgeAttributesUpdated', {
        key: data.key,
        type: 'set',
        attributes: data.attributes,
        name: name
      });
      return this;
    };
  }

  /**
   * Attach an attribute remover method onto the provided class.
   *
   * @param {function} Class         - Target class.
   * @param {string}   method        - Method name.
   * @param {string}   type          - Type of the edge to find.
   */
  function attachEdgeAttributeRemover(Class, method, type) {
    /**
     * Remove the desired attribute for the given element (node or edge).
     *
     * Arity 2:
     * @param  {any}    element - Target element.
     * @param  {string} name    - Attribute's name.
     *
     * Arity 3 (only for edges):
     * @param  {any}     source - Source element.
     * @param  {any}     target - Target element.
     * @param  {string}  name   - Attribute's name.
     *
     * @return {Graph}          - Returns itself for chaining.
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function (element, name) {
      var data;
      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new UsageGraphError("Graph.".concat(method, ": cannot find this type of edges in your ").concat(this.type, " graph."));
      if (arguments.length > 2) {
        if (this.multi) throw new UsageGraphError("Graph.".concat(method, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
        var source = '' + element;
        var target = '' + name;
        name = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find an edge for the given path (\"").concat(source, "\" - \"").concat(target, "\")."));
      } else {
        if (type !== 'mixed') throw new UsageGraphError("Graph.".concat(method, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
        element = '' + element;
        data = this._edges.get(element);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find the \"").concat(element, "\" edge in the graph."));
      }
      delete data.attributes[name];

      // Emitting
      this.emit('edgeAttributesUpdated', {
        key: data.key,
        type: 'remove',
        attributes: data.attributes,
        name: name
      });
      return this;
    };
  }

  /**
   * Attach an attribute replacer method onto the provided class.
   *
   * @param {function} Class         - Target class.
   * @param {string}   method        - Method name.
   * @param {string}   type          - Type of the edge to find.
   */
  function attachEdgeAttributesReplacer(Class, method, type) {
    /**
     * Replace the attributes for the given element (node or edge).
     *
     * Arity 2:
     * @param  {any}    element    - Target element.
     * @param  {object} attributes - New attributes.
     *
     * Arity 3 (only for edges):
     * @param  {any}     source     - Source element.
     * @param  {any}     target     - Target element.
     * @param  {object}  attributes - New attributes.
     *
     * @return {Graph}              - Returns itself for chaining.
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function (element, attributes) {
      var data;
      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new UsageGraphError("Graph.".concat(method, ": cannot find this type of edges in your ").concat(this.type, " graph."));
      if (arguments.length > 2) {
        if (this.multi) throw new UsageGraphError("Graph.".concat(method, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
        var source = '' + element,
          target = '' + attributes;
        attributes = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find an edge for the given path (\"").concat(source, "\" - \"").concat(target, "\")."));
      } else {
        if (type !== 'mixed') throw new UsageGraphError("Graph.".concat(method, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
        element = '' + element;
        data = this._edges.get(element);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find the \"").concat(element, "\" edge in the graph."));
      }
      if (!isPlainObject(attributes)) throw new InvalidArgumentsGraphError("Graph.".concat(method, ": provided attributes are not a plain object."));
      data.attributes = attributes;

      // Emitting
      this.emit('edgeAttributesUpdated', {
        key: data.key,
        type: 'replace',
        attributes: data.attributes
      });
      return this;
    };
  }

  /**
   * Attach an attribute merger method onto the provided class.
   *
   * @param {function} Class         - Target class.
   * @param {string}   method        - Method name.
   * @param {string}   type          - Type of the edge to find.
   */
  function attachEdgeAttributesMerger(Class, method, type) {
    /**
     * Merge the attributes for the given element (node or edge).
     *
     * Arity 2:
     * @param  {any}    element    - Target element.
     * @param  {object} attributes - Attributes to merge.
     *
     * Arity 3 (only for edges):
     * @param  {any}     source     - Source element.
     * @param  {any}     target     - Target element.
     * @param  {object}  attributes - Attributes to merge.
     *
     * @return {Graph}              - Returns itself for chaining.
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function (element, attributes) {
      var data;
      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new UsageGraphError("Graph.".concat(method, ": cannot find this type of edges in your ").concat(this.type, " graph."));
      if (arguments.length > 2) {
        if (this.multi) throw new UsageGraphError("Graph.".concat(method, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
        var source = '' + element,
          target = '' + attributes;
        attributes = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find an edge for the given path (\"").concat(source, "\" - \"").concat(target, "\")."));
      } else {
        if (type !== 'mixed') throw new UsageGraphError("Graph.".concat(method, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
        element = '' + element;
        data = this._edges.get(element);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find the \"").concat(element, "\" edge in the graph."));
      }
      if (!isPlainObject(attributes)) throw new InvalidArgumentsGraphError("Graph.".concat(method, ": provided attributes are not a plain object."));
      assign(data.attributes, attributes);

      // Emitting
      this.emit('edgeAttributesUpdated', {
        key: data.key,
        type: 'merge',
        attributes: data.attributes,
        data: attributes
      });
      return this;
    };
  }

  /**
   * Attach an attribute updater method onto the provided class.
   *
   * @param {function} Class         - Target class.
   * @param {string}   method        - Method name.
   * @param {string}   type          - Type of the edge to find.
   */
  function attachEdgeAttributesUpdater(Class, method, type) {
    /**
     * Update the attributes of the given element (node or edge).
     *
     * Arity 2:
     * @param  {any}      element - Target element.
     * @param  {function} updater - Updater function.
     *
     * Arity 3 (only for edges):
     * @param  {any}      source  - Source element.
     * @param  {any}      target  - Target element.
     * @param  {function} updater - Updater function.
     *
     * @return {Graph}            - Returns itself for chaining.
     *
     * @throws {Error} - Will throw if too many arguments are provided.
     * @throws {Error} - Will throw if any of the elements is not found.
     */
    Class.prototype[method] = function (element, updater) {
      var data;
      if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new UsageGraphError("Graph.".concat(method, ": cannot find this type of edges in your ").concat(this.type, " graph."));
      if (arguments.length > 2) {
        if (this.multi) throw new UsageGraphError("Graph.".concat(method, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
        var source = '' + element,
          target = '' + updater;
        updater = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find an edge for the given path (\"").concat(source, "\" - \"").concat(target, "\")."));
      } else {
        if (type !== 'mixed') throw new UsageGraphError("Graph.".concat(method, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
        element = '' + element;
        data = this._edges.get(element);
        if (!data) throw new NotFoundGraphError("Graph.".concat(method, ": could not find the \"").concat(element, "\" edge in the graph."));
      }
      if (typeof updater !== 'function') throw new InvalidArgumentsGraphError("Graph.".concat(method, ": provided updater is not a function."));
      data.attributes = updater(data.attributes);

      // Emitting
      this.emit('edgeAttributesUpdated', {
        key: data.key,
        type: 'update',
        attributes: data.attributes
      });
      return this;
    };
  }

  /**
   * List of methods to attach.
   */
  var EDGE_ATTRIBUTES_METHODS = [{
    name: function name(element) {
      return "get".concat(element, "Attribute");
    },
    attacher: attachEdgeAttributeGetter
  }, {
    name: function name(element) {
      return "get".concat(element, "Attributes");
    },
    attacher: attachEdgeAttributesGetter
  }, {
    name: function name(element) {
      return "has".concat(element, "Attribute");
    },
    attacher: attachEdgeAttributeChecker
  }, {
    name: function name(element) {
      return "set".concat(element, "Attribute");
    },
    attacher: attachEdgeAttributeSetter
  }, {
    name: function name(element) {
      return "update".concat(element, "Attribute");
    },
    attacher: attachEdgeAttributeUpdater
  }, {
    name: function name(element) {
      return "remove".concat(element, "Attribute");
    },
    attacher: attachEdgeAttributeRemover
  }, {
    name: function name(element) {
      return "replace".concat(element, "Attributes");
    },
    attacher: attachEdgeAttributesReplacer
  }, {
    name: function name(element) {
      return "merge".concat(element, "Attributes");
    },
    attacher: attachEdgeAttributesMerger
  }, {
    name: function name(element) {
      return "update".concat(element, "Attributes");
    },
    attacher: attachEdgeAttributesUpdater
  }];

  /**
   * Attach every attributes-related methods to a Graph class.
   *
   * @param {function} Graph - Target class.
   */
  function attachEdgeAttributesMethods(Graph) {
    EDGE_ATTRIBUTES_METHODS.forEach(function (_ref) {
      var name = _ref.name,
        attacher = _ref.attacher;
      // For edges
      attacher(Graph, name('Edge'), 'mixed');

      // For directed edges
      attacher(Graph, name('DirectedEdge'), 'directed');

      // For undirected edges
      attacher(Graph, name('UndirectedEdge'), 'undirected');
    });
  }

  /**
   * Obliterator Chain Function
   * ===========================
   *
   * Variadic function combining the given iterables.
   */
  var Iterator = iterator;
  var iter = iter$2;

  /**
   * Chain.
   *
   * @param  {...Iterator} iterables - Target iterables.
   * @return {Iterator}
   */
  var chain = function chain() {
    var iterables = arguments;
    var current = null;
    var i = -1;

    /* eslint-disable no-constant-condition */
    return new Iterator(function next() {
      var step = null;
      do {
        if (current === null) {
          i++;
          if (i >= iterables.length) return {
            done: true
          };
          current = iter(iterables[i]);
        }
        step = current.next();
        if (step.done === true) {
          current = null;
          continue;
        }
        break;
      } while (true);
      return step;
    });
  };

  /**
   * Graphology Edge Iteration
   * ==========================
   *
   * Attaching some methods to the Graph class to be able to iterate over a
   * graph's edges.
   */

  /**
   * Definitions.
   */
  var EDGES_ITERATION = [{
    name: 'edges',
    type: 'mixed'
  }, {
    name: 'inEdges',
    type: 'directed',
    direction: 'in'
  }, {
    name: 'outEdges',
    type: 'directed',
    direction: 'out'
  }, {
    name: 'inboundEdges',
    type: 'mixed',
    direction: 'in'
  }, {
    name: 'outboundEdges',
    type: 'mixed',
    direction: 'out'
  }, {
    name: 'directedEdges',
    type: 'directed'
  }, {
    name: 'undirectedEdges',
    type: 'undirected'
  }];

  /**
   * Function iterating over edges from the given object to match one of them.
   *
   * @param {object}   object   - Target object.
   * @param {function} callback - Function to call.
   */
  function forEachSimple(breakable, object, callback, avoid) {
    var shouldBreak = false;
    for (var k in object) {
      if (k === avoid) continue;
      var edgeData = object[k];
      shouldBreak = callback(edgeData.key, edgeData.attributes, edgeData.source.key, edgeData.target.key, edgeData.source.attributes, edgeData.target.attributes, edgeData.undirected);
      if (breakable && shouldBreak) return edgeData.key;
    }
    return;
  }
  function forEachMulti(breakable, object, callback, avoid) {
    var edgeData, source, target;
    var shouldBreak = false;
    for (var k in object) {
      if (k === avoid) continue;
      edgeData = object[k];
      do {
        source = edgeData.source;
        target = edgeData.target;
        shouldBreak = callback(edgeData.key, edgeData.attributes, source.key, target.key, source.attributes, target.attributes, edgeData.undirected);
        if (breakable && shouldBreak) return edgeData.key;
        edgeData = edgeData.next;
      } while (edgeData !== undefined);
    }
    return;
  }

  /**
   * Function returning an iterator over edges from the given object.
   *
   * @param  {object}   object - Target object.
   * @return {Iterator}
   */
  function createIterator(object, avoid) {
    var keys = Object.keys(object);
    var l = keys.length;
    var edgeData;
    var i = 0;
    return new iterator(function next() {
      do {
        if (!edgeData) {
          if (i >= l) return {
            done: true
          };
          var k = keys[i++];
          if (k === avoid) {
            edgeData = undefined;
            continue;
          }
          edgeData = object[k];
        } else {
          edgeData = edgeData.next;
        }
      } while (!edgeData);
      return {
        done: false,
        value: {
          edge: edgeData.key,
          attributes: edgeData.attributes,
          source: edgeData.source.key,
          target: edgeData.target.key,
          sourceAttributes: edgeData.source.attributes,
          targetAttributes: edgeData.target.attributes,
          undirected: edgeData.undirected
        }
      };
    });
  }

  /**
   * Function iterating over the egdes from the object at given key to match
   * one of them.
   *
   * @param {object}   object   - Target object.
   * @param {mixed}    k        - Neighbor key.
   * @param {function} callback - Callback to use.
   */
  function forEachForKeySimple(breakable, object, k, callback) {
    var edgeData = object[k];
    if (!edgeData) return;
    var sourceData = edgeData.source;
    var targetData = edgeData.target;
    if (callback(edgeData.key, edgeData.attributes, sourceData.key, targetData.key, sourceData.attributes, targetData.attributes, edgeData.undirected) && breakable) return edgeData.key;
  }
  function forEachForKeyMulti(breakable, object, k, callback) {
    var edgeData = object[k];
    if (!edgeData) return;
    var shouldBreak = false;
    do {
      shouldBreak = callback(edgeData.key, edgeData.attributes, edgeData.source.key, edgeData.target.key, edgeData.source.attributes, edgeData.target.attributes, edgeData.undirected);
      if (breakable && shouldBreak) return edgeData.key;
      edgeData = edgeData.next;
    } while (edgeData !== undefined);
    return;
  }

  /**
   * Function returning an iterator over the egdes from the object at given key.
   *
   * @param  {object}   object   - Target object.
   * @param  {mixed}    k        - Neighbor key.
   * @return {Iterator}
   */
  function createIteratorForKey(object, k) {
    var edgeData = object[k];
    if (edgeData.next !== undefined) {
      return new iterator(function () {
        if (!edgeData) return {
          done: true
        };
        var value = {
          edge: edgeData.key,
          attributes: edgeData.attributes,
          source: edgeData.source.key,
          target: edgeData.target.key,
          sourceAttributes: edgeData.source.attributes,
          targetAttributes: edgeData.target.attributes,
          undirected: edgeData.undirected
        };
        edgeData = edgeData.next;
        return {
          done: false,
          value: value
        };
      });
    }
    return iterator.of({
      edge: edgeData.key,
      attributes: edgeData.attributes,
      source: edgeData.source.key,
      target: edgeData.target.key,
      sourceAttributes: edgeData.source.attributes,
      targetAttributes: edgeData.target.attributes,
      undirected: edgeData.undirected
    });
  }

  /**
   * Function creating an array of edges for the given type.
   *
   * @param  {Graph}   graph - Target Graph instance.
   * @param  {string}  type  - Type of edges to retrieve.
   * @return {array}         - Array of edges.
   */
  function createEdgeArray(graph, type) {
    if (graph.size === 0) return [];
    if (type === 'mixed' || type === graph.type) {
      if (typeof Array.from === 'function') return Array.from(graph._edges.keys());
      return take(graph._edges.keys(), graph._edges.size);
    }
    var size = type === 'undirected' ? graph.undirectedSize : graph.directedSize;
    var list = new Array(size),
      mask = type === 'undirected';
    var iterator = graph._edges.values();
    var i = 0;
    var step, data;
    while (step = iterator.next(), step.done !== true) {
      data = step.value;
      if (data.undirected === mask) list[i++] = data.key;
    }
    return list;
  }

  /**
   * Function iterating over a graph's edges using a callback to match one of
   * them.
   *
   * @param  {Graph}    graph    - Target Graph instance.
   * @param  {string}   type     - Type of edges to retrieve.
   * @param  {function} callback - Function to call.
   */
  function forEachEdge(breakable, graph, type, callback) {
    if (graph.size === 0) return;
    var shouldFilter = type !== 'mixed' && type !== graph.type;
    var mask = type === 'undirected';
    var step, data;
    var shouldBreak = false;
    var iterator = graph._edges.values();
    while (step = iterator.next(), step.done !== true) {
      data = step.value;
      if (shouldFilter && data.undirected !== mask) continue;
      var _data = data,
        key = _data.key,
        attributes = _data.attributes,
        source = _data.source,
        target = _data.target;
      shouldBreak = callback(key, attributes, source.key, target.key, source.attributes, target.attributes, data.undirected);
      if (breakable && shouldBreak) return key;
    }
    return;
  }

  /**
   * Function creating an iterator of edges for the given type.
   *
   * @param  {Graph}    graph - Target Graph instance.
   * @param  {string}   type  - Type of edges to retrieve.
   * @return {Iterator}
   */
  function createEdgeIterator(graph, type) {
    if (graph.size === 0) return iterator.empty();
    var shouldFilter = type !== 'mixed' && type !== graph.type;
    var mask = type === 'undirected';
    var iterator$1 = graph._edges.values();
    return new iterator(function next() {
      var step, data;

      // eslint-disable-next-line no-constant-condition
      while (true) {
        step = iterator$1.next();
        if (step.done) return step;
        data = step.value;
        if (shouldFilter && data.undirected !== mask) continue;
        break;
      }
      var value = {
        edge: data.key,
        attributes: data.attributes,
        source: data.source.key,
        target: data.target.key,
        sourceAttributes: data.source.attributes,
        targetAttributes: data.target.attributes,
        undirected: data.undirected
      };
      return {
        value: value,
        done: false
      };
    });
  }

  /**
   * Function iterating over a node's edges using a callback to match one of them.
   *
   * @param  {boolean}  multi     - Whether the graph is multi or not.
   * @param  {string}   type      - Type of edges to retrieve.
   * @param  {string}   direction - In or out?
   * @param  {any}      nodeData  - Target node's data.
   * @param  {function} callback  - Function to call.
   */
  function forEachEdgeForNode(breakable, multi, type, direction, nodeData, callback) {
    var fn = multi ? forEachMulti : forEachSimple;
    var found;
    if (type !== 'undirected') {
      if (direction !== 'out') {
        found = fn(breakable, nodeData["in"], callback);
        if (breakable && found) return found;
      }
      if (direction !== 'in') {
        found = fn(breakable, nodeData.out, callback, !direction ? nodeData.key : undefined);
        if (breakable && found) return found;
      }
    }
    if (type !== 'directed') {
      found = fn(breakable, nodeData.undirected, callback);
      if (breakable && found) return found;
    }
    return;
  }

  /**
   * Function creating an array of edges for the given type & the given node.
   *
   * @param  {boolean} multi     - Whether the graph is multi or not.
   * @param  {string}  type      - Type of edges to retrieve.
   * @param  {string}  direction - In or out?
   * @param  {any}     nodeData  - Target node's data.
   * @return {array}             - Array of edges.
   */
  function createEdgeArrayForNode(multi, type, direction, nodeData) {
    var edges = []; // TODO: possibility to know size beforehand or factorize with map

    forEachEdgeForNode(false, multi, type, direction, nodeData, function (key) {
      edges.push(key);
    });
    return edges;
  }

  /**
   * Function iterating over a node's edges using a callback.
   *
   * @param  {string}   type      - Type of edges to retrieve.
   * @param  {string}   direction - In or out?
   * @param  {any}      nodeData  - Target node's data.
   * @return {Iterator}
   */
  function createEdgeIteratorForNode(type, direction, nodeData) {
    var iterator$1 = iterator.empty();
    if (type !== 'undirected') {
      if (direction !== 'out' && typeof nodeData["in"] !== 'undefined') iterator$1 = chain(iterator$1, createIterator(nodeData["in"]));
      if (direction !== 'in' && typeof nodeData.out !== 'undefined') iterator$1 = chain(iterator$1, createIterator(nodeData.out, !direction ? nodeData.key : undefined));
    }
    if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {
      iterator$1 = chain(iterator$1, createIterator(nodeData.undirected));
    }
    return iterator$1;
  }

  /**
   * Function iterating over edges for the given path using a callback to match
   * one of them.
   *
   * @param  {string}   type       - Type of edges to retrieve.
   * @param  {boolean}  multi      - Whether the graph is multi.
   * @param  {string}   direction  - In or out?
   * @param  {NodeData} sourceData - Source node's data.
   * @param  {string}   target     - Target node.
   * @param  {function} callback   - Function to call.
   */
  function forEachEdgeForPath(breakable, type, multi, direction, sourceData, target, callback) {
    var fn = multi ? forEachForKeyMulti : forEachForKeySimple;
    var found;
    if (type !== 'undirected') {
      if (typeof sourceData["in"] !== 'undefined' && direction !== 'out') {
        found = fn(breakable, sourceData["in"], target, callback);
        if (breakable && found) return found;
      }
      if (typeof sourceData.out !== 'undefined' && direction !== 'in' && (direction || sourceData.key !== target)) {
        found = fn(breakable, sourceData.out, target, callback);
        if (breakable && found) return found;
      }
    }
    if (type !== 'directed') {
      if (typeof sourceData.undirected !== 'undefined') {
        found = fn(breakable, sourceData.undirected, target, callback);
        if (breakable && found) return found;
      }
    }
    return;
  }

  /**
   * Function creating an array of edges for the given path.
   *
   * @param  {string}   type       - Type of edges to retrieve.
   * @param  {boolean}  multi      - Whether the graph is multi.
   * @param  {string}   direction  - In or out?
   * @param  {NodeData} sourceData - Source node's data.
   * @param  {any}      target     - Target node.
   * @return {array}               - Array of edges.
   */
  function createEdgeArrayForPath(type, multi, direction, sourceData, target) {
    var edges = []; // TODO: possibility to know size beforehand or factorize with map

    forEachEdgeForPath(false, type, multi, direction, sourceData, target, function (key) {
      edges.push(key);
    });
    return edges;
  }

  /**
   * Function returning an iterator over edges for the given path.
   *
   * @param  {string}   type       - Type of edges to retrieve.
   * @param  {string}   direction  - In or out?
   * @param  {NodeData} sourceData - Source node's data.
   * @param  {string}   target     - Target node.
   * @param  {function} callback   - Function to call.
   */
  function createEdgeIteratorForPath(type, direction, sourceData, target) {
    var iterator$1 = iterator.empty();
    if (type !== 'undirected') {
      if (typeof sourceData["in"] !== 'undefined' && direction !== 'out' && target in sourceData["in"]) iterator$1 = chain(iterator$1, createIteratorForKey(sourceData["in"], target));
      if (typeof sourceData.out !== 'undefined' && direction !== 'in' && target in sourceData.out && (direction || sourceData.key !== target)) iterator$1 = chain(iterator$1, createIteratorForKey(sourceData.out, target));
    }
    if (type !== 'directed') {
      if (typeof sourceData.undirected !== 'undefined' && target in sourceData.undirected) iterator$1 = chain(iterator$1, createIteratorForKey(sourceData.undirected, target));
    }
    return iterator$1;
  }

  /**
   * Function attaching an edge array creator method to the Graph prototype.
   *
   * @param {function} Class       - Target class.
   * @param {object}   description - Method description.
   */
  function attachEdgeArrayCreator(Class, description) {
    var name = description.name,
      type = description.type,
      direction = description.direction;

    /**
     * Function returning an array of certain edges.
     *
     * Arity 0: Return all the relevant edges.
     *
     * Arity 1: Return all of a node's relevant edges.
     * @param  {any}   node   - Target node.
     *
     * Arity 2: Return the relevant edges across the given path.
     * @param  {any}   source - Source node.
     * @param  {any}   target - Target node.
     *
     * @return {array|number} - The edges or the number of edges.
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    Class.prototype[name] = function (source, target) {
      // Early termination
      if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return [];
      if (!arguments.length) return createEdgeArray(this, type);
      if (arguments.length === 1) {
        source = '' + source;
        var nodeData = this._nodes.get(source);
        if (typeof nodeData === 'undefined') throw new NotFoundGraphError("Graph.".concat(name, ": could not find the \"").concat(source, "\" node in the graph."));

        // Iterating over a node's edges
        return createEdgeArrayForNode(this.multi, type === 'mixed' ? this.type : type, direction, nodeData);
      }
      if (arguments.length === 2) {
        source = '' + source;
        target = '' + target;
        var sourceData = this._nodes.get(source);
        if (!sourceData) throw new NotFoundGraphError("Graph.".concat(name, ":  could not find the \"").concat(source, "\" source node in the graph."));
        if (!this._nodes.has(target)) throw new NotFoundGraphError("Graph.".concat(name, ":  could not find the \"").concat(target, "\" target node in the graph."));

        // Iterating over the edges between source & target
        return createEdgeArrayForPath(type, this.multi, direction, sourceData, target);
      }
      throw new InvalidArgumentsGraphError("Graph.".concat(name, ": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length, ")."));
    };
  }

  /**
   * Function attaching a edge callback iterator method to the Graph prototype.
   *
   * @param {function} Class       - Target class.
   * @param {object}   description - Method description.
   */
  function attachForEachEdge(Class, description) {
    var name = description.name,
      type = description.type,
      direction = description.direction;
    var forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);

    /**
     * Function iterating over the graph's relevant edges by applying the given
     * callback.
     *
     * Arity 1: Iterate over all the relevant edges.
     * @param  {function} callback - Callback to use.
     *
     * Arity 2: Iterate over all of a node's relevant edges.
     * @param  {any}      node     - Target node.
     * @param  {function} callback - Callback to use.
     *
     * Arity 3: Iterate over the relevant edges across the given path.
     * @param  {any}      source   - Source node.
     * @param  {any}      target   - Target node.
     * @param  {function} callback - Callback to use.
     *
     * @return {undefined}
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    Class.prototype[forEachName] = function (source, target, callback) {
      // Early termination
      if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;
      if (arguments.length === 1) {
        callback = source;
        return forEachEdge(false, this, type, callback);
      }
      if (arguments.length === 2) {
        source = '' + source;
        callback = target;
        var nodeData = this._nodes.get(source);
        if (typeof nodeData === 'undefined') throw new NotFoundGraphError("Graph.".concat(forEachName, ": could not find the \"").concat(source, "\" node in the graph."));

        // Iterating over a node's edges
        // TODO: maybe attach the sub method to the instance dynamically?
        return forEachEdgeForNode(false, this.multi, type === 'mixed' ? this.type : type, direction, nodeData, callback);
      }
      if (arguments.length === 3) {
        source = '' + source;
        target = '' + target;
        var sourceData = this._nodes.get(source);
        if (!sourceData) throw new NotFoundGraphError("Graph.".concat(forEachName, ":  could not find the \"").concat(source, "\" source node in the graph."));
        if (!this._nodes.has(target)) throw new NotFoundGraphError("Graph.".concat(forEachName, ":  could not find the \"").concat(target, "\" target node in the graph."));

        // Iterating over the edges between source & target
        return forEachEdgeForPath(false, type, this.multi, direction, sourceData, target, callback);
      }
      throw new InvalidArgumentsGraphError("Graph.".concat(forEachName, ": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length, ")."));
    };

    /**
     * Function mapping the graph's relevant edges by applying the given
     * callback.
     *
     * Arity 1: Map all the relevant edges.
     * @param  {function} callback - Callback to use.
     *
     * Arity 2: Map all of a node's relevant edges.
     * @param  {any}      node     - Target node.
     * @param  {function} callback - Callback to use.
     *
     * Arity 3: Map the relevant edges across the given path.
     * @param  {any}      source   - Source node.
     * @param  {any}      target   - Target node.
     * @param  {function} callback - Callback to use.
     *
     * @return {undefined}
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    var mapName = 'map' + name[0].toUpperCase() + name.slice(1);
    Class.prototype[mapName] = function () {
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      var result;

      // We know the result length beforehand
      if (args.length === 0) {
        var length = 0;
        if (type !== 'directed') length += this.undirectedSize;
        if (type !== 'undirected') length += this.directedSize;
        result = new Array(length);
        var i = 0;
        args.push(function (e, ea, s, t, sa, ta, u) {
          result[i++] = callback(e, ea, s, t, sa, ta, u);
        });
      }

      // We don't know the result length beforehand
      // TODO: we can in some instances of simple graphs, knowing degree
      else {
        result = [];
        args.push(function (e, ea, s, t, sa, ta, u) {
          result.push(callback(e, ea, s, t, sa, ta, u));
        });
      }
      this[forEachName].apply(this, args);
      return result;
    };

    /**
     * Function filtering the graph's relevant edges using the provided predicate
     * function.
     *
     * Arity 1: Filter all the relevant edges.
     * @param  {function} predicate - Predicate to use.
     *
     * Arity 2: Filter all of a node's relevant edges.
     * @param  {any}      node      - Target node.
     * @param  {function} predicate - Predicate to use.
     *
     * Arity 3: Filter the relevant edges across the given path.
     * @param  {any}      source    - Source node.
     * @param  {any}      target    - Target node.
     * @param  {function} predicate - Predicate to use.
     *
     * @return {undefined}
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    var filterName = 'filter' + name[0].toUpperCase() + name.slice(1);
    Class.prototype[filterName] = function () {
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      var result = [];
      args.push(function (e, ea, s, t, sa, ta, u) {
        if (callback(e, ea, s, t, sa, ta, u)) result.push(e);
      });
      this[forEachName].apply(this, args);
      return result;
    };

    /**
     * Function reducing the graph's relevant edges using the provided accumulator
     * function.
     *
     * Arity 1: Reduce all the relevant edges.
     * @param  {function} accumulator  - Accumulator to use.
     * @param  {any}      initialValue - Initial value.
     *
     * Arity 2: Reduce all of a node's relevant edges.
     * @param  {any}      node         - Target node.
     * @param  {function} accumulator  - Accumulator to use.
     * @param  {any}      initialValue - Initial value.
     *
     * Arity 3: Reduce the relevant edges across the given path.
     * @param  {any}      source       - Source node.
     * @param  {any}      target       - Target node.
     * @param  {function} accumulator  - Accumulator to use.
     * @param  {any}      initialValue - Initial value.
     *
     * @return {undefined}
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    var reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);
    Class.prototype[reduceName] = function () {
      var args = Array.prototype.slice.call(arguments);
      if (args.length < 2 || args.length > 4) {
        throw new InvalidArgumentsGraphError("Graph.".concat(reduceName, ": invalid number of arguments (expecting 2, 3 or 4 and got ").concat(args.length, ")."));
      }
      if (typeof args[args.length - 1] === 'function' && typeof args[args.length - 2] !== 'function') {
        throw new InvalidArgumentsGraphError("Graph.".concat(reduceName, ": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));
      }
      var callback;
      var initialValue;
      if (args.length === 2) {
        callback = args[0];
        initialValue = args[1];
        args = [];
      } else if (args.length === 3) {
        callback = args[1];
        initialValue = args[2];
        args = [args[0]];
      } else if (args.length === 4) {
        callback = args[2];
        initialValue = args[3];
        args = [args[0], args[1]];
      }
      var accumulator = initialValue;
      args.push(function (e, ea, s, t, sa, ta, u) {
        accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);
      });
      this[forEachName].apply(this, args);
      return accumulator;
    };
  }

  /**
   * Function attaching a breakable edge callback iterator method to the Graph
   * prototype.
   *
   * @param {function} Class       - Target class.
   * @param {object}   description - Method description.
   */
  function attachFindEdge(Class, description) {
    var name = description.name,
      type = description.type,
      direction = description.direction;
    var findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);

    /**
     * Function iterating over the graph's relevant edges in order to match
     * one of them using the provided predicate function.
     *
     * Arity 1: Iterate over all the relevant edges.
     * @param  {function} callback - Callback to use.
     *
     * Arity 2: Iterate over all of a node's relevant edges.
     * @param  {any}      node     - Target node.
     * @param  {function} callback - Callback to use.
     *
     * Arity 3: Iterate over the relevant edges across the given path.
     * @param  {any}      source   - Source node.
     * @param  {any}      target   - Target node.
     * @param  {function} callback - Callback to use.
     *
     * @return {undefined}
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    Class.prototype[findEdgeName] = function (source, target, callback) {
      // Early termination
      if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return false;
      if (arguments.length === 1) {
        callback = source;
        return forEachEdge(true, this, type, callback);
      }
      if (arguments.length === 2) {
        source = '' + source;
        callback = target;
        var nodeData = this._nodes.get(source);
        if (typeof nodeData === 'undefined') throw new NotFoundGraphError("Graph.".concat(findEdgeName, ": could not find the \"").concat(source, "\" node in the graph."));

        // Iterating over a node's edges
        // TODO: maybe attach the sub method to the instance dynamically?
        return forEachEdgeForNode(true, this.multi, type === 'mixed' ? this.type : type, direction, nodeData, callback);
      }
      if (arguments.length === 3) {
        source = '' + source;
        target = '' + target;
        var sourceData = this._nodes.get(source);
        if (!sourceData) throw new NotFoundGraphError("Graph.".concat(findEdgeName, ":  could not find the \"").concat(source, "\" source node in the graph."));
        if (!this._nodes.has(target)) throw new NotFoundGraphError("Graph.".concat(findEdgeName, ":  could not find the \"").concat(target, "\" target node in the graph."));

        // Iterating over the edges between source & target
        return forEachEdgeForPath(true, type, this.multi, direction, sourceData, target, callback);
      }
      throw new InvalidArgumentsGraphError("Graph.".concat(findEdgeName, ": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length, ")."));
    };

    /**
     * Function iterating over the graph's relevant edges in order to assert
     * whether any one of them matches the provided predicate function.
     *
     * Arity 1: Iterate over all the relevant edges.
     * @param  {function} callback - Callback to use.
     *
     * Arity 2: Iterate over all of a node's relevant edges.
     * @param  {any}      node     - Target node.
     * @param  {function} callback - Callback to use.
     *
     * Arity 3: Iterate over the relevant edges across the given path.
     * @param  {any}      source   - Source node.
     * @param  {any}      target   - Target node.
     * @param  {function} callback - Callback to use.
     *
     * @return {undefined}
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    var someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);
    Class.prototype[someName] = function () {
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      args.push(function (e, ea, s, t, sa, ta, u) {
        return callback(e, ea, s, t, sa, ta, u);
      });
      var found = this[findEdgeName].apply(this, args);
      if (found) return true;
      return false;
    };

    /**
     * Function iterating over the graph's relevant edges in order to assert
     * whether all of them matche the provided predicate function.
     *
     * Arity 1: Iterate over all the relevant edges.
     * @param  {function} callback - Callback to use.
     *
     * Arity 2: Iterate over all of a node's relevant edges.
     * @param  {any}      node     - Target node.
     * @param  {function} callback - Callback to use.
     *
     * Arity 3: Iterate over the relevant edges across the given path.
     * @param  {any}      source   - Source node.
     * @param  {any}      target   - Target node.
     * @param  {function} callback - Callback to use.
     *
     * @return {undefined}
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    var everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);
    Class.prototype[everyName] = function () {
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      args.push(function (e, ea, s, t, sa, ta, u) {
        return !callback(e, ea, s, t, sa, ta, u);
      });
      var found = this[findEdgeName].apply(this, args);
      if (found) return false;
      return true;
    };
  }

  /**
   * Function attaching an edge iterator method to the Graph prototype.
   *
   * @param {function} Class       - Target class.
   * @param {object}   description - Method description.
   */
  function attachEdgeIteratorCreator(Class, description) {
    var originalName = description.name,
      type = description.type,
      direction = description.direction;
    var name = originalName.slice(0, -1) + 'Entries';

    /**
     * Function returning an iterator over the graph's edges.
     *
     * Arity 0: Iterate over all the relevant edges.
     *
     * Arity 1: Iterate over all of a node's relevant edges.
     * @param  {any}   node   - Target node.
     *
     * Arity 2: Iterate over the relevant edges across the given path.
     * @param  {any}   source - Source node.
     * @param  {any}   target - Target node.
     *
     * @return {array|number} - The edges or the number of edges.
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    Class.prototype[name] = function (source, target) {
      // Early termination
      if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return iterator.empty();
      if (!arguments.length) return createEdgeIterator(this, type);
      if (arguments.length === 1) {
        source = '' + source;
        var sourceData = this._nodes.get(source);
        if (!sourceData) throw new NotFoundGraphError("Graph.".concat(name, ": could not find the \"").concat(source, "\" node in the graph."));

        // Iterating over a node's edges
        return createEdgeIteratorForNode(type, direction, sourceData);
      }
      if (arguments.length === 2) {
        source = '' + source;
        target = '' + target;
        var _sourceData = this._nodes.get(source);
        if (!_sourceData) throw new NotFoundGraphError("Graph.".concat(name, ":  could not find the \"").concat(source, "\" source node in the graph."));
        if (!this._nodes.has(target)) throw new NotFoundGraphError("Graph.".concat(name, ":  could not find the \"").concat(target, "\" target node in the graph."));

        // Iterating over the edges between source & target
        return createEdgeIteratorForPath(type, direction, _sourceData, target);
      }
      throw new InvalidArgumentsGraphError("Graph.".concat(name, ": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length, ")."));
    };
  }

  /**
   * Function attaching every edge iteration method to the Graph class.
   *
   * @param {function} Graph - Graph class.
   */
  function attachEdgeIterationMethods(Graph) {
    EDGES_ITERATION.forEach(function (description) {
      attachEdgeArrayCreator(Graph, description);
      attachForEachEdge(Graph, description);
      attachFindEdge(Graph, description);
      attachEdgeIteratorCreator(Graph, description);
    });
  }

  /**
   * Graphology Neighbor Iteration
   * ==============================
   *
   * Attaching some methods to the Graph class to be able to iterate over
   * neighbors.
   */

  /**
   * Definitions.
   */
  var NEIGHBORS_ITERATION = [{
    name: 'neighbors',
    type: 'mixed'
  }, {
    name: 'inNeighbors',
    type: 'directed',
    direction: 'in'
  }, {
    name: 'outNeighbors',
    type: 'directed',
    direction: 'out'
  }, {
    name: 'inboundNeighbors',
    type: 'mixed',
    direction: 'in'
  }, {
    name: 'outboundNeighbors',
    type: 'mixed',
    direction: 'out'
  }, {
    name: 'directedNeighbors',
    type: 'directed'
  }, {
    name: 'undirectedNeighbors',
    type: 'undirected'
  }];

  /**
   * Helpers.
   */
  function CompositeSetWrapper() {
    this.A = null;
    this.B = null;
  }
  CompositeSetWrapper.prototype.wrap = function (set) {
    if (this.A === null) this.A = set;else if (this.B === null) this.B = set;
  };
  CompositeSetWrapper.prototype.has = function (key) {
    if (this.A !== null && key in this.A) return true;
    if (this.B !== null && key in this.B) return true;
    return false;
  };

  /**
   * Function iterating over the given node's relevant neighbors to match
   * one of them using a predicated function.
   *
   * @param  {string}   type      - Type of neighbors.
   * @param  {string}   direction - Direction.
   * @param  {any}      nodeData  - Target node's data.
   * @param  {function} callback  - Callback to use.
   */
  function forEachInObjectOnce(breakable, visited, nodeData, object, callback) {
    for (var k in object) {
      var edgeData = object[k];
      var sourceData = edgeData.source;
      var targetData = edgeData.target;
      var neighborData = sourceData === nodeData ? targetData : sourceData;
      if (visited && visited.has(neighborData.key)) continue;
      var shouldBreak = callback(neighborData.key, neighborData.attributes);
      if (breakable && shouldBreak) return neighborData.key;
    }
    return;
  }
  function forEachNeighbor(breakable, type, direction, nodeData, callback) {
    // If we want only undirected or in or out, we can roll some optimizations
    if (type !== 'mixed') {
      if (type === 'undirected') return forEachInObjectOnce(breakable, null, nodeData, nodeData.undirected, callback);
      if (typeof direction === 'string') return forEachInObjectOnce(breakable, null, nodeData, nodeData[direction], callback);
    }

    // Else we need to keep a set of neighbors not to return duplicates
    // We cheat by querying the other adjacencies
    var visited = new CompositeSetWrapper();
    var found;
    if (type !== 'undirected') {
      if (direction !== 'out') {
        found = forEachInObjectOnce(breakable, null, nodeData, nodeData["in"], callback);
        if (breakable && found) return found;
        visited.wrap(nodeData["in"]);
      }
      if (direction !== 'in') {
        found = forEachInObjectOnce(breakable, visited, nodeData, nodeData.out, callback);
        if (breakable && found) return found;
        visited.wrap(nodeData.out);
      }
    }
    if (type !== 'directed') {
      found = forEachInObjectOnce(breakable, visited, nodeData, nodeData.undirected, callback);
      if (breakable && found) return found;
    }
    return;
  }

  /**
   * Function creating an array of relevant neighbors for the given node.
   *
   * @param  {string}       type      - Type of neighbors.
   * @param  {string}       direction - Direction.
   * @param  {any}          nodeData  - Target node's data.
   * @return {Array}                  - The list of neighbors.
   */
  function createNeighborArrayForNode(type, direction, nodeData) {
    // If we want only undirected or in or out, we can roll some optimizations
    if (type !== 'mixed') {
      if (type === 'undirected') return Object.keys(nodeData.undirected);
      if (typeof direction === 'string') return Object.keys(nodeData[direction]);
    }
    var neighbors = [];
    forEachNeighbor(false, type, direction, nodeData, function (key) {
      neighbors.push(key);
    });
    return neighbors;
  }

  /**
   * Function returning an iterator over the given node's relevant neighbors.
   *
   * @param  {string}   type      - Type of neighbors.
   * @param  {string}   direction - Direction.
   * @param  {any}      nodeData  - Target node's data.
   * @return {Iterator}
   */
  function createDedupedObjectIterator(visited, nodeData, object) {
    var keys = Object.keys(object);
    var l = keys.length;
    var i = 0;
    return new iterator(function next() {
      var neighborData = null;
      do {
        if (i >= l) {
          if (visited) visited.wrap(object);
          return {
            done: true
          };
        }
        var edgeData = object[keys[i++]];
        var sourceData = edgeData.source;
        var targetData = edgeData.target;
        neighborData = sourceData === nodeData ? targetData : sourceData;
        if (visited && visited.has(neighborData.key)) {
          neighborData = null;
          continue;
        }
      } while (neighborData === null);
      return {
        done: false,
        value: {
          neighbor: neighborData.key,
          attributes: neighborData.attributes
        }
      };
    });
  }
  function createNeighborIterator(type, direction, nodeData) {
    // If we want only undirected or in or out, we can roll some optimizations
    if (type !== 'mixed') {
      if (type === 'undirected') return createDedupedObjectIterator(null, nodeData, nodeData.undirected);
      if (typeof direction === 'string') return createDedupedObjectIterator(null, nodeData, nodeData[direction]);
    }
    var iterator$1 = iterator.empty();

    // Else we need to keep a set of neighbors not to return duplicates
    // We cheat by querying the other adjacencies
    var visited = new CompositeSetWrapper();
    if (type !== 'undirected') {
      if (direction !== 'out') {
        iterator$1 = chain(iterator$1, createDedupedObjectIterator(visited, nodeData, nodeData["in"]));
      }
      if (direction !== 'in') {
        iterator$1 = chain(iterator$1, createDedupedObjectIterator(visited, nodeData, nodeData.out));
      }
    }
    if (type !== 'directed') {
      iterator$1 = chain(iterator$1, createDedupedObjectIterator(visited, nodeData, nodeData.undirected));
    }
    return iterator$1;
  }

  /**
   * Function attaching a neighbors array creator method to the Graph prototype.
   *
   * @param {function} Class       - Target class.
   * @param {object}   description - Method description.
   */
  function attachNeighborArrayCreator(Class, description) {
    var name = description.name,
      type = description.type,
      direction = description.direction;

    /**
     * Function returning an array of certain neighbors.
     *
     * @param  {any}   node   - Target node.
     * @return {array} - The neighbors of neighbors.
     *
     * @throws {Error} - Will throw if node is not found in the graph.
     */
    Class.prototype[name] = function (node) {
      // Early termination
      if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return [];
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (typeof nodeData === 'undefined') throw new NotFoundGraphError("Graph.".concat(name, ": could not find the \"").concat(node, "\" node in the graph."));

      // Here, we want to iterate over a node's relevant neighbors
      return createNeighborArrayForNode(type === 'mixed' ? this.type : type, direction, nodeData);
    };
  }

  /**
   * Function attaching a neighbors callback iterator method to the Graph prototype.
   *
   * @param {function} Class       - Target class.
   * @param {object}   description - Method description.
   */
  function attachForEachNeighbor(Class, description) {
    var name = description.name,
      type = description.type,
      direction = description.direction;
    var forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);

    /**
     * Function iterating over all the relevant neighbors using a callback.
     *
     * @param  {any}      node     - Target node.
     * @param  {function} callback - Callback to use.
     * @return {undefined}
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    Class.prototype[forEachName] = function (node, callback) {
      // Early termination
      if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (typeof nodeData === 'undefined') throw new NotFoundGraphError("Graph.".concat(forEachName, ": could not find the \"").concat(node, "\" node in the graph."));

      // Here, we want to iterate over a node's relevant neighbors
      forEachNeighbor(false, type === 'mixed' ? this.type : type, direction, nodeData, callback);
    };

    /**
     * Function mapping the relevant neighbors using a callback.
     *
     * @param  {any}      node     - Target node.
     * @param  {function} callback - Callback to use.
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    var mapName = 'map' + name[0].toUpperCase() + name.slice(1);
    Class.prototype[mapName] = function (node, callback) {
      // TODO: optimize when size is known beforehand
      var result = [];
      this[forEachName](node, function (n, a) {
        result.push(callback(n, a));
      });
      return result;
    };

    /**
     * Function filtering the relevant neighbors using a callback.
     *
     * @param  {any}      node     - Target node.
     * @param  {function} callback - Callback to use.
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    var filterName = 'filter' + name[0].toUpperCase() + name.slice(1);
    Class.prototype[filterName] = function (node, callback) {
      var result = [];
      this[forEachName](node, function (n, a) {
        if (callback(n, a)) result.push(n);
      });
      return result;
    };

    /**
     * Function reducing the relevant neighbors using a callback.
     *
     * @param  {any}      node     - Target node.
     * @param  {function} callback - Callback to use.
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    var reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);
    Class.prototype[reduceName] = function (node, callback, initialValue) {
      if (arguments.length < 3) throw new InvalidArgumentsGraphError("Graph.".concat(reduceName, ": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));
      var accumulator = initialValue;
      this[forEachName](node, function (n, a) {
        accumulator = callback(accumulator, n, a);
      });
      return accumulator;
    };
  }

  /**
   * Function attaching a breakable neighbors callback iterator method to the
   * Graph prototype.
   *
   * @param {function} Class       - Target class.
   * @param {object}   description - Method description.
   */
  function attachFindNeighbor(Class, description) {
    var name = description.name,
      type = description.type,
      direction = description.direction;
    var capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);
    var findName = 'find' + capitalizedSingular;

    /**
     * Function iterating over all the relevant neighbors using a callback.
     *
     * @param  {any}      node     - Target node.
     * @param  {function} callback - Callback to use.
     * @return {undefined}
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    Class.prototype[findName] = function (node, callback) {
      // Early termination
      if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (typeof nodeData === 'undefined') throw new NotFoundGraphError("Graph.".concat(findName, ": could not find the \"").concat(node, "\" node in the graph."));

      // Here, we want to iterate over a node's relevant neighbors
      return forEachNeighbor(true, type === 'mixed' ? this.type : type, direction, nodeData, callback);
    };

    /**
     * Function iterating over all the relevant neighbors to find if any of them
     * matches the given predicate.
     *
     * @param  {any}      node     - Target node.
     * @param  {function} callback - Callback to use.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    var someName = 'some' + capitalizedSingular;
    Class.prototype[someName] = function (node, callback) {
      var found = this[findName](node, callback);
      if (found) return true;
      return false;
    };

    /**
     * Function iterating over all the relevant neighbors to find if all of them
     * matche the given predicate.
     *
     * @param  {any}      node     - Target node.
     * @param  {function} callback - Callback to use.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    var everyName = 'every' + capitalizedSingular;
    Class.prototype[everyName] = function (node, callback) {
      var found = this[findName](node, function (n, a) {
        return !callback(n, a);
      });
      if (found) return false;
      return true;
    };
  }

  /**
   * Function attaching a neighbors callback iterator method to the Graph prototype.
   *
   * @param {function} Class       - Target class.
   * @param {object}   description - Method description.
   */
  function attachNeighborIteratorCreator(Class, description) {
    var name = description.name,
      type = description.type,
      direction = description.direction;
    var iteratorName = name.slice(0, -1) + 'Entries';

    /**
     * Function returning an iterator over all the relevant neighbors.
     *
     * @param  {any}      node     - Target node.
     * @return {Iterator}
     *
     * @throws {Error} - Will throw if there are too many arguments.
     */
    Class.prototype[iteratorName] = function (node) {
      // Early termination
      if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return iterator.empty();
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (typeof nodeData === 'undefined') throw new NotFoundGraphError("Graph.".concat(iteratorName, ": could not find the \"").concat(node, "\" node in the graph."));

      // Here, we want to iterate over a node's relevant neighbors
      return createNeighborIterator(type === 'mixed' ? this.type : type, direction, nodeData);
    };
  }

  /**
   * Function attaching every neighbor iteration method to the Graph class.
   *
   * @param {function} Graph - Graph class.
   */
  function attachNeighborIterationMethods(Graph) {
    NEIGHBORS_ITERATION.forEach(function (description) {
      attachNeighborArrayCreator(Graph, description);
      attachForEachNeighbor(Graph, description);
      attachFindNeighbor(Graph, description);
      attachNeighborIteratorCreator(Graph, description);
    });
  }

  /**
   * Graphology Adjacency Iteration
   * ===============================
   *
   * Attaching some methods to the Graph class to be able to iterate over a
   * graph's adjacency.
   */

  /**
   * Function iterating over a simple graph's adjacency using a callback.
   *
   * @param {boolean}  breakable         - Can we break?
   * @param {boolean}  assymetric        - Whether to emit undirected edges only once.
   * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.
   * @param {Graph}    graph             - Target Graph instance.
   * @param {callback} function          - Iteration callback.
   */
  function forEachAdjacency(breakable, assymetric, disconnectedNodes, graph, callback) {
    var iterator = graph._nodes.values();
    var type = graph.type;
    var step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;
    while (step = iterator.next(), step.done !== true) {
      var hasEdges = false;
      sourceData = step.value;
      if (type !== 'undirected') {
        adj = sourceData.out;
        for (neighbor in adj) {
          edgeData = adj[neighbor];
          do {
            targetData = edgeData.target;
            hasEdges = true;
            shouldBreak = callback(sourceData.key, targetData.key, sourceData.attributes, targetData.attributes, edgeData.key, edgeData.attributes, edgeData.undirected);
            if (breakable && shouldBreak) return edgeData;
            edgeData = edgeData.next;
          } while (edgeData);
        }
      }
      if (type !== 'directed') {
        adj = sourceData.undirected;
        for (neighbor in adj) {
          if (assymetric && sourceData.key > neighbor) continue;
          edgeData = adj[neighbor];
          do {
            targetData = edgeData.target;
            if (targetData.key !== neighbor) targetData = edgeData.source;
            hasEdges = true;
            shouldBreak = callback(sourceData.key, targetData.key, sourceData.attributes, targetData.attributes, edgeData.key, edgeData.attributes, edgeData.undirected);
            if (breakable && shouldBreak) return edgeData;
            edgeData = edgeData.next;
          } while (edgeData);
        }
      }
      if (disconnectedNodes && !hasEdges) {
        shouldBreak = callback(sourceData.key, null, sourceData.attributes, null, null, null, null);
        if (breakable && shouldBreak) return null;
      }
    }
    return;
  }

  /**
   * Graphology Serialization Utilities
   * ===================================
   *
   * Collection of functions used by the graph serialization schemes.
   */

  /**
   * Formats internal node data into a serialized node.
   *
   * @param  {any}    key  - The node's key.
   * @param  {object} data - Internal node's data.
   * @return {array}       - The serialized node.
   */
  function serializeNode(key, data) {
    var serialized = {
      key: key
    };
    if (!isEmpty(data.attributes)) serialized.attributes = assign({}, data.attributes);
    return serialized;
  }

  /**
   * Formats internal edge data into a serialized edge.
   *
   * @param  {string} type - The graph's type.
   * @param  {any}    key  - The edge's key.
   * @param  {object} data - Internal edge's data.
   * @return {array}       - The serialized edge.
   */
  function serializeEdge(type, key, data) {
    var serialized = {
      key: key,
      source: data.source.key,
      target: data.target.key
    };
    if (!isEmpty(data.attributes)) serialized.attributes = assign({}, data.attributes);
    if (type === 'mixed' && data.undirected) serialized.undirected = true;
    return serialized;
  }

  /**
   * Checks whether the given value is a serialized node.
   *
   * @param  {mixed} value - Target value.
   * @return {string|null}
   */
  function validateSerializedNode(value) {
    if (!isPlainObject(value)) throw new InvalidArgumentsGraphError('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');
    if (!('key' in value)) throw new InvalidArgumentsGraphError('Graph.import: serialized node is missing its key.');
    if ('attributes' in value && (!isPlainObject(value.attributes) || value.attributes === null)) throw new InvalidArgumentsGraphError('Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.');
  }

  /**
   * Checks whether the given value is a serialized edge.
   *
   * @param  {mixed} value - Target value.
   * @return {string|null}
   */
  function validateSerializedEdge(value) {
    if (!isPlainObject(value)) throw new InvalidArgumentsGraphError('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');
    if (!('source' in value)) throw new InvalidArgumentsGraphError('Graph.import: serialized edge is missing its source.');
    if (!('target' in value)) throw new InvalidArgumentsGraphError('Graph.import: serialized edge is missing its target.');
    if ('attributes' in value && (!isPlainObject(value.attributes) || value.attributes === null)) throw new InvalidArgumentsGraphError('Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.');
    if ('undirected' in value && typeof value.undirected !== 'boolean') throw new InvalidArgumentsGraphError('Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.');
  }

  /**
   * Constants.
   */
  var INSTANCE_ID = incrementalIdStartingFromRandomByte();

  /**
   * Enums.
   */
  var TYPES = new Set(['directed', 'undirected', 'mixed']);
  var EMITTER_PROPS = new Set(['domain', '_events', '_eventsCount', '_maxListeners']);
  var EDGE_ADD_METHODS = [{
    name: function name(verb) {
      return "".concat(verb, "Edge");
    },
    generateKey: true
  }, {
    name: function name(verb) {
      return "".concat(verb, "DirectedEdge");
    },
    generateKey: true,
    type: 'directed'
  }, {
    name: function name(verb) {
      return "".concat(verb, "UndirectedEdge");
    },
    generateKey: true,
    type: 'undirected'
  }, {
    name: function name(verb) {
      return "".concat(verb, "EdgeWithKey");
    }
  }, {
    name: function name(verb) {
      return "".concat(verb, "DirectedEdgeWithKey");
    },
    type: 'directed'
  }, {
    name: function name(verb) {
      return "".concat(verb, "UndirectedEdgeWithKey");
    },
    type: 'undirected'
  }];

  /**
   * Default options.
   */
  var DEFAULTS = {
    allowSelfLoops: true,
    multi: false,
    type: 'mixed'
  };

  /**
   * Abstract functions used by the Graph class for various methods.
   */

  /**
   * Internal method used to add a node to the given graph
   *
   * @param  {Graph}   graph           - Target graph.
   * @param  {any}     node            - The node's key.
   * @param  {object}  [attributes]    - Optional attributes.
   * @return {NodeData}                - Created node data.
   */
  function _addNode(graph, node, attributes) {
    if (attributes && !isPlainObject(attributes)) throw new InvalidArgumentsGraphError("Graph.addNode: invalid attributes. Expecting an object but got \"".concat(attributes, "\""));

    // String coercion
    node = '' + node;
    attributes = attributes || {};
    if (graph._nodes.has(node)) throw new UsageGraphError("Graph.addNode: the \"".concat(node, "\" node already exist in the graph."));
    var data = new graph.NodeDataClass(node, attributes);

    // Adding the node to internal register
    graph._nodes.set(node, data);

    // Emitting
    graph.emit('nodeAdded', {
      key: node,
      attributes: attributes
    });
    return data;
  }

  /**
   * Same as the above but without sanity checks because we call this in contexts
   * where necessary checks were already done.
   */
  function unsafeAddNode(graph, node, attributes) {
    var data = new graph.NodeDataClass(node, attributes);
    graph._nodes.set(node, data);
    graph.emit('nodeAdded', {
      key: node,
      attributes: attributes
    });
    return data;
  }

  /**
   * Internal method used to add an arbitrary edge to the given graph.
   *
   * @param  {Graph}   graph           - Target graph.
   * @param  {string}  name            - Name of the child method for errors.
   * @param  {boolean} mustGenerateKey - Should the graph generate an id?
   * @param  {boolean} undirected      - Whether the edge is undirected.
   * @param  {any}     edge            - The edge's key.
   * @param  {any}     source          - The source node.
   * @param  {any}     target          - The target node.
   * @param  {object}  [attributes]    - Optional attributes.
   * @return {any}                     - The edge.
   *
   * @throws {Error} - Will throw if the graph is of the wrong type.
   * @throws {Error} - Will throw if the given attributes are not an object.
   * @throws {Error} - Will throw if source or target doesn't exist.
   * @throws {Error} - Will throw if the edge already exist.
   */
  function addEdge(graph, name, mustGenerateKey, undirected, edge, source, target, attributes) {
    // Checking validity of operation
    if (!undirected && graph.type === 'undirected') throw new UsageGraphError("Graph.".concat(name, ": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead."));
    if (undirected && graph.type === 'directed') throw new UsageGraphError("Graph.".concat(name, ": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead."));
    if (attributes && !isPlainObject(attributes)) throw new InvalidArgumentsGraphError("Graph.".concat(name, ": invalid attributes. Expecting an object but got \"").concat(attributes, "\""));

    // Coercion of source & target:
    source = '' + source;
    target = '' + target;
    attributes = attributes || {};
    if (!graph.allowSelfLoops && source === target) throw new UsageGraphError("Graph.".concat(name, ": source & target are the same (\"").concat(source, "\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false."));
    var sourceData = graph._nodes.get(source),
      targetData = graph._nodes.get(target);
    if (!sourceData) throw new NotFoundGraphError("Graph.".concat(name, ": source node \"").concat(source, "\" not found."));
    if (!targetData) throw new NotFoundGraphError("Graph.".concat(name, ": target node \"").concat(target, "\" not found."));

    // Must the graph generate an id for this edge?
    var eventData = {
      key: null,
      undirected: undirected,
      source: source,
      target: target,
      attributes: attributes
    };
    if (mustGenerateKey) {
      // NOTE: in this case we can guarantee that the key does not already
      // exist and is already correctly casted as a string
      edge = graph._edgeKeyGenerator();
    } else {
      // Coercion of edge key
      edge = '' + edge;

      // Here, we have a key collision
      if (graph._edges.has(edge)) throw new UsageGraphError("Graph.".concat(name, ": the \"").concat(edge, "\" edge already exists in the graph."));
    }

    // Here, we might have a source / target collision
    if (!graph.multi && (undirected ? typeof sourceData.undirected[target] !== 'undefined' : typeof sourceData.out[target] !== 'undefined')) {
      throw new UsageGraphError("Graph.".concat(name, ": an edge linking \"").concat(source, "\" to \"").concat(target, "\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option."));
    }

    // Storing some data
    var edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);

    // Adding the edge to the internal register
    graph._edges.set(edge, edgeData);

    // Incrementing node degree counters
    var isSelfLoop = source === target;
    if (undirected) {
      sourceData.undirectedDegree++;
      targetData.undirectedDegree++;
      if (isSelfLoop) {
        sourceData.undirectedLoops++;
        graph._undirectedSelfLoopCount++;
      }
    } else {
      sourceData.outDegree++;
      targetData.inDegree++;
      if (isSelfLoop) {
        sourceData.directedLoops++;
        graph._directedSelfLoopCount++;
      }
    }

    // Updating relevant index
    if (graph.multi) edgeData.attachMulti();else edgeData.attach();
    if (undirected) graph._undirectedSize++;else graph._directedSize++;

    // Emitting
    eventData.key = edge;
    graph.emit('edgeAdded', eventData);
    return edge;
  }

  /**
   * Internal method used to add an arbitrary edge to the given graph.
   *
   * @param  {Graph}   graph           - Target graph.
   * @param  {string}  name            - Name of the child method for errors.
   * @param  {boolean} mustGenerateKey - Should the graph generate an id?
   * @param  {boolean} undirected      - Whether the edge is undirected.
   * @param  {any}     edge            - The edge's key.
   * @param  {any}     source          - The source node.
   * @param  {any}     target          - The target node.
   * @param  {object}  [attributes]    - Optional attributes.
   * @param  {boolean} [asUpdater]       - Are we updating or merging?
   * @return {any}                     - The edge.
   *
   * @throws {Error} - Will throw if the graph is of the wrong type.
   * @throws {Error} - Will throw if the given attributes are not an object.
   * @throws {Error} - Will throw if source or target doesn't exist.
   * @throws {Error} - Will throw if the edge already exist.
   */
  function mergeEdge(graph, name, mustGenerateKey, undirected, edge, source, target, attributes, asUpdater) {
    // Checking validity of operation
    if (!undirected && graph.type === 'undirected') throw new UsageGraphError("Graph.".concat(name, ": you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead."));
    if (undirected && graph.type === 'directed') throw new UsageGraphError("Graph.".concat(name, ": you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead."));
    if (attributes) {
      if (asUpdater) {
        if (typeof attributes !== 'function') throw new InvalidArgumentsGraphError("Graph.".concat(name, ": invalid updater function. Expecting a function but got \"").concat(attributes, "\""));
      } else {
        if (!isPlainObject(attributes)) throw new InvalidArgumentsGraphError("Graph.".concat(name, ": invalid attributes. Expecting an object but got \"").concat(attributes, "\""));
      }
    }

    // Coercion of source & target:
    source = '' + source;
    target = '' + target;
    var updater;
    if (asUpdater) {
      updater = attributes;
      attributes = undefined;
    }
    if (!graph.allowSelfLoops && source === target) throw new UsageGraphError("Graph.".concat(name, ": source & target are the same (\"").concat(source, "\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false."));
    var sourceData = graph._nodes.get(source);
    var targetData = graph._nodes.get(target);
    var edgeData;

    // Do we need to handle duplicate?
    var alreadyExistingEdgeData;
    if (!mustGenerateKey) {
      edgeData = graph._edges.get(edge);
      if (edgeData) {
        // Here, we need to ensure, if the user gave a key, that source & target
        // are consistent
        if (edgeData.source.key !== source || edgeData.target.key !== target) {
          // If source or target inconsistent
          if (!undirected || edgeData.source.key !== target || edgeData.target.key !== source) {
            // If directed, or source/target aren't flipped
            throw new UsageGraphError("Graph.".concat(name, ": inconsistency detected when attempting to merge the \"").concat(edge, "\" edge with \"").concat(source, "\" source & \"").concat(target, "\" target vs. (\"").concat(edgeData.source.key, "\", \"").concat(edgeData.target.key, "\")."));
          }
        }
        alreadyExistingEdgeData = edgeData;
      }
    }

    // Here, we might have a source / target collision
    if (!alreadyExistingEdgeData && !graph.multi && sourceData) {
      alreadyExistingEdgeData = undirected ? sourceData.undirected[target] : sourceData.out[target];
    }

    // Handling duplicates
    if (alreadyExistingEdgeData) {
      var info = [alreadyExistingEdgeData.key, false, false, false];

      // We can skip the attribute merging part if the user did not provide them
      if (asUpdater ? !updater : !attributes) return info;

      // Updating the attributes
      if (asUpdater) {
        var oldAttributes = alreadyExistingEdgeData.attributes;
        alreadyExistingEdgeData.attributes = updater(oldAttributes);
        graph.emit('edgeAttributesUpdated', {
          type: 'replace',
          key: alreadyExistingEdgeData.key,
          attributes: alreadyExistingEdgeData.attributes
        });
      }

      // Merging the attributes
      else {
        assign(alreadyExistingEdgeData.attributes, attributes);
        graph.emit('edgeAttributesUpdated', {
          type: 'merge',
          key: alreadyExistingEdgeData.key,
          attributes: alreadyExistingEdgeData.attributes,
          data: attributes
        });
      }
      return info;
    }
    attributes = attributes || {};
    if (asUpdater && updater) attributes = updater(attributes);

    // Must the graph generate an id for this edge?
    var eventData = {
      key: null,
      undirected: undirected,
      source: source,
      target: target,
      attributes: attributes
    };
    if (mustGenerateKey) {
      // NOTE: in this case we can guarantee that the key does not already
      // exist and is already correctly casted as a string
      edge = graph._edgeKeyGenerator();
    } else {
      // Coercion of edge key
      edge = '' + edge;

      // Here, we have a key collision
      if (graph._edges.has(edge)) throw new UsageGraphError("Graph.".concat(name, ": the \"").concat(edge, "\" edge already exists in the graph."));
    }
    var sourceWasAdded = false;
    var targetWasAdded = false;
    if (!sourceData) {
      sourceData = unsafeAddNode(graph, source, {});
      sourceWasAdded = true;
      if (source === target) {
        targetData = sourceData;
        targetWasAdded = true;
      }
    }
    if (!targetData) {
      targetData = unsafeAddNode(graph, target, {});
      targetWasAdded = true;
    }

    // Storing some data
    edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);

    // Adding the edge to the internal register
    graph._edges.set(edge, edgeData);

    // Incrementing node degree counters
    var isSelfLoop = source === target;
    if (undirected) {
      sourceData.undirectedDegree++;
      targetData.undirectedDegree++;
      if (isSelfLoop) {
        sourceData.undirectedLoops++;
        graph._undirectedSelfLoopCount++;
      }
    } else {
      sourceData.outDegree++;
      targetData.inDegree++;
      if (isSelfLoop) {
        sourceData.directedLoops++;
        graph._directedSelfLoopCount++;
      }
    }

    // Updating relevant index
    if (graph.multi) edgeData.attachMulti();else edgeData.attach();
    if (undirected) graph._undirectedSize++;else graph._directedSize++;

    // Emitting
    eventData.key = edge;
    graph.emit('edgeAdded', eventData);
    return [edge, true, sourceWasAdded, targetWasAdded];
  }

  /**
   * Internal method used to drop an edge.
   *
   * @param  {Graph}    graph    - Target graph.
   * @param  {EdgeData} edgeData - Data of the edge to drop.
   */
  function dropEdgeFromData(graph, edgeData) {
    // Dropping the edge from the register
    graph._edges["delete"](edgeData.key);

    // Updating related degrees
    var sourceData = edgeData.source,
      targetData = edgeData.target,
      attributes = edgeData.attributes;
    var undirected = edgeData.undirected;
    var isSelfLoop = sourceData === targetData;
    if (undirected) {
      sourceData.undirectedDegree--;
      targetData.undirectedDegree--;
      if (isSelfLoop) {
        sourceData.undirectedLoops--;
        graph._undirectedSelfLoopCount--;
      }
    } else {
      sourceData.outDegree--;
      targetData.inDegree--;
      if (isSelfLoop) {
        sourceData.directedLoops--;
        graph._directedSelfLoopCount--;
      }
    }

    // Clearing index
    if (graph.multi) edgeData.detachMulti();else edgeData.detach();
    if (undirected) graph._undirectedSize--;else graph._directedSize--;

    // Emitting
    graph.emit('edgeDropped', {
      key: edgeData.key,
      attributes: attributes,
      source: sourceData.key,
      target: targetData.key,
      undirected: undirected
    });
  }

  /**
   * Graph class
   *
   * @constructor
   * @param  {object}  [options] - Options:
   * @param  {boolean}   [allowSelfLoops] - Allow self loops?
   * @param  {string}    [type]           - Type of the graph.
   * @param  {boolean}   [map]            - Allow references as keys?
   * @param  {boolean}   [multi]          - Allow parallel edges?
   *
   * @throws {Error} - Will throw if the arguments are not valid.
   */
  var Graph = /*#__PURE__*/function (_EventEmitter) {
    _inheritsLoose(Graph, _EventEmitter);
    function Graph(options) {
      var _this;
      _this = _EventEmitter.call(this) || this;

      //-- Solving options
      options = assign({}, DEFAULTS, options);

      // Enforcing options validity
      if (typeof options.multi !== 'boolean') throw new InvalidArgumentsGraphError("Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"".concat(options.multi, "\"."));
      if (!TYPES.has(options.type)) throw new InvalidArgumentsGraphError("Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"".concat(options.type, "\"."));
      if (typeof options.allowSelfLoops !== 'boolean') throw new InvalidArgumentsGraphError("Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"".concat(options.allowSelfLoops, "\"."));

      //-- Private properties

      // Utilities
      var NodeDataClass = options.type === 'mixed' ? MixedNodeData : options.type === 'directed' ? DirectedNodeData : UndirectedNodeData;
      privateProperty(_assertThisInitialized(_this), 'NodeDataClass', NodeDataClass);

      // Internal edge key generator

      // NOTE: this internal generator produce keys that are strings
      // composed of a weird prefix, an incremental instance id starting from
      // a random byte and finally an internal instance incremental id.
      // All this to avoid intra-frame and cross-frame adversarial inputs
      // that can force a single #.addEdge call to degenerate into a O(n)
      // available key search loop.

      // It also ensures that automatically generated edge keys are unlikely
      // to produce collisions with arbitrary keys given by users.
      var instancePrefix = 'geid_' + INSTANCE_ID() + '_';
      var edgeId = 0;
      var edgeKeyGenerator = function edgeKeyGenerator() {
        var availableEdgeKey;
        do {
          availableEdgeKey = instancePrefix + edgeId++;
        } while (_this._edges.has(availableEdgeKey));
        return availableEdgeKey;
      };

      // Indexes
      privateProperty(_assertThisInitialized(_this), '_attributes', {});
      privateProperty(_assertThisInitialized(_this), '_nodes', new Map());
      privateProperty(_assertThisInitialized(_this), '_edges', new Map());
      privateProperty(_assertThisInitialized(_this), '_directedSize', 0);
      privateProperty(_assertThisInitialized(_this), '_undirectedSize', 0);
      privateProperty(_assertThisInitialized(_this), '_directedSelfLoopCount', 0);
      privateProperty(_assertThisInitialized(_this), '_undirectedSelfLoopCount', 0);
      privateProperty(_assertThisInitialized(_this), '_edgeKeyGenerator', edgeKeyGenerator);

      // Options
      privateProperty(_assertThisInitialized(_this), '_options', options);

      // Emitter properties
      EMITTER_PROPS.forEach(function (prop) {
        return privateProperty(_assertThisInitialized(_this), prop, _this[prop]);
      });

      //-- Properties readers
      readOnlyProperty(_assertThisInitialized(_this), 'order', function () {
        return _this._nodes.size;
      });
      readOnlyProperty(_assertThisInitialized(_this), 'size', function () {
        return _this._edges.size;
      });
      readOnlyProperty(_assertThisInitialized(_this), 'directedSize', function () {
        return _this._directedSize;
      });
      readOnlyProperty(_assertThisInitialized(_this), 'undirectedSize', function () {
        return _this._undirectedSize;
      });
      readOnlyProperty(_assertThisInitialized(_this), 'selfLoopCount', function () {
        return _this._directedSelfLoopCount + _this._undirectedSelfLoopCount;
      });
      readOnlyProperty(_assertThisInitialized(_this), 'directedSelfLoopCount', function () {
        return _this._directedSelfLoopCount;
      });
      readOnlyProperty(_assertThisInitialized(_this), 'undirectedSelfLoopCount', function () {
        return _this._undirectedSelfLoopCount;
      });
      readOnlyProperty(_assertThisInitialized(_this), 'multi', _this._options.multi);
      readOnlyProperty(_assertThisInitialized(_this), 'type', _this._options.type);
      readOnlyProperty(_assertThisInitialized(_this), 'allowSelfLoops', _this._options.allowSelfLoops);
      readOnlyProperty(_assertThisInitialized(_this), 'implementation', function () {
        return 'graphology';
      });
      return _this;
    }
    var _proto = Graph.prototype;
    _proto._resetInstanceCounters = function _resetInstanceCounters() {
      this._directedSize = 0;
      this._undirectedSize = 0;
      this._directedSelfLoopCount = 0;
      this._undirectedSelfLoopCount = 0;
    }

    /**---------------------------------------------------------------------------
     * Read
     **---------------------------------------------------------------------------
     */

    /**
     * Method returning whether the given node is found in the graph.
     *
     * @param  {any}     node - The node.
     * @return {boolean}
     */;
    _proto.hasNode = function hasNode(node) {
      return this._nodes.has('' + node);
    }

    /**
     * Method returning whether the given directed edge is found in the graph.
     *
     * Arity 1:
     * @param  {any}     edge - The edge's key.
     *
     * Arity 2:
     * @param  {any}     source - The edge's source.
     * @param  {any}     target - The edge's target.
     *
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the arguments are invalid.
     */;
    _proto.hasDirectedEdge = function hasDirectedEdge(source, target) {
      // Early termination
      if (this.type === 'undirected') return false;
      if (arguments.length === 1) {
        var edge = '' + source;
        var edgeData = this._edges.get(edge);
        return !!edgeData && !edgeData.undirected;
      } else if (arguments.length === 2) {
        source = '' + source;
        target = '' + target;

        // If the node source or the target is not in the graph we break
        var nodeData = this._nodes.get(source);
        if (!nodeData) return false;

        // Is there a directed edge pointing toward target?
        return nodeData.out.hasOwnProperty(target);
      }
      throw new InvalidArgumentsGraphError("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."));
    }

    /**
     * Method returning whether the given undirected edge is found in the graph.
     *
     * Arity 1:
     * @param  {any}     edge - The edge's key.
     *
     * Arity 2:
     * @param  {any}     source - The edge's source.
     * @param  {any}     target - The edge's target.
     *
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the arguments are invalid.
     */;
    _proto.hasUndirectedEdge = function hasUndirectedEdge(source, target) {
      // Early termination
      if (this.type === 'directed') return false;
      if (arguments.length === 1) {
        var edge = '' + source;
        var edgeData = this._edges.get(edge);
        return !!edgeData && edgeData.undirected;
      } else if (arguments.length === 2) {
        source = '' + source;
        target = '' + target;

        // If the node source or the target is not in the graph we break
        var nodeData = this._nodes.get(source);
        if (!nodeData) return false;

        // Is there a directed edge pointing toward target?
        return nodeData.undirected.hasOwnProperty(target);
      }
      throw new InvalidArgumentsGraphError("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."));
    }

    /**
     * Method returning whether the given edge is found in the graph.
     *
     * Arity 1:
     * @param  {any}     edge - The edge's key.
     *
     * Arity 2:
     * @param  {any}     source - The edge's source.
     * @param  {any}     target - The edge's target.
     *
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the arguments are invalid.
     */;
    _proto.hasEdge = function hasEdge(source, target) {
      if (arguments.length === 1) {
        var edge = '' + source;
        return this._edges.has(edge);
      } else if (arguments.length === 2) {
        source = '' + source;
        target = '' + target;

        // If the node source or the target is not in the graph we break
        var nodeData = this._nodes.get(source);
        if (!nodeData) return false;

        // Is there a directed edge pointing toward target?
        return typeof nodeData.out !== 'undefined' && nodeData.out.hasOwnProperty(target) || typeof nodeData.undirected !== 'undefined' && nodeData.undirected.hasOwnProperty(target);
      }
      throw new InvalidArgumentsGraphError("Graph.hasEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."));
    }

    /**
     * Method returning the edge matching source & target in a directed fashion.
     *
     * @param  {any} source - The edge's source.
     * @param  {any} target - The edge's target.
     *
     * @return {any|undefined}
     *
     * @throws {Error} - Will throw if the graph is multi.
     * @throws {Error} - Will throw if source or target doesn't exist.
     */;
    _proto.directedEdge = function directedEdge(source, target) {
      if (this.type === 'undirected') return;
      source = '' + source;
      target = '' + target;
      if (this.multi) throw new UsageGraphError('Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.');
      var sourceData = this._nodes.get(source);
      if (!sourceData) throw new NotFoundGraphError("Graph.directedEdge: could not find the \"".concat(source, "\" source node in the graph."));
      if (!this._nodes.has(target)) throw new NotFoundGraphError("Graph.directedEdge: could not find the \"".concat(target, "\" target node in the graph."));
      var edgeData = sourceData.out && sourceData.out[target] || undefined;
      if (edgeData) return edgeData.key;
    }

    /**
     * Method returning the edge matching source & target in a undirected fashion.
     *
     * @param  {any} source - The edge's source.
     * @param  {any} target - The edge's target.
     *
     * @return {any|undefined}
     *
     * @throws {Error} - Will throw if the graph is multi.
     * @throws {Error} - Will throw if source or target doesn't exist.
     */;
    _proto.undirectedEdge = function undirectedEdge(source, target) {
      if (this.type === 'directed') return;
      source = '' + source;
      target = '' + target;
      if (this.multi) throw new UsageGraphError('Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.');
      var sourceData = this._nodes.get(source);
      if (!sourceData) throw new NotFoundGraphError("Graph.undirectedEdge: could not find the \"".concat(source, "\" source node in the graph."));
      if (!this._nodes.has(target)) throw new NotFoundGraphError("Graph.undirectedEdge: could not find the \"".concat(target, "\" target node in the graph."));
      var edgeData = sourceData.undirected && sourceData.undirected[target] || undefined;
      if (edgeData) return edgeData.key;
    }

    /**
     * Method returning the edge matching source & target in a mixed fashion.
     *
     * @param  {any} source - The edge's source.
     * @param  {any} target - The edge's target.
     *
     * @return {any|undefined}
     *
     * @throws {Error} - Will throw if the graph is multi.
     * @throws {Error} - Will throw if source or target doesn't exist.
     */;
    _proto.edge = function edge(source, target) {
      if (this.multi) throw new UsageGraphError('Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.');
      source = '' + source;
      target = '' + target;
      var sourceData = this._nodes.get(source);
      if (!sourceData) throw new NotFoundGraphError("Graph.edge: could not find the \"".concat(source, "\" source node in the graph."));
      if (!this._nodes.has(target)) throw new NotFoundGraphError("Graph.edge: could not find the \"".concat(target, "\" target node in the graph."));
      var edgeData = sourceData.out && sourceData.out[target] || sourceData.undirected && sourceData.undirected[target] || undefined;
      if (edgeData) return edgeData.key;
    }

    /**
     * Method returning whether two nodes are directed neighbors.
     *
     * @param  {any}     node     - The node's key.
     * @param  {any}     neighbor - The neighbor's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.areDirectedNeighbors = function areDirectedNeighbors(node, neighbor) {
      node = '' + node;
      neighbor = '' + neighbor;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.areDirectedNeighbors: could not find the \"".concat(node, "\" node in the graph."));
      if (this.type === 'undirected') return false;
      return neighbor in nodeData["in"] || neighbor in nodeData.out;
    }

    /**
     * Method returning whether two nodes are out neighbors.
     *
     * @param  {any}     node     - The node's key.
     * @param  {any}     neighbor - The neighbor's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.areOutNeighbors = function areOutNeighbors(node, neighbor) {
      node = '' + node;
      neighbor = '' + neighbor;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.areOutNeighbors: could not find the \"".concat(node, "\" node in the graph."));
      if (this.type === 'undirected') return false;
      return neighbor in nodeData.out;
    }

    /**
     * Method returning whether two nodes are in neighbors.
     *
     * @param  {any}     node     - The node's key.
     * @param  {any}     neighbor - The neighbor's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.areInNeighbors = function areInNeighbors(node, neighbor) {
      node = '' + node;
      neighbor = '' + neighbor;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.areInNeighbors: could not find the \"".concat(node, "\" node in the graph."));
      if (this.type === 'undirected') return false;
      return neighbor in nodeData["in"];
    }

    /**
     * Method returning whether two nodes are undirected neighbors.
     *
     * @param  {any}     node     - The node's key.
     * @param  {any}     neighbor - The neighbor's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.areUndirectedNeighbors = function areUndirectedNeighbors(node, neighbor) {
      node = '' + node;
      neighbor = '' + neighbor;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.areUndirectedNeighbors: could not find the \"".concat(node, "\" node in the graph."));
      if (this.type === 'directed') return false;
      return neighbor in nodeData.undirected;
    }

    /**
     * Method returning whether two nodes are neighbors.
     *
     * @param  {any}     node     - The node's key.
     * @param  {any}     neighbor - The neighbor's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.areNeighbors = function areNeighbors(node, neighbor) {
      node = '' + node;
      neighbor = '' + neighbor;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.areNeighbors: could not find the \"".concat(node, "\" node in the graph."));
      if (this.type !== 'undirected') {
        if (neighbor in nodeData["in"] || neighbor in nodeData.out) return true;
      }
      if (this.type !== 'directed') {
        if (neighbor in nodeData.undirected) return true;
      }
      return false;
    }

    /**
     * Method returning whether two nodes are inbound neighbors.
     *
     * @param  {any}     node     - The node's key.
     * @param  {any}     neighbor - The neighbor's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.areInboundNeighbors = function areInboundNeighbors(node, neighbor) {
      node = '' + node;
      neighbor = '' + neighbor;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.areInboundNeighbors: could not find the \"".concat(node, "\" node in the graph."));
      if (this.type !== 'undirected') {
        if (neighbor in nodeData["in"]) return true;
      }
      if (this.type !== 'directed') {
        if (neighbor in nodeData.undirected) return true;
      }
      return false;
    }

    /**
     * Method returning whether two nodes are outbound neighbors.
     *
     * @param  {any}     node     - The node's key.
     * @param  {any}     neighbor - The neighbor's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.areOutboundNeighbors = function areOutboundNeighbors(node, neighbor) {
      node = '' + node;
      neighbor = '' + neighbor;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.areOutboundNeighbors: could not find the \"".concat(node, "\" node in the graph."));
      if (this.type !== 'undirected') {
        if (neighbor in nodeData.out) return true;
      }
      if (this.type !== 'directed') {
        if (neighbor in nodeData.undirected) return true;
      }
      return false;
    }

    /**
     * Method returning the given node's in degree.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's in degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.inDegree = function inDegree(node) {
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.inDegree: could not find the \"".concat(node, "\" node in the graph."));
      if (this.type === 'undirected') return 0;
      return nodeData.inDegree;
    }

    /**
     * Method returning the given node's out degree.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's in degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.outDegree = function outDegree(node) {
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.outDegree: could not find the \"".concat(node, "\" node in the graph."));
      if (this.type === 'undirected') return 0;
      return nodeData.outDegree;
    }

    /**
     * Method returning the given node's directed degree.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's in degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.directedDegree = function directedDegree(node) {
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.directedDegree: could not find the \"".concat(node, "\" node in the graph."));
      if (this.type === 'undirected') return 0;
      return nodeData.inDegree + nodeData.outDegree;
    }

    /**
     * Method returning the given node's undirected degree.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's in degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.undirectedDegree = function undirectedDegree(node) {
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.undirectedDegree: could not find the \"".concat(node, "\" node in the graph."));
      if (this.type === 'directed') return 0;
      return nodeData.undirectedDegree;
    }

    /**
     * Method returning the given node's inbound degree.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's inbound degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.inboundDegree = function inboundDegree(node) {
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.inboundDegree: could not find the \"".concat(node, "\" node in the graph."));
      var degree = 0;
      if (this.type !== 'directed') {
        degree += nodeData.undirectedDegree;
      }
      if (this.type !== 'undirected') {
        degree += nodeData.inDegree;
      }
      return degree;
    }

    /**
     * Method returning the given node's outbound degree.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's outbound degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.outboundDegree = function outboundDegree(node) {
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.outboundDegree: could not find the \"".concat(node, "\" node in the graph."));
      var degree = 0;
      if (this.type !== 'directed') {
        degree += nodeData.undirectedDegree;
      }
      if (this.type !== 'undirected') {
        degree += nodeData.outDegree;
      }
      return degree;
    }

    /**
     * Method returning the given node's directed degree.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.degree = function degree(node) {
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.degree: could not find the \"".concat(node, "\" node in the graph."));
      var degree = 0;
      if (this.type !== 'directed') {
        degree += nodeData.undirectedDegree;
      }
      if (this.type !== 'undirected') {
        degree += nodeData.inDegree + nodeData.outDegree;
      }
      return degree;
    }

    /**
     * Method returning the given node's in degree without considering self loops.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's in degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.inDegreeWithoutSelfLoops = function inDegreeWithoutSelfLoops(node) {
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.inDegreeWithoutSelfLoops: could not find the \"".concat(node, "\" node in the graph."));
      if (this.type === 'undirected') return 0;
      return nodeData.inDegree - nodeData.directedLoops;
    }

    /**
     * Method returning the given node's out degree without considering self loops.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's in degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.outDegreeWithoutSelfLoops = function outDegreeWithoutSelfLoops(node) {
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.outDegreeWithoutSelfLoops: could not find the \"".concat(node, "\" node in the graph."));
      if (this.type === 'undirected') return 0;
      return nodeData.outDegree - nodeData.directedLoops;
    }

    /**
     * Method returning the given node's directed degree without considering self loops.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's in degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.directedDegreeWithoutSelfLoops = function directedDegreeWithoutSelfLoops(node) {
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.directedDegreeWithoutSelfLoops: could not find the \"".concat(node, "\" node in the graph."));
      if (this.type === 'undirected') return 0;
      return nodeData.inDegree + nodeData.outDegree - nodeData.directedLoops * 2;
    }

    /**
     * Method returning the given node's undirected degree without considering self loops.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's in degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.undirectedDegreeWithoutSelfLoops = function undirectedDegreeWithoutSelfLoops(node) {
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.undirectedDegreeWithoutSelfLoops: could not find the \"".concat(node, "\" node in the graph."));
      if (this.type === 'directed') return 0;
      return nodeData.undirectedDegree - nodeData.undirectedLoops * 2;
    }

    /**
     * Method returning the given node's inbound degree without considering self loops.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's inbound degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.inboundDegreeWithoutSelfLoops = function inboundDegreeWithoutSelfLoops(node) {
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.inboundDegreeWithoutSelfLoops: could not find the \"".concat(node, "\" node in the graph."));
      var degree = 0;
      var loops = 0;
      if (this.type !== 'directed') {
        degree += nodeData.undirectedDegree;
        loops += nodeData.undirectedLoops * 2;
      }
      if (this.type !== 'undirected') {
        degree += nodeData.inDegree;
        loops += nodeData.directedLoops;
      }
      return degree - loops;
    }

    /**
     * Method returning the given node's outbound degree without considering self loops.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's outbound degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.outboundDegreeWithoutSelfLoops = function outboundDegreeWithoutSelfLoops(node) {
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.outboundDegreeWithoutSelfLoops: could not find the \"".concat(node, "\" node in the graph."));
      var degree = 0;
      var loops = 0;
      if (this.type !== 'directed') {
        degree += nodeData.undirectedDegree;
        loops += nodeData.undirectedLoops * 2;
      }
      if (this.type !== 'undirected') {
        degree += nodeData.outDegree;
        loops += nodeData.directedLoops;
      }
      return degree - loops;
    }

    /**
     * Method returning the given node's directed degree without considering self loops.
     *
     * @param  {any}     node - The node's key.
     * @return {number}       - The node's degree.
     *
     * @throws {Error} - Will throw if the node isn't in the graph.
     */;
    _proto.degreeWithoutSelfLoops = function degreeWithoutSelfLoops(node) {
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.degreeWithoutSelfLoops: could not find the \"".concat(node, "\" node in the graph."));
      var degree = 0;
      var loops = 0;
      if (this.type !== 'directed') {
        degree += nodeData.undirectedDegree;
        loops += nodeData.undirectedLoops * 2;
      }
      if (this.type !== 'undirected') {
        degree += nodeData.inDegree + nodeData.outDegree;
        loops += nodeData.directedLoops * 2;
      }
      return degree - loops;
    }

    /**
     * Method returning the given edge's source.
     *
     * @param  {any} edge - The edge's key.
     * @return {any}      - The edge's source.
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */;
    _proto.source = function source(edge) {
      edge = '' + edge;
      var data = this._edges.get(edge);
      if (!data) throw new NotFoundGraphError("Graph.source: could not find the \"".concat(edge, "\" edge in the graph."));
      return data.source.key;
    }

    /**
     * Method returning the given edge's target.
     *
     * @param  {any} edge - The edge's key.
     * @return {any}      - The edge's target.
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */;
    _proto.target = function target(edge) {
      edge = '' + edge;
      var data = this._edges.get(edge);
      if (!data) throw new NotFoundGraphError("Graph.target: could not find the \"".concat(edge, "\" edge in the graph."));
      return data.target.key;
    }

    /**
     * Method returning the given edge's extremities.
     *
     * @param  {any}   edge - The edge's key.
     * @return {array}      - The edge's extremities.
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */;
    _proto.extremities = function extremities(edge) {
      edge = '' + edge;
      var edgeData = this._edges.get(edge);
      if (!edgeData) throw new NotFoundGraphError("Graph.extremities: could not find the \"".concat(edge, "\" edge in the graph."));
      return [edgeData.source.key, edgeData.target.key];
    }

    /**
     * Given a node & an edge, returns the other extremity of the edge.
     *
     * @param  {any}   node - The node's key.
     * @param  {any}   edge - The edge's key.
     * @return {any}        - The related node.
     *
     * @throws {Error} - Will throw if the edge isn't in the graph or if the
     *                   edge & node are not related.
     */;
    _proto.opposite = function opposite(node, edge) {
      node = '' + node;
      edge = '' + edge;
      var data = this._edges.get(edge);
      if (!data) throw new NotFoundGraphError("Graph.opposite: could not find the \"".concat(edge, "\" edge in the graph."));
      var source = data.source.key;
      var target = data.target.key;
      if (node === source) return target;
      if (node === target) return source;
      throw new NotFoundGraphError("Graph.opposite: the \"".concat(node, "\" node is not attached to the \"").concat(edge, "\" edge (").concat(source, ", ").concat(target, ")."));
    }

    /**
     * Returns whether the given edge has the given node as extremity.
     *
     * @param  {any}     edge - The edge's key.
     * @param  {any}     node - The node's key.
     * @return {boolean}      - The related node.
     *
     * @throws {Error} - Will throw if either the node or the edge isn't in the graph.
     */;
    _proto.hasExtremity = function hasExtremity(edge, node) {
      edge = '' + edge;
      node = '' + node;
      var data = this._edges.get(edge);
      if (!data) throw new NotFoundGraphError("Graph.hasExtremity: could not find the \"".concat(edge, "\" edge in the graph."));
      return data.source.key === node || data.target.key === node;
    }

    /**
     * Method returning whether the given edge is undirected.
     *
     * @param  {any}     edge - The edge's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */;
    _proto.isUndirected = function isUndirected(edge) {
      edge = '' + edge;
      var data = this._edges.get(edge);
      if (!data) throw new NotFoundGraphError("Graph.isUndirected: could not find the \"".concat(edge, "\" edge in the graph."));
      return data.undirected;
    }

    /**
     * Method returning whether the given edge is directed.
     *
     * @param  {any}     edge - The edge's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */;
    _proto.isDirected = function isDirected(edge) {
      edge = '' + edge;
      var data = this._edges.get(edge);
      if (!data) throw new NotFoundGraphError("Graph.isDirected: could not find the \"".concat(edge, "\" edge in the graph."));
      return !data.undirected;
    }

    /**
     * Method returning whether the given edge is a self loop.
     *
     * @param  {any}     edge - The edge's key.
     * @return {boolean}
     *
     * @throws {Error} - Will throw if the edge isn't in the graph.
     */;
    _proto.isSelfLoop = function isSelfLoop(edge) {
      edge = '' + edge;
      var data = this._edges.get(edge);
      if (!data) throw new NotFoundGraphError("Graph.isSelfLoop: could not find the \"".concat(edge, "\" edge in the graph."));
      return data.source === data.target;
    }

    /**---------------------------------------------------------------------------
     * Mutation
     **---------------------------------------------------------------------------
     */

    /**
     * Method used to add a node to the graph.
     *
     * @param  {any}    node         - The node.
     * @param  {object} [attributes] - Optional attributes.
     * @return {any}                 - The node.
     *
     * @throws {Error} - Will throw if the given node already exist.
     * @throws {Error} - Will throw if the given attributes are not an object.
     */;
    _proto.addNode = function addNode(node, attributes) {
      var nodeData = _addNode(this, node, attributes);
      return nodeData.key;
    }

    /**
     * Method used to merge a node into the graph.
     *
     * @param  {any}    node         - The node.
     * @param  {object} [attributes] - Optional attributes.
     * @return {any}                 - The node.
     */;
    _proto.mergeNode = function mergeNode(node, attributes) {
      if (attributes && !isPlainObject(attributes)) throw new InvalidArgumentsGraphError("Graph.mergeNode: invalid attributes. Expecting an object but got \"".concat(attributes, "\""));

      // String coercion
      node = '' + node;
      attributes = attributes || {};

      // If the node already exists, we merge the attributes
      var data = this._nodes.get(node);
      if (data) {
        if (attributes) {
          assign(data.attributes, attributes);
          this.emit('nodeAttributesUpdated', {
            type: 'merge',
            key: node,
            attributes: data.attributes,
            data: attributes
          });
        }
        return [node, false];
      }
      data = new this.NodeDataClass(node, attributes);

      // Adding the node to internal register
      this._nodes.set(node, data);

      // Emitting
      this.emit('nodeAdded', {
        key: node,
        attributes: attributes
      });
      return [node, true];
    }

    /**
     * Method used to add a node if it does not exist in the graph or else to
     * update its attributes using a function.
     *
     * @param  {any}      node      - The node.
     * @param  {function} [updater] - Optional updater function.
     * @return {any}                - The node.
     */;
    _proto.updateNode = function updateNode(node, updater) {
      if (updater && typeof updater !== 'function') throw new InvalidArgumentsGraphError("Graph.updateNode: invalid updater function. Expecting a function but got \"".concat(updater, "\""));

      // String coercion
      node = '' + node;

      // If the node already exists, we update the attributes
      var data = this._nodes.get(node);
      if (data) {
        if (updater) {
          var oldAttributes = data.attributes;
          data.attributes = updater(oldAttributes);
          this.emit('nodeAttributesUpdated', {
            type: 'replace',
            key: node,
            attributes: data.attributes
          });
        }
        return [node, false];
      }
      var attributes = updater ? updater({}) : {};
      data = new this.NodeDataClass(node, attributes);

      // Adding the node to internal register
      this._nodes.set(node, data);

      // Emitting
      this.emit('nodeAdded', {
        key: node,
        attributes: attributes
      });
      return [node, true];
    }

    /**
     * Method used to drop a single node & all its attached edges from the graph.
     *
     * @param  {any}    node - The node.
     * @return {Graph}
     *
     * @throws {Error} - Will throw if the node doesn't exist.
     */;
    _proto.dropNode = function dropNode(node) {
      node = '' + node;
      var nodeData = this._nodes.get(node);
      if (!nodeData) throw new NotFoundGraphError("Graph.dropNode: could not find the \"".concat(node, "\" node in the graph."));
      var edgeData;

      // Removing attached edges
      // NOTE: we could be faster here, but this is such a pain to maintain
      if (this.type !== 'undirected') {
        for (var neighbor in nodeData.out) {
          edgeData = nodeData.out[neighbor];
          do {
            dropEdgeFromData(this, edgeData);
            edgeData = edgeData.next;
          } while (edgeData);
        }
        for (var _neighbor in nodeData["in"]) {
          edgeData = nodeData["in"][_neighbor];
          do {
            dropEdgeFromData(this, edgeData);
            edgeData = edgeData.next;
          } while (edgeData);
        }
      }
      if (this.type !== 'directed') {
        for (var _neighbor2 in nodeData.undirected) {
          edgeData = nodeData.undirected[_neighbor2];
          do {
            dropEdgeFromData(this, edgeData);
            edgeData = edgeData.next;
          } while (edgeData);
        }
      }

      // Dropping the node from the register
      this._nodes["delete"](node);

      // Emitting
      this.emit('nodeDropped', {
        key: node,
        attributes: nodeData.attributes
      });
    }

    /**
     * Method used to drop a single edge from the graph.
     *
     * Arity 1:
     * @param  {any}    edge - The edge.
     *
     * Arity 2:
     * @param  {any}    source - Source node.
     * @param  {any}    target - Target node.
     *
     * @return {Graph}
     *
     * @throws {Error} - Will throw if the edge doesn't exist.
     */;
    _proto.dropEdge = function dropEdge(edge) {
      var edgeData;
      if (arguments.length > 1) {
        var source = '' + arguments[0];
        var target = '' + arguments[1];
        edgeData = getMatchingEdge(this, source, target, this.type);
        if (!edgeData) throw new NotFoundGraphError("Graph.dropEdge: could not find the \"".concat(source, "\" -> \"").concat(target, "\" edge in the graph."));
      } else {
        edge = '' + edge;
        edgeData = this._edges.get(edge);
        if (!edgeData) throw new NotFoundGraphError("Graph.dropEdge: could not find the \"".concat(edge, "\" edge in the graph."));
      }
      dropEdgeFromData(this, edgeData);
      return this;
    }

    /**
     * Method used to drop a single directed edge from the graph.
     *
     * @param  {any}    source - Source node.
     * @param  {any}    target - Target node.
     *
     * @return {Graph}
     *
     * @throws {Error} - Will throw if the edge doesn't exist.
     */;
    _proto.dropDirectedEdge = function dropDirectedEdge(source, target) {
      if (arguments.length < 2) throw new UsageGraphError('Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.');
      if (this.multi) throw new UsageGraphError('Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.');
      source = '' + source;
      target = '' + target;
      var edgeData = getMatchingEdge(this, source, target, 'directed');
      if (!edgeData) throw new NotFoundGraphError("Graph.dropDirectedEdge: could not find a \"".concat(source, "\" -> \"").concat(target, "\" edge in the graph."));
      dropEdgeFromData(this, edgeData);
      return this;
    }

    /**
     * Method used to drop a single undirected edge from the graph.
     *
     * @param  {any}    source - Source node.
     * @param  {any}    target - Target node.
     *
     * @return {Graph}
     *
     * @throws {Error} - Will throw if the edge doesn't exist.
     */;
    _proto.dropUndirectedEdge = function dropUndirectedEdge(source, target) {
      if (arguments.length < 2) throw new UsageGraphError('Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.');
      if (this.multi) throw new UsageGraphError('Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.');
      var edgeData = getMatchingEdge(this, source, target, 'undirected');
      if (!edgeData) throw new NotFoundGraphError("Graph.dropUndirectedEdge: could not find a \"".concat(source, "\" -> \"").concat(target, "\" edge in the graph."));
      dropEdgeFromData(this, edgeData);
      return this;
    }

    /**
     * Method used to remove every edge & every node from the graph.
     *
     * @return {Graph}
     */;
    _proto.clear = function clear() {
      // Clearing edges
      this._edges.clear();

      // Clearing nodes
      this._nodes.clear();

      // Reset counters
      this._resetInstanceCounters();

      // Emitting
      this.emit('cleared');
    }

    /**
     * Method used to remove every edge from the graph.
     *
     * @return {Graph}
     */;
    _proto.clearEdges = function clearEdges() {
      // Clearing structure index
      var iterator = this._nodes.values();
      var step;
      while (step = iterator.next(), step.done !== true) {
        step.value.clear();
      }

      // Clearing edges
      this._edges.clear();

      // Reset counters
      this._resetInstanceCounters();

      // Emitting
      this.emit('edgesCleared');
    }

    /**---------------------------------------------------------------------------
     * Attributes-related methods
     **---------------------------------------------------------------------------
     */

    /**
     * Method returning the desired graph's attribute.
     *
     * @param  {string} name - Name of the attribute.
     * @return {any}
     */;
    _proto.getAttribute = function getAttribute(name) {
      return this._attributes[name];
    }

    /**
     * Method returning the graph's attributes.
     *
     * @return {object}
     */;
    _proto.getAttributes = function getAttributes() {
      return this._attributes;
    }

    /**
     * Method returning whether the graph has the desired attribute.
     *
     * @param  {string}  name - Name of the attribute.
     * @return {boolean}
     */;
    _proto.hasAttribute = function hasAttribute(name) {
      return this._attributes.hasOwnProperty(name);
    }

    /**
     * Method setting a value for the desired graph's attribute.
     *
     * @param  {string}  name  - Name of the attribute.
     * @param  {any}     value - Value for the attribute.
     * @return {Graph}
     */;
    _proto.setAttribute = function setAttribute(name, value) {
      this._attributes[name] = value;

      // Emitting
      this.emit('attributesUpdated', {
        type: 'set',
        attributes: this._attributes,
        name: name
      });
      return this;
    }

    /**
     * Method using a function to update the desired graph's attribute's value.
     *
     * @param  {string}   name    - Name of the attribute.
     * @param  {function} updater - Function use to update the attribute's value.
     * @return {Graph}
     */;
    _proto.updateAttribute = function updateAttribute(name, updater) {
      if (typeof updater !== 'function') throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');
      var value = this._attributes[name];
      this._attributes[name] = updater(value);

      // Emitting
      this.emit('attributesUpdated', {
        type: 'set',
        attributes: this._attributes,
        name: name
      });
      return this;
    }

    /**
     * Method removing the desired graph's attribute.
     *
     * @param  {string} name  - Name of the attribute.
     * @return {Graph}
     */;
    _proto.removeAttribute = function removeAttribute(name) {
      delete this._attributes[name];

      // Emitting
      this.emit('attributesUpdated', {
        type: 'remove',
        attributes: this._attributes,
        name: name
      });
      return this;
    }

    /**
     * Method replacing the graph's attributes.
     *
     * @param  {object} attributes - New attributes.
     * @return {Graph}
     *
     * @throws {Error} - Will throw if given attributes are not a plain object.
     */;
    _proto.replaceAttributes = function replaceAttributes(attributes) {
      if (!isPlainObject(attributes)) throw new InvalidArgumentsGraphError('Graph.replaceAttributes: provided attributes are not a plain object.');
      this._attributes = attributes;

      // Emitting
      this.emit('attributesUpdated', {
        type: 'replace',
        attributes: this._attributes
      });
      return this;
    }

    /**
     * Method merging the graph's attributes.
     *
     * @param  {object} attributes - Attributes to merge.
     * @return {Graph}
     *
     * @throws {Error} - Will throw if given attributes are not a plain object.
     */;
    _proto.mergeAttributes = function mergeAttributes(attributes) {
      if (!isPlainObject(attributes)) throw new InvalidArgumentsGraphError('Graph.mergeAttributes: provided attributes are not a plain object.');
      assign(this._attributes, attributes);

      // Emitting
      this.emit('attributesUpdated', {
        type: 'merge',
        attributes: this._attributes,
        data: attributes
      });
      return this;
    }

    /**
     * Method updating the graph's attributes.
     *
     * @param  {function} updater - Function used to update the attributes.
     * @return {Graph}
     *
     * @throws {Error} - Will throw if given updater is not a function.
     */;
    _proto.updateAttributes = function updateAttributes(updater) {
      if (typeof updater !== 'function') throw new InvalidArgumentsGraphError('Graph.updateAttributes: provided updater is not a function.');
      this._attributes = updater(this._attributes);

      // Emitting
      this.emit('attributesUpdated', {
        type: 'update',
        attributes: this._attributes
      });
      return this;
    }

    /**
     * Method used to update each node's attributes using the given function.
     *
     * @param {function}  updater - Updater function to use.
     * @param {object}    [hints] - Optional hints.
     */;
    _proto.updateEachNodeAttributes = function updateEachNodeAttributes(updater, hints) {
      if (typeof updater !== 'function') throw new InvalidArgumentsGraphError('Graph.updateEachNodeAttributes: expecting an updater function.');
      if (hints && !validateHints(hints)) throw new InvalidArgumentsGraphError('Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}');
      var iterator = this._nodes.values();
      var step, nodeData;
      while (step = iterator.next(), step.done !== true) {
        nodeData = step.value;
        nodeData.attributes = updater(nodeData.key, nodeData.attributes);
      }
      this.emit('eachNodeAttributesUpdated', {
        hints: hints ? hints : null
      });
    }

    /**
     * Method used to update each edge's attributes using the given function.
     *
     * @param {function}  updater - Updater function to use.
     * @param {object}    [hints] - Optional hints.
     */;
    _proto.updateEachEdgeAttributes = function updateEachEdgeAttributes(updater, hints) {
      if (typeof updater !== 'function') throw new InvalidArgumentsGraphError('Graph.updateEachEdgeAttributes: expecting an updater function.');
      if (hints && !validateHints(hints)) throw new InvalidArgumentsGraphError('Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}');
      var iterator = this._edges.values();
      var step, edgeData, sourceData, targetData;
      while (step = iterator.next(), step.done !== true) {
        edgeData = step.value;
        sourceData = edgeData.source;
        targetData = edgeData.target;
        edgeData.attributes = updater(edgeData.key, edgeData.attributes, sourceData.key, targetData.key, sourceData.attributes, targetData.attributes, edgeData.undirected);
      }
      this.emit('eachEdgeAttributesUpdated', {
        hints: hints ? hints : null
      });
    }

    /**---------------------------------------------------------------------------
     * Iteration-related methods
     **---------------------------------------------------------------------------
     */

    /**
     * Method iterating over the graph's adjacency using the given callback.
     *
     * @param  {function}  callback - Callback to use.
     */;
    _proto.forEachAdjacencyEntry = function forEachAdjacencyEntry(callback) {
      if (typeof callback !== 'function') throw new InvalidArgumentsGraphError('Graph.forEachAdjacencyEntry: expecting a callback.');
      forEachAdjacency(false, false, false, this, callback);
    };
    _proto.forEachAdjacencyEntryWithOrphans = function forEachAdjacencyEntryWithOrphans(callback) {
      if (typeof callback !== 'function') throw new InvalidArgumentsGraphError('Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.');
      forEachAdjacency(false, false, true, this, callback);
    }

    /**
     * Method iterating over the graph's assymetric adjacency using the given callback.
     *
     * @param  {function}  callback - Callback to use.
     */;
    _proto.forEachAssymetricAdjacencyEntry = function forEachAssymetricAdjacencyEntry(callback) {
      if (typeof callback !== 'function') throw new InvalidArgumentsGraphError('Graph.forEachAssymetricAdjacencyEntry: expecting a callback.');
      forEachAdjacency(false, true, false, this, callback);
    };
    _proto.forEachAssymetricAdjacencyEntryWithOrphans = function forEachAssymetricAdjacencyEntryWithOrphans(callback) {
      if (typeof callback !== 'function') throw new InvalidArgumentsGraphError('Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.');
      forEachAdjacency(false, true, true, this, callback);
    }

    /**
     * Method returning the list of the graph's nodes.
     *
     * @return {array} - The nodes.
     */;
    _proto.nodes = function nodes() {
      if (typeof Array.from === 'function') return Array.from(this._nodes.keys());
      return take(this._nodes.keys(), this._nodes.size);
    }

    /**
     * Method iterating over the graph's nodes using the given callback.
     *
     * @param  {function}  callback - Callback (key, attributes, index).
     */;
    _proto.forEachNode = function forEachNode(callback) {
      if (typeof callback !== 'function') throw new InvalidArgumentsGraphError('Graph.forEachNode: expecting a callback.');
      var iterator = this._nodes.values();
      var step, nodeData;
      while (step = iterator.next(), step.done !== true) {
        nodeData = step.value;
        callback(nodeData.key, nodeData.attributes);
      }
    }

    /**
     * Method iterating attempting to find a node matching the given predicate
     * function.
     *
     * @param  {function}  callback - Callback (key, attributes).
     */;
    _proto.findNode = function findNode(callback) {
      if (typeof callback !== 'function') throw new InvalidArgumentsGraphError('Graph.findNode: expecting a callback.');
      var iterator = this._nodes.values();
      var step, nodeData;
      while (step = iterator.next(), step.done !== true) {
        nodeData = step.value;
        if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;
      }
      return;
    }

    /**
     * Method mapping nodes.
     *
     * @param  {function}  callback - Callback (key, attributes).
     */;
    _proto.mapNodes = function mapNodes(callback) {
      if (typeof callback !== 'function') throw new InvalidArgumentsGraphError('Graph.mapNode: expecting a callback.');
      var iterator = this._nodes.values();
      var step, nodeData;
      var result = new Array(this.order);
      var i = 0;
      while (step = iterator.next(), step.done !== true) {
        nodeData = step.value;
        result[i++] = callback(nodeData.key, nodeData.attributes);
      }
      return result;
    }

    /**
     * Method returning whether some node verify the given predicate.
     *
     * @param  {function}  callback - Callback (key, attributes).
     */;
    _proto.someNode = function someNode(callback) {
      if (typeof callback !== 'function') throw new InvalidArgumentsGraphError('Graph.someNode: expecting a callback.');
      var iterator = this._nodes.values();
      var step, nodeData;
      while (step = iterator.next(), step.done !== true) {
        nodeData = step.value;
        if (callback(nodeData.key, nodeData.attributes)) return true;
      }
      return false;
    }

    /**
     * Method returning whether all node verify the given predicate.
     *
     * @param  {function}  callback - Callback (key, attributes).
     */;
    _proto.everyNode = function everyNode(callback) {
      if (typeof callback !== 'function') throw new InvalidArgumentsGraphError('Graph.everyNode: expecting a callback.');
      var iterator = this._nodes.values();
      var step, nodeData;
      while (step = iterator.next(), step.done !== true) {
        nodeData = step.value;
        if (!callback(nodeData.key, nodeData.attributes)) return false;
      }
      return true;
    }

    /**
     * Method filtering nodes.
     *
     * @param  {function}  callback - Callback (key, attributes).
     */;
    _proto.filterNodes = function filterNodes(callback) {
      if (typeof callback !== 'function') throw new InvalidArgumentsGraphError('Graph.filterNodes: expecting a callback.');
      var iterator = this._nodes.values();
      var step, nodeData;
      var result = [];
      while (step = iterator.next(), step.done !== true) {
        nodeData = step.value;
        if (callback(nodeData.key, nodeData.attributes)) result.push(nodeData.key);
      }
      return result;
    }

    /**
     * Method reducing nodes.
     *
     * @param  {function}  callback - Callback (accumulator, key, attributes).
     */;
    _proto.reduceNodes = function reduceNodes(callback, initialValue) {
      if (typeof callback !== 'function') throw new InvalidArgumentsGraphError('Graph.reduceNodes: expecting a callback.');
      if (arguments.length < 2) throw new InvalidArgumentsGraphError('Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.');
      var accumulator = initialValue;
      var iterator = this._nodes.values();
      var step, nodeData;
      while (step = iterator.next(), step.done !== true) {
        nodeData = step.value;
        accumulator = callback(accumulator, nodeData.key, nodeData.attributes);
      }
      return accumulator;
    }

    /**
     * Method returning an iterator over the graph's node entries.
     *
     * @return {Iterator}
     */;
    _proto.nodeEntries = function nodeEntries() {
      var iterator$1 = this._nodes.values();
      return new iterator(function () {
        var step = iterator$1.next();
        if (step.done) return step;
        var data = step.value;
        return {
          value: {
            node: data.key,
            attributes: data.attributes
          },
          done: false
        };
      });
    }

    /**---------------------------------------------------------------------------
     * Serialization
     **---------------------------------------------------------------------------
     */

    /**
     * Method used to export the whole graph.
     *
     * @return {object} - The serialized graph.
     */;
    _proto["export"] = function _export() {
      var _this2 = this;
      var nodes = new Array(this._nodes.size);
      var i = 0;
      this._nodes.forEach(function (data, key) {
        nodes[i++] = serializeNode(key, data);
      });
      var edges = new Array(this._edges.size);
      i = 0;
      this._edges.forEach(function (data, key) {
        edges[i++] = serializeEdge(_this2.type, key, data);
      });
      return {
        options: {
          type: this.type,
          multi: this.multi,
          allowSelfLoops: this.allowSelfLoops
        },
        attributes: this.getAttributes(),
        nodes: nodes,
        edges: edges
      };
    }

    /**
     * Method used to import a serialized graph.
     *
     * @param  {object|Graph} data  - The serialized graph.
     * @param  {boolean}      merge - Whether to merge data.
     * @return {Graph}              - Returns itself for chaining.
     */;
    _proto["import"] = function _import(data) {
      var _this3 = this;
      var merge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      // Importing a Graph instance directly
      if (data instanceof Graph) {
        // Nodes
        data.forEachNode(function (n, a) {
          if (merge) _this3.mergeNode(n, a);else _this3.addNode(n, a);
        });

        // Edges
        data.forEachEdge(function (e, a, s, t, _sa, _ta, u) {
          if (merge) {
            if (u) _this3.mergeUndirectedEdgeWithKey(e, s, t, a);else _this3.mergeDirectedEdgeWithKey(e, s, t, a);
          } else {
            if (u) _this3.addUndirectedEdgeWithKey(e, s, t, a);else _this3.addDirectedEdgeWithKey(e, s, t, a);
          }
        });
        return this;
      }

      // Importing a serialized graph
      if (!isPlainObject(data)) throw new InvalidArgumentsGraphError('Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.');
      if (data.attributes) {
        if (!isPlainObject(data.attributes)) throw new InvalidArgumentsGraphError('Graph.import: invalid attributes. Expecting a plain object.');
        if (merge) this.mergeAttributes(data.attributes);else this.replaceAttributes(data.attributes);
      }
      var i, l, list, node, edge;
      if (data.nodes) {
        list = data.nodes;
        if (!Array.isArray(list)) throw new InvalidArgumentsGraphError('Graph.import: invalid nodes. Expecting an array.');
        for (i = 0, l = list.length; i < l; i++) {
          node = list[i];

          // Validating
          validateSerializedNode(node);

          // Adding the node
          var _node = node,
            key = _node.key,
            attributes = _node.attributes;
          if (merge) this.mergeNode(key, attributes);else this.addNode(key, attributes);
        }
      }
      if (data.edges) {
        var undirectedByDefault = false;
        if (this.type === 'undirected') {
          undirectedByDefault = true;
        }
        list = data.edges;
        if (!Array.isArray(list)) throw new InvalidArgumentsGraphError('Graph.import: invalid edges. Expecting an array.');
        for (i = 0, l = list.length; i < l; i++) {
          edge = list[i];

          // Validating
          validateSerializedEdge(edge);

          // Adding the edge
          var _edge = edge,
            source = _edge.source,
            target = _edge.target,
            _attributes = _edge.attributes,
            _edge$undirected = _edge.undirected,
            undirected = _edge$undirected === void 0 ? undirectedByDefault : _edge$undirected;
          var method = void 0;
          if ('key' in edge) {
            method = merge ? undirected ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey : undirected ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey;
            method.call(this, edge.key, source, target, _attributes);
          } else {
            method = merge ? undirected ? this.mergeUndirectedEdge : this.mergeDirectedEdge : undirected ? this.addUndirectedEdge : this.addDirectedEdge;
            method.call(this, source, target, _attributes);
          }
        }
      }
      return this;
    }

    /**---------------------------------------------------------------------------
     * Utils
     **---------------------------------------------------------------------------
     */

    /**
     * Method returning a null copy of the graph, i.e. a graph without nodes
     * & edges but with the exact same options.
     *
     * @param  {object} options - Options to merge with the current ones.
     * @return {Graph}          - The null copy.
     */;
    _proto.nullCopy = function nullCopy(options) {
      var graph = new Graph(assign({}, this._options, options));
      graph.replaceAttributes(assign({}, this.getAttributes()));
      return graph;
    }

    /**
     * Method returning an empty copy of the graph, i.e. a graph without edges but
     * with the exact same options.
     *
     * @param  {object} options - Options to merge with the current ones.
     * @return {Graph}          - The empty copy.
     */;
    _proto.emptyCopy = function emptyCopy(options) {
      var graph = this.nullCopy(options);
      this._nodes.forEach(function (nodeData, key) {
        var attributes = assign({}, nodeData.attributes);

        // NOTE: no need to emit events since user cannot access the instance yet
        nodeData = new graph.NodeDataClass(key, attributes);
        graph._nodes.set(key, nodeData);
      });
      return graph;
    }

    /**
     * Method returning an exact copy of the graph.
     *
     * @param  {object} options - Upgrade options.
     * @return {Graph}          - The copy.
     */;
    _proto.copy = function copy(options) {
      options = options || {};
      if (typeof options.type === 'string' && options.type !== this.type && options.type !== 'mixed') throw new UsageGraphError("Graph.copy: cannot create an incompatible copy from \"".concat(this.type, "\" type to \"").concat(options.type, "\" because this would mean losing information about the current graph."));
      if (typeof options.multi === 'boolean' && options.multi !== this.multi && options.multi !== true) throw new UsageGraphError('Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.');
      if (typeof options.allowSelfLoops === 'boolean' && options.allowSelfLoops !== this.allowSelfLoops && options.allowSelfLoops !== true) throw new UsageGraphError('Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.');
      var graph = this.emptyCopy(options);
      var iterator = this._edges.values();
      var step, edgeData;
      while (step = iterator.next(), step.done !== true) {
        edgeData = step.value;

        // NOTE: no need to emit events since user cannot access the instance yet
        addEdge(graph, 'copy', false, edgeData.undirected, edgeData.key, edgeData.source.key, edgeData.target.key, assign({}, edgeData.attributes));
      }
      return graph;
    }

    /**---------------------------------------------------------------------------
     * Known methods
     **---------------------------------------------------------------------------
     */

    /**
     * Method used by JavaScript to perform JSON serialization.
     *
     * @return {object} - The serialized graph.
     */;
    _proto.toJSON = function toJSON() {
      return this["export"]();
    }

    /**
     * Method returning [object Graph].
     */;
    _proto.toString = function toString() {
      return '[object Graph]';
    }

    /**
     * Method used internally by node's console to display a custom object.
     *
     * @return {object} - Formatted object representation of the graph.
     */;
    _proto.inspect = function inspect() {
      var _this4 = this;
      var nodes = {};
      this._nodes.forEach(function (data, key) {
        nodes[key] = data.attributes;
      });
      var edges = {},
        multiIndex = {};
      this._edges.forEach(function (data, key) {
        var direction = data.undirected ? '--' : '->';
        var label = '';
        var source = data.source.key;
        var target = data.target.key;
        var tmp;
        if (data.undirected && source > target) {
          tmp = source;
          source = target;
          target = tmp;
        }
        var desc = "(".concat(source, ")").concat(direction, "(").concat(target, ")");
        if (!key.startsWith('geid_')) {
          label += "[".concat(key, "]: ");
        } else if (_this4.multi) {
          if (typeof multiIndex[desc] === 'undefined') {
            multiIndex[desc] = 0;
          } else {
            multiIndex[desc]++;
          }
          label += "".concat(multiIndex[desc], ". ");
        }
        label += desc;
        edges[label] = data.attributes;
      });
      var dummy = {};
      for (var k in this) {
        if (this.hasOwnProperty(k) && !EMITTER_PROPS.has(k) && typeof this[k] !== 'function' && _typeof(k) !== 'symbol') dummy[k] = this[k];
      }
      dummy.attributes = this._attributes;
      dummy.nodes = nodes;
      dummy.edges = edges;
      privateProperty(dummy, 'constructor', this.constructor);
      return dummy;
    };
    return Graph;
  }(events.exports.EventEmitter);
  if (typeof Symbol !== 'undefined') Graph.prototype[Symbol["for"]('nodejs.util.inspect.custom')] = Graph.prototype.inspect;

  /**
   * Related to edge addition.
   */
  EDGE_ADD_METHODS.forEach(function (method) {
    ['add', 'merge', 'update'].forEach(function (verb) {
      var name = method.name(verb);
      var fn = verb === 'add' ? addEdge : mergeEdge;
      if (method.generateKey) {
        Graph.prototype[name] = function (source, target, attributes) {
          return fn(this, name, true, (method.type || this.type) === 'undirected', null, source, target, attributes, verb === 'update');
        };
      } else {
        Graph.prototype[name] = function (edge, source, target, attributes) {
          return fn(this, name, false, (method.type || this.type) === 'undirected', edge, source, target, attributes, verb === 'update');
        };
      }
    });
  });

  /**
   * Attributes-related.
   */
  attachNodeAttributesMethods(Graph);
  attachEdgeAttributesMethods(Graph);

  /**
   * Edge iteration-related.
   */
  attachEdgeIterationMethods(Graph);

  /**
   * Neighbor iteration-related.
   */
  attachNeighborIterationMethods(Graph);

  /**
   * Alternative constructors.
   */
  var DirectedGraph = /*#__PURE__*/function (_Graph) {
    _inheritsLoose(DirectedGraph, _Graph);
    function DirectedGraph(options) {
      var finalOptions = assign({
        type: 'directed'
      }, options);
      if ('multi' in finalOptions && finalOptions.multi !== false) throw new InvalidArgumentsGraphError('DirectedGraph.from: inconsistent indication that the graph should be multi in given options!');
      if (finalOptions.type !== 'directed') throw new InvalidArgumentsGraphError('DirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!');
      return _Graph.call(this, finalOptions) || this;
    }
    return DirectedGraph;
  }(Graph);
  var UndirectedGraph = /*#__PURE__*/function (_Graph2) {
    _inheritsLoose(UndirectedGraph, _Graph2);
    function UndirectedGraph(options) {
      var finalOptions = assign({
        type: 'undirected'
      }, options);
      if ('multi' in finalOptions && finalOptions.multi !== false) throw new InvalidArgumentsGraphError('UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!');
      if (finalOptions.type !== 'undirected') throw new InvalidArgumentsGraphError('UndirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!');
      return _Graph2.call(this, finalOptions) || this;
    }
    return UndirectedGraph;
  }(Graph);
  var MultiGraph = /*#__PURE__*/function (_Graph3) {
    _inheritsLoose(MultiGraph, _Graph3);
    function MultiGraph(options) {
      var finalOptions = assign({
        multi: true
      }, options);
      if ('multi' in finalOptions && finalOptions.multi !== true) throw new InvalidArgumentsGraphError('MultiGraph.from: inconsistent indication that the graph should be simple in given options!');
      return _Graph3.call(this, finalOptions) || this;
    }
    return MultiGraph;
  }(Graph);
  var MultiDirectedGraph = /*#__PURE__*/function (_Graph4) {
    _inheritsLoose(MultiDirectedGraph, _Graph4);
    function MultiDirectedGraph(options) {
      var finalOptions = assign({
        type: 'directed',
        multi: true
      }, options);
      if ('multi' in finalOptions && finalOptions.multi !== true) throw new InvalidArgumentsGraphError('MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!');
      if (finalOptions.type !== 'directed') throw new InvalidArgumentsGraphError('MultiDirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!');
      return _Graph4.call(this, finalOptions) || this;
    }
    return MultiDirectedGraph;
  }(Graph);
  var MultiUndirectedGraph = /*#__PURE__*/function (_Graph5) {
    _inheritsLoose(MultiUndirectedGraph, _Graph5);
    function MultiUndirectedGraph(options) {
      var finalOptions = assign({
        type: 'undirected',
        multi: true
      }, options);
      if ('multi' in finalOptions && finalOptions.multi !== true) throw new InvalidArgumentsGraphError('MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!');
      if (finalOptions.type !== 'undirected') throw new InvalidArgumentsGraphError('MultiUndirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!');
      return _Graph5.call(this, finalOptions) || this;
    }
    return MultiUndirectedGraph;
  }(Graph); /**
             * Attaching static #.from method to each of the constructors.
             */
  function attachStaticFromMethod(Class) {
    /**
     * Builds a graph from serialized data or another graph's data.
     *
     * @param  {Graph|SerializedGraph} data      - Hydratation data.
     * @param  {object}                [options] - Options.
     * @return {Class}
     */
    Class.from = function (data, options) {
      // Merging given options with serialized ones
      var finalOptions = assign({}, data.options, options);
      var instance = new Class(finalOptions);
      instance["import"](data);
      return instance;
    };
  }
  attachStaticFromMethod(Graph);
  attachStaticFromMethod(DirectedGraph);
  attachStaticFromMethod(UndirectedGraph);
  attachStaticFromMethod(MultiGraph);
  attachStaticFromMethod(MultiDirectedGraph);
  attachStaticFromMethod(MultiUndirectedGraph);
  Graph.Graph = Graph;
  Graph.DirectedGraph = DirectedGraph;
  Graph.UndirectedGraph = UndirectedGraph;
  Graph.MultiGraph = MultiGraph;
  Graph.MultiDirectedGraph = MultiDirectedGraph;
  Graph.MultiUndirectedGraph = MultiUndirectedGraph;
  Graph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;
  Graph.NotFoundGraphError = NotFoundGraphError;
  Graph.UsageGraphError = UsageGraphError;

  /**
   * Graphology CommonJS Endoint
   * ============================
   *
   * Endpoint for CommonJS modules consumers.
   */

  return Graph;

}));
</script>
<script>
"use strict";
(function(factory, window){
    "use strict";
    if (typeof define === 'function' && define.amd) {
      define(['leaflet'], factory);
    } else if (typeof exports === 'object') {
      module.exports = factory(require('leaflet'));
    }
    if (typeof window !== 'undefined' && window.L) {
      window.L.Ruler = factory(L);
    }
  }(function (L) {
    "use strict";
    L.Control.Ruler = L.Control.extend({
      options: {
        position: 'topright',
        events: {
          onToggle: function (is_active) { }
        },
        circleMarker: {
          color: 'red',
          radius: 2
        },
        lineStyle: {
          color: 'red',
          dashArray: '1,6'
        },
        lengthUnit: {
          display: 'km',
          decimal: 2,
          factor: null,
          label: 'Distance:'
        },
        angleUnit: {
          display: '&deg;',
          decimal: 2,
          factor: null,
          label: 'Bearing:'
        }
      },
      isActive: function () {
        return this._choice;
      },
      onAdd: function(map) {
        this._map = map;
        this._container = L.DomUtil.create('div', 'leaflet-bar');
        this._container.title = '- The ruler tool allows you to draw paths on the map\n- Click this button to enable\n- Press escape once or double click once to finish drawing the current path\n- Click this button or press escape again to disable';
        this._container.classList.add('leaflet-ruler');
        L.DomEvent.disableClickPropagation(this._container);
        L.DomEvent.on(this._container, 'click', this._toggleMeasure, this);
        this._choice = false;
        this._defaultCursor = this._map._container.style.cursor;
        this._allLayers = L.layerGroup();
        return this._container;
      },
      onRemove: function() {
        L.DomEvent.off(this._container, 'click', this._toggleMeasure, this);
      },
      _toggleMeasure: function() {
        this._choice = !this._choice;
        this.options.events.onToggle(this._choice);
        this._clickedLatLong = null;
        this._clickedPoints = [];
        this._totalLength = 0;
        if (this._choice){
          this._map.doubleClickZoom.disable();
          L.DomEvent.on(this._map._container, 'keydown', this._escape, this);
          L.DomEvent.on(this._map._container, 'dblclick', this._closePath, this);
          this._container.classList.add("leaflet-ruler-clicked");
          this._clickCount = 0;
          this._tempLine = L.featureGroup().addTo(this._allLayers);
          this._tempPoint = L.featureGroup().addTo(this._allLayers);
          this._pointLayer = L.featureGroup().addTo(this._allLayers);
          this._polylineLayer = L.featureGroup().addTo(this._allLayers);
          this._allLayers.addTo(this._map);
          this._map._container.style.cursor = 'crosshair';
          this._map.on('click', this._clicked, this);
          this._map.on('mousemove', this._moving, this);
        }
        else {
          this._map.doubleClickZoom.enable();
          L.DomEvent.off(this._map._container, 'keydown', this._escape, this);
          L.DomEvent.off(this._map._container, 'dblclick', this._closePath, this);
          this._container.classList.remove("leaflet-ruler-clicked");
          this._map.removeLayer(this._allLayers);
          this._allLayers = L.layerGroup();
          this._map._container.style.cursor = this._defaultCursor;
          this._map.off('click', this._clicked, this);
          this._map.off('mousemove', this._moving, this);
        }
      },
      _clicked: function(e) {
        this._clickedLatLong = e.latlng;
        this._clickedPoints.push(this._clickedLatLong);
        L.circleMarker(this._clickedLatLong, this.options.circleMarker).addTo(this._pointLayer);
        if(this._clickCount > 0 && !e.latlng.equals(this._clickedPoints[this._clickedPoints.length - 2])){
          if (this._movingLatLong){
            L.polyline([this._clickedPoints[this._clickCount-1], this._movingLatLong], this.options.lineStyle).addTo(this._polylineLayer);
          }
          var text;
          this._totalLength += this._result.Distance;
          if (this._clickCount > 1){
            text = '<b>' + this.options.angleUnit.label + '</b>&nbsp;' + this._result.Bearing.toFixed(this.options.angleUnit.decimal) + '&nbsp;' + this.options.angleUnit.display + '<br><b>' + this.options.lengthUnit.label + '</b>&nbsp;' + this._totalLength.toFixed(this.options.lengthUnit.decimal) + '&nbsp;' +  this.options.lengthUnit.display;
          }
          else {
            text = '<b>' + this.options.angleUnit.label + '</b>&nbsp;' + this._result.Bearing.toFixed(this.options.angleUnit.decimal) + '&nbsp;' + this.options.angleUnit.display + '<br><b>' + this.options.lengthUnit.label + '</b>&nbsp;' + this._result.Distance.toFixed(this.options.lengthUnit.decimal) + '&nbsp;' +  this.options.lengthUnit.display;
          }
          L.circleMarker(this._clickedLatLong, this.options.circleMarker).bindTooltip(text, {permanent: true, className: 'result-tooltip'}).addTo(this._pointLayer).openTooltip();
        }
        this._clickCount++;
      },
      _moving: function(e) {
        if (this._clickedLatLong){
          L.DomEvent.off(this._container, 'click', this._toggleMeasure, this);
          this._movingLatLong = e.latlng;
          if (this._tempLine){
            this._map.removeLayer(this._tempLine);
            this._map.removeLayer(this._tempPoint);
          }
          var text;
          this._addedLength = 0;
          this._tempLine = L.featureGroup();
          this._tempPoint = L.featureGroup();
          this._tempLine.addTo(this._map);
          this._tempPoint.addTo(this._map);
          this._calculateBearingAndDistance();
          this._addedLength = this._result.Distance + this._totalLength;
          L.polyline([this._clickedLatLong, this._movingLatLong], this.options.lineStyle).addTo(this._tempLine);
          if (this._clickCount > 1){
            text = '<b>' + this.options.angleUnit.label + '</b>&nbsp;' + this._result.Bearing.toFixed(this.options.angleUnit.decimal) + '&nbsp;' + this.options.angleUnit.display + '<br><b>' + this.options.lengthUnit.label + '</b>&nbsp;' + this._addedLength.toFixed(this.options.lengthUnit.decimal) + '&nbsp;' +  this.options.lengthUnit.display + '<br><div class="plus-length">(+' + this._result.Distance.toFixed(this.options.lengthUnit.decimal) + ')</div>';
          }
          else {
            text = '<b>' + this.options.angleUnit.label + '</b>&nbsp;' + this._result.Bearing.toFixed(this.options.angleUnit.decimal) + '&nbsp;' + this.options.angleUnit.display + '<br><b>' + this.options.lengthUnit.label + '</b>&nbsp;' + this._result.Distance.toFixed(this.options.lengthUnit.decimal) + '&nbsp;' +  this.options.lengthUnit.display;
          }
          L.circleMarker(this._movingLatLong, this.options.circleMarker).bindTooltip(text, {sticky: true, offset: L.point(0, -40) ,className: 'moving-tooltip'}).addTo(this._tempPoint).openTooltip();
        }
      },
      _escape: function(e) {
        if (e.keyCode === 27){
          if (this._clickCount > 0){
            this._closePath();
          }
          else {
            this._choice = true;
            this._toggleMeasure();
          }
        }
      },
      _calculateBearingAndDistance: function() {
        var f1 = this._clickedLatLong.lat, l1 = this._clickedLatLong.lng, f2 = this._movingLatLong.lat, l2 = this._movingLatLong.lng;
        var toRadian = Math.PI / 180;
        // haversine formula
        // bearing
        var y = Math.sin((l2-l1)*toRadian) * Math.cos(f2*toRadian);
        var x = Math.cos(f1*toRadian)*Math.sin(f2*toRadian) - Math.sin(f1*toRadian)*Math.cos(f2*toRadian)*Math.cos((l2-l1)*toRadian);
        var brng = Math.atan2(y, x)*((this.options.angleUnit.factor ? this.options.angleUnit.factor/2 : 180)/Math.PI);
        brng += brng < 0 ? (this.options.angleUnit.factor ? this.options.angleUnit.factor : 360) : 0;
        // distance
        var R = this.options.lengthUnit.factor ? 6371 * this.options.lengthUnit.factor : 6371; // kilometres
        var deltaF = (f2 - f1)*toRadian;
        var deltaL = (l2 - l1)*toRadian;
        var a = Math.sin(deltaF/2) * Math.sin(deltaF/2) + Math.cos(f1*toRadian) * Math.cos(f2*toRadian) * Math.sin(deltaL/2) * Math.sin(deltaL/2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        var distance = R * c;
        this._result = {
          Bearing: brng,
          Distance: distance
        };
      },
      _closePath: function() {
        this._map.removeLayer(this._tempLine);
        this._map.removeLayer(this._tempPoint);
        if (this._clickCount <= 1) this._map.removeLayer(this._pointLayer);
        this._choice = false;
        L.DomEvent.on(this._container, 'click', this._toggleMeasure, this);
        this._toggleMeasure();
      }
    });
    L.control.ruler = function(options) {
      return new L.Control.Ruler(options);
    };
  }, window));
</script>
<script>
"use strict";
/**
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2019, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -------------------------------------------------------
 *
 * chroma.js includes colors from colorbrewer2.org, which are released under
 * the following license:
 *
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
 * and The Pennsylvania State University.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 * ------------------------------------------------------
 *
 * Named colors are taken from X11 Color Names.
 * http://www.w3.org/TR/css3-color/#svg-color
 *
 * @preserve
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.chroma = factory());
})(this, (function () { 'use strict';

    var limit$2 = function (x, min, max) {
        if ( min === void 0 ) min=0;
        if ( max === void 0 ) max=1;

        return x < min ? min : x > max ? max : x;
    };

    var limit$1 = limit$2;

    var clip_rgb$3 = function (rgb) {
        rgb._clipped = false;
        rgb._unclipped = rgb.slice(0);
        for (var i=0; i<=3; i++) {
            if (i < 3) {
                if (rgb[i] < 0 || rgb[i] > 255) { rgb._clipped = true; }
                rgb[i] = limit$1(rgb[i], 0, 255);
            } else if (i === 3) {
                rgb[i] = limit$1(rgb[i], 0, 1);
            }
        }
        return rgb;
    };

    // ported from jQuery's $.type
    var classToType = {};
    for (var i$1 = 0, list$1 = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Undefined', 'Null']; i$1 < list$1.length; i$1 += 1) {
        var name = list$1[i$1];

        classToType[("[object " + name + "]")] = name.toLowerCase();
    }
    var type$p = function(obj) {
        return classToType[Object.prototype.toString.call(obj)] || "object";
    };

    var type$o = type$p;

    var unpack$B = function (args, keyOrder) {
        if ( keyOrder === void 0 ) keyOrder=null;

    	// if called with more than 3 arguments, we return the arguments
        if (args.length >= 3) { return Array.prototype.slice.call(args); }
        // with less than 3 args we check if first arg is object
        // and use the keyOrder string to extract and sort properties
    	if (type$o(args[0]) == 'object' && keyOrder) {
    		return keyOrder.split('')
    			.filter(function (k) { return args[0][k] !== undefined; })
    			.map(function (k) { return args[0][k]; });
    	}
    	// otherwise we just return the first argument
    	// (which we suppose is an array of args)
        return args[0];
    };

    var type$n = type$p;

    var last$4 = function (args) {
        if (args.length < 2) { return null; }
        var l = args.length-1;
        if (type$n(args[l]) == 'string') { return args[l].toLowerCase(); }
        return null;
    };

    var PI$2 = Math.PI;

    var utils = {
    	clip_rgb: clip_rgb$3,
    	limit: limit$2,
    	type: type$p,
    	unpack: unpack$B,
    	last: last$4,
    	PI: PI$2,
    	TWOPI: PI$2*2,
    	PITHIRD: PI$2/3,
    	DEG2RAD: PI$2 / 180,
    	RAD2DEG: 180 / PI$2
    };

    var input$h = {
    	format: {},
    	autodetect: []
    };

    var last$3 = utils.last;
    var clip_rgb$2 = utils.clip_rgb;
    var type$m = utils.type;
    var _input = input$h;

    var Color$D = function Color() {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var me = this;
        if (type$m(args[0]) === 'object' &&
            args[0].constructor &&
            args[0].constructor === this.constructor) {
            // the argument is already a Color instance
            return args[0];
        }

        // last argument could be the mode
        var mode = last$3(args);
        var autodetect = false;

        if (!mode) {
            autodetect = true;
            if (!_input.sorted) {
                _input.autodetect = _input.autodetect.sort(function (a,b) { return b.p - a.p; });
                _input.sorted = true;
            }
            // auto-detect format
            for (var i = 0, list = _input.autodetect; i < list.length; i += 1) {
                var chk = list[i];

                mode = chk.test.apply(chk, args);
                if (mode) { break; }
            }
        }

        if (_input.format[mode]) {
            var rgb = _input.format[mode].apply(null, autodetect ? args : args.slice(0,-1));
            me._rgb = clip_rgb$2(rgb);
        } else {
            throw new Error('unknown format: '+args);
        }

        // add alpha channel
        if (me._rgb.length === 3) { me._rgb.push(1); }
    };

    Color$D.prototype.toString = function toString () {
        if (type$m(this.hex) == 'function') { return this.hex(); }
        return ("[" + (this._rgb.join(',')) + "]");
    };

    var Color_1 = Color$D;

    var chroma$k = function () {
    	var args = [], len = arguments.length;
    	while ( len-- ) args[ len ] = arguments[ len ];

    	return new (Function.prototype.bind.apply( chroma$k.Color, [ null ].concat( args) ));
    };

    chroma$k.Color = Color_1;
    chroma$k.version = '2.4.2';

    var chroma_1 = chroma$k;

    var unpack$A = utils.unpack;
    var max$2 = Math.max;

    var rgb2cmyk$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$A(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r = r / 255;
        g = g / 255;
        b = b / 255;
        var k = 1 - max$2(r,max$2(g,b));
        var f = k < 1 ? 1 / (1-k) : 0;
        var c = (1-r-k) * f;
        var m = (1-g-k) * f;
        var y = (1-b-k) * f;
        return [c,m,y,k];
    };

    var rgb2cmyk_1 = rgb2cmyk$1;

    var unpack$z = utils.unpack;

    var cmyk2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$z(args, 'cmyk');
        var c = args[0];
        var m = args[1];
        var y = args[2];
        var k = args[3];
        var alpha = args.length > 4 ? args[4] : 1;
        if (k === 1) { return [0,0,0,alpha]; }
        return [
            c >= 1 ? 0 : 255 * (1-c) * (1-k), // r
            m >= 1 ? 0 : 255 * (1-m) * (1-k), // g
            y >= 1 ? 0 : 255 * (1-y) * (1-k), // b
            alpha
        ];
    };

    var cmyk2rgb_1 = cmyk2rgb;

    var chroma$j = chroma_1;
    var Color$C = Color_1;
    var input$g = input$h;
    var unpack$y = utils.unpack;
    var type$l = utils.type;

    var rgb2cmyk = rgb2cmyk_1;

    Color$C.prototype.cmyk = function() {
        return rgb2cmyk(this._rgb);
    };

    chroma$j.cmyk = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$C, [ null ].concat( args, ['cmyk']) ));
    };

    input$g.format.cmyk = cmyk2rgb_1;

    input$g.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$y(args, 'cmyk');
            if (type$l(args) === 'array' && args.length === 4) {
                return 'cmyk';
            }
        }
    });

    var unpack$x = utils.unpack;
    var last$2 = utils.last;
    var rnd = function (a) { return Math.round(a*100)/100; };

    /*
     * supported arguments:
     * - hsl2css(h,s,l)
     * - hsl2css(h,s,l,a)
     * - hsl2css([h,s,l], mode)
     * - hsl2css([h,s,l,a], mode)
     * - hsl2css({h,s,l,a}, mode)
     */
    var hsl2css$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var hsla = unpack$x(args, 'hsla');
        var mode = last$2(args) || 'lsa';
        hsla[0] = rnd(hsla[0] || 0);
        hsla[1] = rnd(hsla[1]*100) + '%';
        hsla[2] = rnd(hsla[2]*100) + '%';
        if (mode === 'hsla' || (hsla.length > 3 && hsla[3]<1)) {
            hsla[3] = hsla.length > 3 ? hsla[3] : 1;
            mode = 'hsla';
        } else {
            hsla.length = 3;
        }
        return (mode + "(" + (hsla.join(',')) + ")");
    };

    var hsl2css_1 = hsl2css$1;

    var unpack$w = utils.unpack;

    /*
     * supported arguments:
     * - rgb2hsl(r,g,b)
     * - rgb2hsl(r,g,b,a)
     * - rgb2hsl([r,g,b])
     * - rgb2hsl([r,g,b,a])
     * - rgb2hsl({r,g,b,a})
     */
    var rgb2hsl$3 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$w(args, 'rgba');
        var r = args[0];
        var g = args[1];
        var b = args[2];

        r /= 255;
        g /= 255;
        b /= 255;

        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);

        var l = (max + min) / 2;
        var s, h;

        if (max === min){
            s = 0;
            h = Number.NaN;
        } else {
            s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
        }

        if (r == max) { h = (g - b) / (max - min); }
        else if (g == max) { h = 2 + (b - r) / (max - min); }
        else if (b == max) { h = 4 + (r - g) / (max - min); }

        h *= 60;
        if (h < 0) { h += 360; }
        if (args.length>3 && args[3]!==undefined) { return [h,s,l,args[3]]; }
        return [h,s,l];
    };

    var rgb2hsl_1 = rgb2hsl$3;

    var unpack$v = utils.unpack;
    var last$1 = utils.last;
    var hsl2css = hsl2css_1;
    var rgb2hsl$2 = rgb2hsl_1;
    var round$6 = Math.round;

    /*
     * supported arguments:
     * - rgb2css(r,g,b)
     * - rgb2css(r,g,b,a)
     * - rgb2css([r,g,b], mode)
     * - rgb2css([r,g,b,a], mode)
     * - rgb2css({r,g,b,a}, mode)
     */
    var rgb2css$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgba = unpack$v(args, 'rgba');
        var mode = last$1(args) || 'rgb';
        if (mode.substr(0,3) == 'hsl') {
            return hsl2css(rgb2hsl$2(rgba), mode);
        }
        rgba[0] = round$6(rgba[0]);
        rgba[1] = round$6(rgba[1]);
        rgba[2] = round$6(rgba[2]);
        if (mode === 'rgba' || (rgba.length > 3 && rgba[3]<1)) {
            rgba[3] = rgba.length > 3 ? rgba[3] : 1;
            mode = 'rgba';
        }
        return (mode + "(" + (rgba.slice(0,mode==='rgb'?3:4).join(',')) + ")");
    };

    var rgb2css_1 = rgb2css$1;

    var unpack$u = utils.unpack;
    var round$5 = Math.round;

    var hsl2rgb$1 = function () {
        var assign;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$u(args, 'hsl');
        var h = args[0];
        var s = args[1];
        var l = args[2];
        var r,g,b;
        if (s === 0) {
            r = g = b = l*255;
        } else {
            var t3 = [0,0,0];
            var c = [0,0,0];
            var t2 = l < 0.5 ? l * (1+s) : l+s-l*s;
            var t1 = 2 * l - t2;
            var h_ = h / 360;
            t3[0] = h_ + 1/3;
            t3[1] = h_;
            t3[2] = h_ - 1/3;
            for (var i=0; i<3; i++) {
                if (t3[i] < 0) { t3[i] += 1; }
                if (t3[i] > 1) { t3[i] -= 1; }
                if (6 * t3[i] < 1)
                    { c[i] = t1 + (t2 - t1) * 6 * t3[i]; }
                else if (2 * t3[i] < 1)
                    { c[i] = t2; }
                else if (3 * t3[i] < 2)
                    { c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6; }
                else
                    { c[i] = t1; }
            }
            (assign = [round$5(c[0]*255),round$5(c[1]*255),round$5(c[2]*255)], r = assign[0], g = assign[1], b = assign[2]);
        }
        if (args.length > 3) {
            // keep alpha channel
            return [r,g,b,args[3]];
        }
        return [r,g,b,1];
    };

    var hsl2rgb_1 = hsl2rgb$1;

    var hsl2rgb = hsl2rgb_1;
    var input$f = input$h;

    var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
    var RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;

    var round$4 = Math.round;

    var css2rgb$1 = function (css) {
        css = css.toLowerCase().trim();
        var m;

        if (input$f.format.named) {
            try {
                return input$f.format.named(css);
            } catch (e) {
                // eslint-disable-next-line
            }
        }

        // rgb(250,20,0)
        if ((m = css.match(RE_RGB))) {
            var rgb = m.slice(1,4);
            for (var i=0; i<3; i++) {
                rgb[i] = +rgb[i];
            }
            rgb[3] = 1;  // default alpha
            return rgb;
        }

        // rgba(250,20,0,0.4)
        if ((m = css.match(RE_RGBA))) {
            var rgb$1 = m.slice(1,5);
            for (var i$1=0; i$1<4; i$1++) {
                rgb$1[i$1] = +rgb$1[i$1];
            }
            return rgb$1;
        }

        // rgb(100%,0%,0%)
        if ((m = css.match(RE_RGB_PCT))) {
            var rgb$2 = m.slice(1,4);
            for (var i$2=0; i$2<3; i$2++) {
                rgb$2[i$2] = round$4(rgb$2[i$2] * 2.55);
            }
            rgb$2[3] = 1;  // default alpha
            return rgb$2;
        }

        // rgba(100%,0%,0%,0.4)
        if ((m = css.match(RE_RGBA_PCT))) {
            var rgb$3 = m.slice(1,5);
            for (var i$3=0; i$3<3; i$3++) {
                rgb$3[i$3] = round$4(rgb$3[i$3] * 2.55);
            }
            rgb$3[3] = +rgb$3[3];
            return rgb$3;
        }

        // hsl(0,100%,50%)
        if ((m = css.match(RE_HSL))) {
            var hsl = m.slice(1,4);
            hsl[1] *= 0.01;
            hsl[2] *= 0.01;
            var rgb$4 = hsl2rgb(hsl);
            rgb$4[3] = 1;
            return rgb$4;
        }

        // hsla(0,100%,50%,0.5)
        if ((m = css.match(RE_HSLA))) {
            var hsl$1 = m.slice(1,4);
            hsl$1[1] *= 0.01;
            hsl$1[2] *= 0.01;
            var rgb$5 = hsl2rgb(hsl$1);
            rgb$5[3] = +m[4];  // default alpha = 1
            return rgb$5;
        }
    };

    css2rgb$1.test = function (s) {
        return RE_RGB.test(s) ||
            RE_RGBA.test(s) ||
            RE_RGB_PCT.test(s) ||
            RE_RGBA_PCT.test(s) ||
            RE_HSL.test(s) ||
            RE_HSLA.test(s);
    };

    var css2rgb_1 = css2rgb$1;

    var chroma$i = chroma_1;
    var Color$B = Color_1;
    var input$e = input$h;
    var type$k = utils.type;

    var rgb2css = rgb2css_1;
    var css2rgb = css2rgb_1;

    Color$B.prototype.css = function(mode) {
        return rgb2css(this._rgb, mode);
    };

    chroma$i.css = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$B, [ null ].concat( args, ['css']) ));
    };

    input$e.format.css = css2rgb;

    input$e.autodetect.push({
        p: 5,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$k(h) === 'string' && css2rgb.test(h)) {
                return 'css';
            }
        }
    });

    var Color$A = Color_1;
    var chroma$h = chroma_1;
    var input$d = input$h;
    var unpack$t = utils.unpack;

    input$d.format.gl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgb = unpack$t(args, 'rgba');
        rgb[0] *= 255;
        rgb[1] *= 255;
        rgb[2] *= 255;
        return rgb;
    };

    chroma$h.gl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$A, [ null ].concat( args, ['gl']) ));
    };

    Color$A.prototype.gl = function() {
        var rgb = this._rgb;
        return [rgb[0]/255, rgb[1]/255, rgb[2]/255, rgb[3]];
    };

    var unpack$s = utils.unpack;

    var rgb2hcg$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$s(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);
        var delta = max - min;
        var c = delta * 100 / 255;
        var _g = min / (255 - delta) * 100;
        var h;
        if (delta === 0) {
            h = Number.NaN;
        } else {
            if (r === max) { h = (g - b) / delta; }
            if (g === max) { h = 2+(b - r) / delta; }
            if (b === max) { h = 4+(r - g) / delta; }
            h *= 60;
            if (h < 0) { h += 360; }
        }
        return [h, c, _g];
    };

    var rgb2hcg_1 = rgb2hcg$1;

    var unpack$r = utils.unpack;
    var floor$3 = Math.floor;

    /*
     * this is basically just HSV with some minor tweaks
     *
     * hue.. [0..360]
     * chroma .. [0..1]
     * grayness .. [0..1]
     */

    var hcg2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$r(args, 'hcg');
        var h = args[0];
        var c = args[1];
        var _g = args[2];
        var r,g,b;
        _g = _g * 255;
        var _c = c * 255;
        if (c === 0) {
            r = g = b = _g;
        } else {
            if (h === 360) { h = 0; }
            if (h > 360) { h -= 360; }
            if (h < 0) { h += 360; }
            h /= 60;
            var i = floor$3(h);
            var f = h - i;
            var p = _g * (1 - c);
            var q = p + _c * (1 - f);
            var t = p + _c * f;
            var v = p + _c;
            switch (i) {
                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break
                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break
                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break
                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break
                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break
                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break
            }
        }
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var hcg2rgb_1 = hcg2rgb;

    var unpack$q = utils.unpack;
    var type$j = utils.type;
    var chroma$g = chroma_1;
    var Color$z = Color_1;
    var input$c = input$h;

    var rgb2hcg = rgb2hcg_1;

    Color$z.prototype.hcg = function() {
        return rgb2hcg(this._rgb);
    };

    chroma$g.hcg = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$z, [ null ].concat( args, ['hcg']) ));
    };

    input$c.format.hcg = hcg2rgb_1;

    input$c.autodetect.push({
        p: 1,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$q(args, 'hcg');
            if (type$j(args) === 'array' && args.length === 3) {
                return 'hcg';
            }
        }
    });

    var unpack$p = utils.unpack;
    var last = utils.last;
    var round$3 = Math.round;

    var rgb2hex$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$p(args, 'rgba');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var a = ref[3];
        var mode = last(args) || 'auto';
        if (a === undefined) { a = 1; }
        if (mode === 'auto') {
            mode = a < 1 ? 'rgba' : 'rgb';
        }
        r = round$3(r);
        g = round$3(g);
        b = round$3(b);
        var u = r << 16 | g << 8 | b;
        var str = "000000" + u.toString(16); //#.toUpperCase();
        str = str.substr(str.length - 6);
        var hxa = '0' + round$3(a * 255).toString(16);
        hxa = hxa.substr(hxa.length - 2);
        switch (mode.toLowerCase()) {
            case 'rgba': return ("#" + str + hxa);
            case 'argb': return ("#" + hxa + str);
            default: return ("#" + str);
        }
    };

    var rgb2hex_1 = rgb2hex$2;

    var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;

    var hex2rgb$1 = function (hex) {
        if (hex.match(RE_HEX)) {
            // remove optional leading #
            if (hex.length === 4 || hex.length === 7) {
                hex = hex.substr(1);
            }
            // expand short-notation to full six-digit
            if (hex.length === 3) {
                hex = hex.split('');
                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
            }
            var u = parseInt(hex, 16);
            var r = u >> 16;
            var g = u >> 8 & 0xFF;
            var b = u & 0xFF;
            return [r,g,b,1];
        }

        // match rgba hex format, eg #FF000077
        if (hex.match(RE_HEXA)) {
            if (hex.length === 5 || hex.length === 9) {
                // remove optional leading #
                hex = hex.substr(1);
            }
            // expand short-notation to full eight-digit
            if (hex.length === 4) {
                hex = hex.split('');
                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]+hex[3]+hex[3];
            }
            var u$1 = parseInt(hex, 16);
            var r$1 = u$1 >> 24 & 0xFF;
            var g$1 = u$1 >> 16 & 0xFF;
            var b$1 = u$1 >> 8 & 0xFF;
            var a = Math.round((u$1 & 0xFF) / 0xFF * 100) / 100;
            return [r$1,g$1,b$1,a];
        }

        // we used to check for css colors here
        // if _input.css? and rgb = _input.css hex
        //     return rgb

        throw new Error(("unknown hex color: " + hex));
    };

    var hex2rgb_1 = hex2rgb$1;

    var chroma$f = chroma_1;
    var Color$y = Color_1;
    var type$i = utils.type;
    var input$b = input$h;

    var rgb2hex$1 = rgb2hex_1;

    Color$y.prototype.hex = function(mode) {
        return rgb2hex$1(this._rgb, mode);
    };

    chroma$f.hex = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$y, [ null ].concat( args, ['hex']) ));
    };

    input$b.format.hex = hex2rgb_1;
    input$b.autodetect.push({
        p: 4,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$i(h) === 'string' && [3,4,5,6,7,8,9].indexOf(h.length) >= 0) {
                return 'hex';
            }
        }
    });

    var unpack$o = utils.unpack;
    var TWOPI$2 = utils.TWOPI;
    var min$2 = Math.min;
    var sqrt$4 = Math.sqrt;
    var acos = Math.acos;

    var rgb2hsi$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        borrowed from here:
        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp
        */
        var ref = unpack$o(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        r /= 255;
        g /= 255;
        b /= 255;
        var h;
        var min_ = min$2(r,g,b);
        var i = (r+g+b) / 3;
        var s = i > 0 ? 1 - min_/i : 0;
        if (s === 0) {
            h = NaN;
        } else {
            h = ((r-g)+(r-b)) / 2;
            h /= sqrt$4((r-g)*(r-g) + (r-b)*(g-b));
            h = acos(h);
            if (b > g) {
                h = TWOPI$2 - h;
            }
            h /= TWOPI$2;
        }
        return [h*360,s,i];
    };

    var rgb2hsi_1 = rgb2hsi$1;

    var unpack$n = utils.unpack;
    var limit = utils.limit;
    var TWOPI$1 = utils.TWOPI;
    var PITHIRD = utils.PITHIRD;
    var cos$4 = Math.cos;

    /*
     * hue [0..360]
     * saturation [0..1]
     * intensity [0..1]
     */
    var hsi2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        borrowed from here:
        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp
        */
        args = unpack$n(args, 'hsi');
        var h = args[0];
        var s = args[1];
        var i = args[2];
        var r,g,b;

        if (isNaN(h)) { h = 0; }
        if (isNaN(s)) { s = 0; }
        // normalize hue
        if (h > 360) { h -= 360; }
        if (h < 0) { h += 360; }
        h /= 360;
        if (h < 1/3) {
            b = (1-s)/3;
            r = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
            g = 1 - (b+r);
        } else if (h < 2/3) {
            h -= 1/3;
            r = (1-s)/3;
            g = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
            b = 1 - (r+g);
        } else {
            h -= 2/3;
            g = (1-s)/3;
            b = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
            r = 1 - (g+b);
        }
        r = limit(i*r*3);
        g = limit(i*g*3);
        b = limit(i*b*3);
        return [r*255, g*255, b*255, args.length > 3 ? args[3] : 1];
    };

    var hsi2rgb_1 = hsi2rgb;

    var unpack$m = utils.unpack;
    var type$h = utils.type;
    var chroma$e = chroma_1;
    var Color$x = Color_1;
    var input$a = input$h;

    var rgb2hsi = rgb2hsi_1;

    Color$x.prototype.hsi = function() {
        return rgb2hsi(this._rgb);
    };

    chroma$e.hsi = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$x, [ null ].concat( args, ['hsi']) ));
    };

    input$a.format.hsi = hsi2rgb_1;

    input$a.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$m(args, 'hsi');
            if (type$h(args) === 'array' && args.length === 3) {
                return 'hsi';
            }
        }
    });

    var unpack$l = utils.unpack;
    var type$g = utils.type;
    var chroma$d = chroma_1;
    var Color$w = Color_1;
    var input$9 = input$h;

    var rgb2hsl$1 = rgb2hsl_1;

    Color$w.prototype.hsl = function() {
        return rgb2hsl$1(this._rgb);
    };

    chroma$d.hsl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$w, [ null ].concat( args, ['hsl']) ));
    };

    input$9.format.hsl = hsl2rgb_1;

    input$9.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$l(args, 'hsl');
            if (type$g(args) === 'array' && args.length === 3) {
                return 'hsl';
            }
        }
    });

    var unpack$k = utils.unpack;
    var min$1 = Math.min;
    var max$1 = Math.max;

    /*
     * supported arguments:
     * - rgb2hsv(r,g,b)
     * - rgb2hsv([r,g,b])
     * - rgb2hsv({r,g,b})
     */
    var rgb2hsl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$k(args, 'rgb');
        var r = args[0];
        var g = args[1];
        var b = args[2];
        var min_ = min$1(r, g, b);
        var max_ = max$1(r, g, b);
        var delta = max_ - min_;
        var h,s,v;
        v = max_ / 255.0;
        if (max_ === 0) {
            h = Number.NaN;
            s = 0;
        } else {
            s = delta / max_;
            if (r === max_) { h = (g - b) / delta; }
            if (g === max_) { h = 2+(b - r) / delta; }
            if (b === max_) { h = 4+(r - g) / delta; }
            h *= 60;
            if (h < 0) { h += 360; }
        }
        return [h, s, v]
    };

    var rgb2hsv$1 = rgb2hsl;

    var unpack$j = utils.unpack;
    var floor$2 = Math.floor;

    var hsv2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
        args = unpack$j(args, 'hsv');
        var h = args[0];
        var s = args[1];
        var v = args[2];
        var r,g,b;
        v *= 255;
        if (s === 0) {
            r = g = b = v;
        } else {
            if (h === 360) { h = 0; }
            if (h > 360) { h -= 360; }
            if (h < 0) { h += 360; }
            h /= 60;

            var i = floor$2(h);
            var f = h - i;
            var p = v * (1 - s);
            var q = v * (1 - s * f);
            var t = v * (1 - s * (1 - f));

            switch (i) {
                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break
                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break
                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break
                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break
                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break
                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break
            }
        }
        return [r,g,b,args.length > 3?args[3]:1];
    };

    var hsv2rgb_1 = hsv2rgb;

    var unpack$i = utils.unpack;
    var type$f = utils.type;
    var chroma$c = chroma_1;
    var Color$v = Color_1;
    var input$8 = input$h;

    var rgb2hsv = rgb2hsv$1;

    Color$v.prototype.hsv = function() {
        return rgb2hsv(this._rgb);
    };

    chroma$c.hsv = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$v, [ null ].concat( args, ['hsv']) ));
    };

    input$8.format.hsv = hsv2rgb_1;

    input$8.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$i(args, 'hsv');
            if (type$f(args) === 'array' && args.length === 3) {
                return 'hsv';
            }
        }
    });

    var labConstants = {
        // Corresponds roughly to RGB brighter/darker
        Kn: 18,

        // D65 standard referent
        Xn: 0.950470,
        Yn: 1,
        Zn: 1.088830,

        t0: 0.137931034,  // 4 / 29
        t1: 0.206896552,  // 6 / 29
        t2: 0.12841855,   // 3 * t1 * t1
        t3: 0.008856452,  // t1 * t1 * t1
    };

    var LAB_CONSTANTS$3 = labConstants;
    var unpack$h = utils.unpack;
    var pow$a = Math.pow;

    var rgb2lab$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$h(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2xyz(r,g,b);
        var x = ref$1[0];
        var y = ref$1[1];
        var z = ref$1[2];
        var l = 116 * y - 16;
        return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];
    };

    var rgb_xyz = function (r) {
        if ((r /= 255) <= 0.04045) { return r / 12.92; }
        return pow$a((r + 0.055) / 1.055, 2.4);
    };

    var xyz_lab = function (t) {
        if (t > LAB_CONSTANTS$3.t3) { return pow$a(t, 1 / 3); }
        return t / LAB_CONSTANTS$3.t2 + LAB_CONSTANTS$3.t0;
    };

    var rgb2xyz = function (r,g,b) {
        r = rgb_xyz(r);
        g = rgb_xyz(g);
        b = rgb_xyz(b);
        var x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / LAB_CONSTANTS$3.Xn);
        var y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / LAB_CONSTANTS$3.Yn);
        var z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / LAB_CONSTANTS$3.Zn);
        return [x,y,z];
    };

    var rgb2lab_1 = rgb2lab$2;

    var LAB_CONSTANTS$2 = labConstants;
    var unpack$g = utils.unpack;
    var pow$9 = Math.pow;

    /*
     * L* [0..100]
     * a [-100..100]
     * b [-100..100]
     */
    var lab2rgb$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$g(args, 'lab');
        var l = args[0];
        var a = args[1];
        var b = args[2];
        var x,y,z, r,g,b_;

        y = (l + 16) / 116;
        x = isNaN(a) ? y : y + a / 500;
        z = isNaN(b) ? y : y - b / 200;

        y = LAB_CONSTANTS$2.Yn * lab_xyz(y);
        x = LAB_CONSTANTS$2.Xn * lab_xyz(x);
        z = LAB_CONSTANTS$2.Zn * lab_xyz(z);

        r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);  // D65 -> sRGB
        g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);
        b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);

        return [r,g,b_,args.length > 3 ? args[3] : 1];
    };

    var xyz_rgb = function (r) {
        return 255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow$9(r, 1 / 2.4) - 0.055)
    };

    var lab_xyz = function (t) {
        return t > LAB_CONSTANTS$2.t1 ? t * t * t : LAB_CONSTANTS$2.t2 * (t - LAB_CONSTANTS$2.t0)
    };

    var lab2rgb_1 = lab2rgb$1;

    var unpack$f = utils.unpack;
    var type$e = utils.type;
    var chroma$b = chroma_1;
    var Color$u = Color_1;
    var input$7 = input$h;

    var rgb2lab$1 = rgb2lab_1;

    Color$u.prototype.lab = function() {
        return rgb2lab$1(this._rgb);
    };

    chroma$b.lab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$u, [ null ].concat( args, ['lab']) ));
    };

    input$7.format.lab = lab2rgb_1;

    input$7.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$f(args, 'lab');
            if (type$e(args) === 'array' && args.length === 3) {
                return 'lab';
            }
        }
    });

    var unpack$e = utils.unpack;
    var RAD2DEG = utils.RAD2DEG;
    var sqrt$3 = Math.sqrt;
    var atan2$2 = Math.atan2;
    var round$2 = Math.round;

    var lab2lch$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$e(args, 'lab');
        var l = ref[0];
        var a = ref[1];
        var b = ref[2];
        var c = sqrt$3(a * a + b * b);
        var h = (atan2$2(b, a) * RAD2DEG + 360) % 360;
        if (round$2(c*10000) === 0) { h = Number.NaN; }
        return [l, c, h];
    };

    var lab2lch_1 = lab2lch$2;

    var unpack$d = utils.unpack;
    var rgb2lab = rgb2lab_1;
    var lab2lch$1 = lab2lch_1;

    var rgb2lch$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$d(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2lab(r,g,b);
        var l = ref$1[0];
        var a = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch$1(l,a,b_);
    };

    var rgb2lch_1 = rgb2lch$1;

    var unpack$c = utils.unpack;
    var DEG2RAD = utils.DEG2RAD;
    var sin$3 = Math.sin;
    var cos$3 = Math.cos;

    var lch2lab$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        /*
        Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.
        These formulas were invented by David Dalrymple to obtain maximum contrast without going
        out of gamut if the parameters are in the range 0-1.

        A saturation multiplier was added by Gregor Aisch
        */
        var ref = unpack$c(args, 'lch');
        var l = ref[0];
        var c = ref[1];
        var h = ref[2];
        if (isNaN(h)) { h = 0; }
        h = h * DEG2RAD;
        return [l, cos$3(h) * c, sin$3(h) * c]
    };

    var lch2lab_1 = lch2lab$2;

    var unpack$b = utils.unpack;
    var lch2lab$1 = lch2lab_1;
    var lab2rgb = lab2rgb_1;

    var lch2rgb$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$b(args, 'lch');
        var l = args[0];
        var c = args[1];
        var h = args[2];
        var ref = lch2lab$1 (l,c,h);
        var L = ref[0];
        var a = ref[1];
        var b_ = ref[2];
        var ref$1 = lab2rgb (L,a,b_);
        var r = ref$1[0];
        var g = ref$1[1];
        var b = ref$1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var lch2rgb_1 = lch2rgb$1;

    var unpack$a = utils.unpack;
    var lch2rgb = lch2rgb_1;

    var hcl2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var hcl = unpack$a(args, 'hcl').reverse();
        return lch2rgb.apply(void 0, hcl);
    };

    var hcl2rgb_1 = hcl2rgb;

    var unpack$9 = utils.unpack;
    var type$d = utils.type;
    var chroma$a = chroma_1;
    var Color$t = Color_1;
    var input$6 = input$h;

    var rgb2lch = rgb2lch_1;

    Color$t.prototype.lch = function() { return rgb2lch(this._rgb); };
    Color$t.prototype.hcl = function() { return rgb2lch(this._rgb).reverse(); };

    chroma$a.lch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$t, [ null ].concat( args, ['lch']) ));
    };
    chroma$a.hcl = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$t, [ null ].concat( args, ['hcl']) ));
    };

    input$6.format.lch = lch2rgb_1;
    input$6.format.hcl = hcl2rgb_1;

    ['lch','hcl'].forEach(function (m) { return input$6.autodetect.push({
        p: 2,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$9(args, m);
            if (type$d(args) === 'array' && args.length === 3) {
                return m;
            }
        }
    }); });

    /**
    	X11 color names

    	http://www.w3.org/TR/css3-color/#svg-color
    */

    var w3cx11$1 = {
        aliceblue: '#f0f8ff',
        antiquewhite: '#faebd7',
        aqua: '#00ffff',
        aquamarine: '#7fffd4',
        azure: '#f0ffff',
        beige: '#f5f5dc',
        bisque: '#ffe4c4',
        black: '#000000',
        blanchedalmond: '#ffebcd',
        blue: '#0000ff',
        blueviolet: '#8a2be2',
        brown: '#a52a2a',
        burlywood: '#deb887',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        cornflower: '#6495ed',
        cornflowerblue: '#6495ed',
        cornsilk: '#fff8dc',
        crimson: '#dc143c',
        cyan: '#00ffff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkgray: '#a9a9a9',
        darkgreen: '#006400',
        darkgrey: '#a9a9a9',
        darkkhaki: '#bdb76b',
        darkmagenta: '#8b008b',
        darkolivegreen: '#556b2f',
        darkorange: '#ff8c00',
        darkorchid: '#9932cc',
        darkred: '#8b0000',
        darksalmon: '#e9967a',
        darkseagreen: '#8fbc8f',
        darkslateblue: '#483d8b',
        darkslategray: '#2f4f4f',
        darkslategrey: '#2f4f4f',
        darkturquoise: '#00ced1',
        darkviolet: '#9400d3',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        dimgray: '#696969',
        dimgrey: '#696969',
        dodgerblue: '#1e90ff',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        forestgreen: '#228b22',
        fuchsia: '#ff00ff',
        gainsboro: '#dcdcdc',
        ghostwhite: '#f8f8ff',
        gold: '#ffd700',
        goldenrod: '#daa520',
        gray: '#808080',
        green: '#008000',
        greenyellow: '#adff2f',
        grey: '#808080',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        indianred: '#cd5c5c',
        indigo: '#4b0082',
        ivory: '#fffff0',
        khaki: '#f0e68c',
        laserlemon: '#ffff54',
        lavender: '#e6e6fa',
        lavenderblush: '#fff0f5',
        lawngreen: '#7cfc00',
        lemonchiffon: '#fffacd',
        lightblue: '#add8e6',
        lightcoral: '#f08080',
        lightcyan: '#e0ffff',
        lightgoldenrod: '#fafad2',
        lightgoldenrodyellow: '#fafad2',
        lightgray: '#d3d3d3',
        lightgreen: '#90ee90',
        lightgrey: '#d3d3d3',
        lightpink: '#ffb6c1',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        lightskyblue: '#87cefa',
        lightslategray: '#778899',
        lightslategrey: '#778899',
        lightsteelblue: '#b0c4de',
        lightyellow: '#ffffe0',
        lime: '#00ff00',
        limegreen: '#32cd32',
        linen: '#faf0e6',
        magenta: '#ff00ff',
        maroon: '#800000',
        maroon2: '#7f0000',
        maroon3: '#b03060',
        mediumaquamarine: '#66cdaa',
        mediumblue: '#0000cd',
        mediumorchid: '#ba55d3',
        mediumpurple: '#9370db',
        mediumseagreen: '#3cb371',
        mediumslateblue: '#7b68ee',
        mediumspringgreen: '#00fa9a',
        mediumturquoise: '#48d1cc',
        mediumvioletred: '#c71585',
        midnightblue: '#191970',
        mintcream: '#f5fffa',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        navajowhite: '#ffdead',
        navy: '#000080',
        oldlace: '#fdf5e6',
        olive: '#808000',
        olivedrab: '#6b8e23',
        orange: '#ffa500',
        orangered: '#ff4500',
        orchid: '#da70d6',
        palegoldenrod: '#eee8aa',
        palegreen: '#98fb98',
        paleturquoise: '#afeeee',
        palevioletred: '#db7093',
        papayawhip: '#ffefd5',
        peachpuff: '#ffdab9',
        peru: '#cd853f',
        pink: '#ffc0cb',
        plum: '#dda0dd',
        powderblue: '#b0e0e6',
        purple: '#800080',
        purple2: '#7f007f',
        purple3: '#a020f0',
        rebeccapurple: '#663399',
        red: '#ff0000',
        rosybrown: '#bc8f8f',
        royalblue: '#4169e1',
        saddlebrown: '#8b4513',
        salmon: '#fa8072',
        sandybrown: '#f4a460',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        sienna: '#a0522d',
        silver: '#c0c0c0',
        skyblue: '#87ceeb',
        slateblue: '#6a5acd',
        slategray: '#708090',
        slategrey: '#708090',
        snow: '#fffafa',
        springgreen: '#00ff7f',
        steelblue: '#4682b4',
        tan: '#d2b48c',
        teal: '#008080',
        thistle: '#d8bfd8',
        tomato: '#ff6347',
        turquoise: '#40e0d0',
        violet: '#ee82ee',
        wheat: '#f5deb3',
        white: '#ffffff',
        whitesmoke: '#f5f5f5',
        yellow: '#ffff00',
        yellowgreen: '#9acd32'
    };

    var w3cx11_1 = w3cx11$1;

    var Color$s = Color_1;
    var input$5 = input$h;
    var type$c = utils.type;

    var w3cx11 = w3cx11_1;
    var hex2rgb = hex2rgb_1;
    var rgb2hex = rgb2hex_1;

    Color$s.prototype.name = function() {
        var hex = rgb2hex(this._rgb, 'rgb');
        for (var i = 0, list = Object.keys(w3cx11); i < list.length; i += 1) {
            var n = list[i];

            if (w3cx11[n] === hex) { return n.toLowerCase(); }
        }
        return hex;
    };

    input$5.format.named = function (name) {
        name = name.toLowerCase();
        if (w3cx11[name]) { return hex2rgb(w3cx11[name]); }
        throw new Error('unknown color name: '+name);
    };

    input$5.autodetect.push({
        p: 5,
        test: function (h) {
            var rest = [], len = arguments.length - 1;
            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

            if (!rest.length && type$c(h) === 'string' && w3cx11[h.toLowerCase()]) {
                return 'named';
            }
        }
    });

    var unpack$8 = utils.unpack;

    var rgb2num$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$8(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        return (r << 16) + (g << 8) + b;
    };

    var rgb2num_1 = rgb2num$1;

    var type$b = utils.type;

    var num2rgb = function (num) {
        if (type$b(num) == "number" && num >= 0 && num <= 0xFFFFFF) {
            var r = num >> 16;
            var g = (num >> 8) & 0xFF;
            var b = num & 0xFF;
            return [r,g,b,1];
        }
        throw new Error("unknown num color: "+num);
    };

    var num2rgb_1 = num2rgb;

    var chroma$9 = chroma_1;
    var Color$r = Color_1;
    var input$4 = input$h;
    var type$a = utils.type;

    var rgb2num = rgb2num_1;

    Color$r.prototype.num = function() {
        return rgb2num(this._rgb);
    };

    chroma$9.num = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$r, [ null ].concat( args, ['num']) ));
    };

    input$4.format.num = num2rgb_1;

    input$4.autodetect.push({
        p: 5,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            if (args.length === 1 && type$a(args[0]) === 'number' && args[0] >= 0 && args[0] <= 0xFFFFFF) {
                return 'num';
            }
        }
    });

    var chroma$8 = chroma_1;
    var Color$q = Color_1;
    var input$3 = input$h;
    var unpack$7 = utils.unpack;
    var type$9 = utils.type;
    var round$1 = Math.round;

    Color$q.prototype.rgb = function(rnd) {
        if ( rnd === void 0 ) rnd=true;

        if (rnd === false) { return this._rgb.slice(0,3); }
        return this._rgb.slice(0,3).map(round$1);
    };

    Color$q.prototype.rgba = function(rnd) {
        if ( rnd === void 0 ) rnd=true;

        return this._rgb.slice(0,4).map(function (v,i) {
            return i<3 ? (rnd === false ? v : round$1(v)) : v;
        });
    };

    chroma$8.rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$q, [ null ].concat( args, ['rgb']) ));
    };

    input$3.format.rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgba = unpack$7(args, 'rgba');
        if (rgba[3] === undefined) { rgba[3] = 1; }
        return rgba;
    };

    input$3.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$7(args, 'rgba');
            if (type$9(args) === 'array' && (args.length === 3 ||
                args.length === 4 && type$9(args[3]) == 'number' && args[3] >= 0 && args[3] <= 1)) {
                return 'rgb';
            }
        }
    });

    /*
     * Based on implementation by Neil Bartlett
     * https://github.com/neilbartlett/color-temperature
     */

    var log$1 = Math.log;

    var temperature2rgb$1 = function (kelvin) {
        var temp = kelvin / 100;
        var r,g,b;
        if (temp < 66) {
            r = 255;
            g = temp < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * log$1(g);
            b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * log$1(b);
        } else {
            r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * log$1(r);
            g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * log$1(g);
            b = 255;
        }
        return [r,g,b,1];
    };

    var temperature2rgb_1 = temperature2rgb$1;

    /*
     * Based on implementation by Neil Bartlett
     * https://github.com/neilbartlett/color-temperature
     **/

    var temperature2rgb = temperature2rgb_1;
    var unpack$6 = utils.unpack;
    var round = Math.round;

    var rgb2temperature$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var rgb = unpack$6(args, 'rgb');
        var r = rgb[0], b = rgb[2];
        var minTemp = 1000;
        var maxTemp = 40000;
        var eps = 0.4;
        var temp;
        while (maxTemp - minTemp > eps) {
            temp = (maxTemp + minTemp) * 0.5;
            var rgb$1 = temperature2rgb(temp);
            if ((rgb$1[2] / rgb$1[0]) >= (b / r)) {
                maxTemp = temp;
            } else {
                minTemp = temp;
            }
        }
        return round(temp);
    };

    var rgb2temperature_1 = rgb2temperature$1;

    var chroma$7 = chroma_1;
    var Color$p = Color_1;
    var input$2 = input$h;

    var rgb2temperature = rgb2temperature_1;

    Color$p.prototype.temp =
    Color$p.prototype.kelvin =
    Color$p.prototype.temperature = function() {
        return rgb2temperature(this._rgb);
    };

    chroma$7.temp =
    chroma$7.kelvin =
    chroma$7.temperature = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$p, [ null ].concat( args, ['temp']) ));
    };

    input$2.format.temp =
    input$2.format.kelvin =
    input$2.format.temperature = temperature2rgb_1;

    var unpack$5 = utils.unpack;
    var cbrt = Math.cbrt;
    var pow$8 = Math.pow;
    var sign$1 = Math.sign;

    var rgb2oklab$2 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        // OKLab color space implementation taken from
        // https://bottosson.github.io/posts/oklab/
        var ref = unpack$5(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = [rgb2lrgb(r / 255), rgb2lrgb(g / 255), rgb2lrgb(b / 255)];
        var lr = ref$1[0];
        var lg = ref$1[1];
        var lb = ref$1[2];
        var l = cbrt(0.4122214708 * lr + 0.5363325363 * lg + 0.0514459929 * lb);
        var m = cbrt(0.2119034982 * lr + 0.6806995451 * lg + 0.1073969566 * lb);
        var s = cbrt(0.0883024619 * lr + 0.2817188376 * lg + 0.6299787005 * lb);

        return [
            0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
            1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
            0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s
        ];
    };

    var rgb2oklab_1 = rgb2oklab$2;

    function rgb2lrgb(c) {
        var abs = Math.abs(c);
        if (abs < 0.04045) {
            return c / 12.92;
        }
        return (sign$1(c) || 1) * pow$8((abs + 0.055) / 1.055, 2.4);
    }

    var unpack$4 = utils.unpack;
    var pow$7 = Math.pow;
    var sign = Math.sign;

    /*
     * L* [0..100]
     * a [-100..100]
     * b [-100..100]
     */
    var oklab2rgb$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$4(args, 'lab');
        var L = args[0];
        var a = args[1];
        var b = args[2];

        var l = pow$7(L + 0.3963377774 * a + 0.2158037573 * b, 3);
        var m = pow$7(L - 0.1055613458 * a - 0.0638541728 * b, 3);
        var s = pow$7(L - 0.0894841775 * a - 1.291485548 * b, 3);

        return [
            255 * lrgb2rgb(+4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s),
            255 * lrgb2rgb(-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s),
            255 * lrgb2rgb(-0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s),
            args.length > 3 ? args[3] : 1
        ];
    };

    var oklab2rgb_1 = oklab2rgb$1;

    function lrgb2rgb(c) {
        var abs = Math.abs(c);
        if (abs > 0.0031308) {
            return (sign(c) || 1) * (1.055 * pow$7(abs, 1 / 2.4) - 0.055);
        }
        return c * 12.92;
    }

    var unpack$3 = utils.unpack;
    var type$8 = utils.type;
    var chroma$6 = chroma_1;
    var Color$o = Color_1;
    var input$1 = input$h;

    var rgb2oklab$1 = rgb2oklab_1;

    Color$o.prototype.oklab = function () {
        return rgb2oklab$1(this._rgb);
    };

    chroma$6.oklab = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$o, [ null ].concat( args, ['oklab']) ));
    };

    input$1.format.oklab = oklab2rgb_1;

    input$1.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack$3(args, 'oklab');
            if (type$8(args) === 'array' && args.length === 3) {
                return 'oklab';
            }
        }
    });

    var unpack$2 = utils.unpack;
    var rgb2oklab = rgb2oklab_1;
    var lab2lch = lab2lch_1;

    var rgb2oklch$1 = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ref = unpack$2(args, 'rgb');
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var ref$1 = rgb2oklab(r, g, b);
        var l = ref$1[0];
        var a = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch(l, a, b_);
    };

    var rgb2oklch_1 = rgb2oklch$1;

    var unpack$1 = utils.unpack;
    var lch2lab = lch2lab_1;
    var oklab2rgb = oklab2rgb_1;

    var oklch2rgb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        args = unpack$1(args, 'lch');
        var l = args[0];
        var c = args[1];
        var h = args[2];
        var ref = lch2lab(l, c, h);
        var L = ref[0];
        var a = ref[1];
        var b_ = ref[2];
        var ref$1 = oklab2rgb(L, a, b_);
        var r = ref$1[0];
        var g = ref$1[1];
        var b = ref$1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };

    var oklch2rgb_1 = oklch2rgb;

    var unpack = utils.unpack;
    var type$7 = utils.type;
    var chroma$5 = chroma_1;
    var Color$n = Color_1;
    var input = input$h;

    var rgb2oklch = rgb2oklch_1;

    Color$n.prototype.oklch = function () {
        return rgb2oklch(this._rgb);
    };

    chroma$5.oklch = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new (Function.prototype.bind.apply( Color$n, [ null ].concat( args, ['oklch']) ));
    };

    input.format.oklch = oklch2rgb_1;

    input.autodetect.push({
        p: 3,
        test: function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            args = unpack(args, 'oklch');
            if (type$7(args) === 'array' && args.length === 3) {
                return 'oklch';
            }
        }
    });

    var Color$m = Color_1;
    var type$6 = utils.type;

    Color$m.prototype.alpha = function(a, mutate) {
        if ( mutate === void 0 ) mutate=false;

        if (a !== undefined && type$6(a) === 'number') {
            if (mutate) {
                this._rgb[3] = a;
                return this;
            }
            return new Color$m([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');
        }
        return this._rgb[3];
    };

    var Color$l = Color_1;

    Color$l.prototype.clipped = function() {
        return this._rgb._clipped || false;
    };

    var Color$k = Color_1;
    var LAB_CONSTANTS$1 = labConstants;

    Color$k.prototype.darken = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	var me = this;
    	var lab = me.lab();
    	lab[0] -= LAB_CONSTANTS$1.Kn * amount;
    	return new Color$k(lab, 'lab').alpha(me.alpha(), true);
    };

    Color$k.prototype.brighten = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	return this.darken(-amount);
    };

    Color$k.prototype.darker = Color$k.prototype.darken;
    Color$k.prototype.brighter = Color$k.prototype.brighten;

    var Color$j = Color_1;

    Color$j.prototype.get = function (mc) {
        var ref = mc.split('.');
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
            var i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);
            if (i > -1) { return src[i]; }
            throw new Error(("unknown channel " + channel + " in mode " + mode));
        } else {
            return src;
        }
    };

    var Color$i = Color_1;
    var type$5 = utils.type;
    var pow$6 = Math.pow;

    var EPS = 1e-7;
    var MAX_ITER = 20;

    Color$i.prototype.luminance = function(lum) {
        if (lum !== undefined && type$5(lum) === 'number') {
            if (lum === 0) {
                // return pure black
                return new Color$i([0,0,0,this._rgb[3]], 'rgb');
            }
            if (lum === 1) {
                // return pure white
                return new Color$i([255,255,255,this._rgb[3]], 'rgb');
            }
            // compute new color using...
            var cur_lum = this.luminance();
            var mode = 'rgb';
            var max_iter = MAX_ITER;

            var test = function (low, high) {
                var mid = low.interpolate(high, 0.5, mode);
                var lm = mid.luminance();
                if (Math.abs(lum - lm) < EPS || !max_iter--) {
                    // close enough
                    return mid;
                }
                return lm > lum ? test(low, mid) : test(mid, high);
            };

            var rgb = (cur_lum > lum ? test(new Color$i([0,0,0]), this) : test(this, new Color$i([255,255,255]))).rgb();
            return new Color$i(rgb.concat( [this._rgb[3]]));
        }
        return rgb2luminance.apply(void 0, (this._rgb).slice(0,3));
    };


    var rgb2luminance = function (r,g,b) {
        // relative luminance
        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        r = luminance_x(r);
        g = luminance_x(g);
        b = luminance_x(b);
        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    };

    var luminance_x = function (x) {
        x /= 255;
        return x <= 0.03928 ? x/12.92 : pow$6((x+0.055)/1.055, 2.4);
    };

    var interpolator$1 = {};

    var Color$h = Color_1;
    var type$4 = utils.type;
    var interpolator = interpolator$1;

    var mix$1 = function (col1, col2, f) {
        if ( f === void 0 ) f=0.5;
        var rest = [], len = arguments.length - 3;
        while ( len-- > 0 ) rest[ len ] = arguments[ len + 3 ];

        var mode = rest[0] || 'lrgb';
        if (!interpolator[mode] && !rest.length) {
            // fall back to the first supported mode
            mode = Object.keys(interpolator)[0];
        }
        if (!interpolator[mode]) {
            throw new Error(("interpolation mode " + mode + " is not defined"));
        }
        if (type$4(col1) !== 'object') { col1 = new Color$h(col1); }
        if (type$4(col2) !== 'object') { col2 = new Color$h(col2); }
        return interpolator[mode](col1, col2, f)
            .alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
    };

    var Color$g = Color_1;
    var mix = mix$1;

    Color$g.prototype.mix =
    Color$g.prototype.interpolate = function(col2, f) {
    	if ( f === void 0 ) f=0.5;
    	var rest = [], len = arguments.length - 2;
    	while ( len-- > 0 ) rest[ len ] = arguments[ len + 2 ];

    	return mix.apply(void 0, [ this, col2, f ].concat( rest ));
    };

    var Color$f = Color_1;

    Color$f.prototype.premultiply = function(mutate) {
    	if ( mutate === void 0 ) mutate=false;

    	var rgb = this._rgb;
    	var a = rgb[3];
    	if (mutate) {
    		this._rgb = [rgb[0]*a, rgb[1]*a, rgb[2]*a, a];
    		return this;
    	} else {
    		return new Color$f([rgb[0]*a, rgb[1]*a, rgb[2]*a, a], 'rgb');
    	}
    };

    var Color$e = Color_1;
    var LAB_CONSTANTS = labConstants;

    Color$e.prototype.saturate = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	var me = this;
    	var lch = me.lch();
    	lch[1] += LAB_CONSTANTS.Kn * amount;
    	if (lch[1] < 0) { lch[1] = 0; }
    	return new Color$e(lch, 'lch').alpha(me.alpha(), true);
    };

    Color$e.prototype.desaturate = function(amount) {
    	if ( amount === void 0 ) amount=1;

    	return this.saturate(-amount);
    };

    var Color$d = Color_1;
    var type$3 = utils.type;

    Color$d.prototype.set = function (mc, value, mutate) {
        if ( mutate === void 0 ) mutate = false;

        var ref = mc.split('.');
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
            var i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);
            if (i > -1) {
                if (type$3(value) == 'string') {
                    switch (value.charAt(0)) {
                        case '+':
                            src[i] += +value;
                            break;
                        case '-':
                            src[i] += +value;
                            break;
                        case '*':
                            src[i] *= +value.substr(1);
                            break;
                        case '/':
                            src[i] /= +value.substr(1);
                            break;
                        default:
                            src[i] = +value;
                    }
                } else if (type$3(value) === 'number') {
                    src[i] = value;
                } else {
                    throw new Error("unsupported value for Color.set");
                }
                var out = new Color$d(src, mode);
                if (mutate) {
                    this._rgb = out._rgb;
                    return this;
                }
                return out;
            }
            throw new Error(("unknown channel " + channel + " in mode " + mode));
        } else {
            return src;
        }
    };

    var Color$c = Color_1;

    var rgb = function (col1, col2, f) {
        var xyz0 = col1._rgb;
        var xyz1 = col2._rgb;
        return new Color$c(
            xyz0[0] + f * (xyz1[0]-xyz0[0]),
            xyz0[1] + f * (xyz1[1]-xyz0[1]),
            xyz0[2] + f * (xyz1[2]-xyz0[2]),
            'rgb'
        )
    };

    // register interpolator
    interpolator$1.rgb = rgb;

    var Color$b = Color_1;
    var sqrt$2 = Math.sqrt;
    var pow$5 = Math.pow;

    var lrgb = function (col1, col2, f) {
        var ref = col1._rgb;
        var x1 = ref[0];
        var y1 = ref[1];
        var z1 = ref[2];
        var ref$1 = col2._rgb;
        var x2 = ref$1[0];
        var y2 = ref$1[1];
        var z2 = ref$1[2];
        return new Color$b(
            sqrt$2(pow$5(x1,2) * (1-f) + pow$5(x2,2) * f),
            sqrt$2(pow$5(y1,2) * (1-f) + pow$5(y2,2) * f),
            sqrt$2(pow$5(z1,2) * (1-f) + pow$5(z2,2) * f),
            'rgb'
        )
    };

    // register interpolator
    interpolator$1.lrgb = lrgb;

    var Color$a = Color_1;

    var lab = function (col1, col2, f) {
        var xyz0 = col1.lab();
        var xyz1 = col2.lab();
        return new Color$a(
            xyz0[0] + f * (xyz1[0]-xyz0[0]),
            xyz0[1] + f * (xyz1[1]-xyz0[1]),
            xyz0[2] + f * (xyz1[2]-xyz0[2]),
            'lab'
        )
    };

    // register interpolator
    interpolator$1.lab = lab;

    var Color$9 = Color_1;

    var _hsx = function (col1, col2, f, m) {
        var assign, assign$1;

        var xyz0, xyz1;
        if (m === 'hsl') {
            xyz0 = col1.hsl();
            xyz1 = col2.hsl();
        } else if (m === 'hsv') {
            xyz0 = col1.hsv();
            xyz1 = col2.hsv();
        } else if (m === 'hcg') {
            xyz0 = col1.hcg();
            xyz1 = col2.hcg();
        } else if (m === 'hsi') {
            xyz0 = col1.hsi();
            xyz1 = col2.hsi();
        } else if (m === 'lch' || m === 'hcl') {
            m = 'hcl';
            xyz0 = col1.hcl();
            xyz1 = col2.hcl();
        } else if (m === 'oklch') {
            xyz0 = col1.oklch().reverse();
            xyz1 = col2.oklch().reverse();
        }

        var hue0, hue1, sat0, sat1, lbv0, lbv1;
        if (m.substr(0, 1) === 'h' || m === 'oklch') {
            (assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2]);
            (assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2]);
        }

        var sat, hue, lbv, dh;

        if (!isNaN(hue0) && !isNaN(hue1)) {
            // both colors have hue
            if (hue1 > hue0 && hue1 - hue0 > 180) {
                dh = hue1 - (hue0 + 360);
            } else if (hue1 < hue0 && hue0 - hue1 > 180) {
                dh = hue1 + 360 - hue0;
            } else {
                dh = hue1 - hue0;
            }
            hue = hue0 + f * dh;
        } else if (!isNaN(hue0)) {
            hue = hue0;
            if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') { sat = sat0; }
        } else if (!isNaN(hue1)) {
            hue = hue1;
            if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') { sat = sat1; }
        } else {
            hue = Number.NaN;
        }

        if (sat === undefined) { sat = sat0 + f * (sat1 - sat0); }
        lbv = lbv0 + f * (lbv1 - lbv0);
        return m === 'oklch' ? new Color$9([lbv, sat, hue], m) : new Color$9([hue, sat, lbv], m);
    };

    var interpolate_hsx$5 = _hsx;

    var lch = function (col1, col2, f) {
    	return interpolate_hsx$5(col1, col2, f, 'lch');
    };

    // register interpolator
    interpolator$1.lch = lch;
    interpolator$1.hcl = lch;

    var Color$8 = Color_1;

    var num = function (col1, col2, f) {
        var c1 = col1.num();
        var c2 = col2.num();
        return new Color$8(c1 + f * (c2-c1), 'num')
    };

    // register interpolator
    interpolator$1.num = num;

    var interpolate_hsx$4 = _hsx;

    var hcg = function (col1, col2, f) {
    	return interpolate_hsx$4(col1, col2, f, 'hcg');
    };

    // register interpolator
    interpolator$1.hcg = hcg;

    var interpolate_hsx$3 = _hsx;

    var hsi = function (col1, col2, f) {
    	return interpolate_hsx$3(col1, col2, f, 'hsi');
    };

    // register interpolator
    interpolator$1.hsi = hsi;

    var interpolate_hsx$2 = _hsx;

    var hsl = function (col1, col2, f) {
    	return interpolate_hsx$2(col1, col2, f, 'hsl');
    };

    // register interpolator
    interpolator$1.hsl = hsl;

    var interpolate_hsx$1 = _hsx;

    var hsv = function (col1, col2, f) {
    	return interpolate_hsx$1(col1, col2, f, 'hsv');
    };

    // register interpolator
    interpolator$1.hsv = hsv;

    var Color$7 = Color_1;

    var oklab = function (col1, col2, f) {
        var xyz0 = col1.oklab();
        var xyz1 = col2.oklab();
        return new Color$7(
            xyz0[0] + f * (xyz1[0] - xyz0[0]),
            xyz0[1] + f * (xyz1[1] - xyz0[1]),
            xyz0[2] + f * (xyz1[2] - xyz0[2]),
            'oklab'
        );
    };

    // register interpolator
    interpolator$1.oklab = oklab;

    var interpolate_hsx = _hsx;

    var oklch = function (col1, col2, f) {
        return interpolate_hsx(col1, col2, f, 'oklch');
    };

    // register interpolator
    interpolator$1.oklch = oklch;

    var Color$6 = Color_1;
    var clip_rgb$1 = utils.clip_rgb;
    var pow$4 = Math.pow;
    var sqrt$1 = Math.sqrt;
    var PI$1 = Math.PI;
    var cos$2 = Math.cos;
    var sin$2 = Math.sin;
    var atan2$1 = Math.atan2;

    var average = function (colors, mode, weights) {
        if ( mode === void 0 ) mode='lrgb';
        if ( weights === void 0 ) weights=null;

        var l = colors.length;
        if (!weights) { weights = Array.from(new Array(l)).map(function () { return 1; }); }
        // normalize weights
        var k = l / weights.reduce(function(a, b) { return a + b; });
        weights.forEach(function (w,i) { weights[i] *= k; });
        // convert colors to Color objects
        colors = colors.map(function (c) { return new Color$6(c); });
        if (mode === 'lrgb') {
            return _average_lrgb(colors, weights)
        }
        var first = colors.shift();
        var xyz = first.get(mode);
        var cnt = [];
        var dx = 0;
        var dy = 0;
        // initial color
        for (var i=0; i<xyz.length; i++) {
            xyz[i] = (xyz[i] || 0) * weights[0];
            cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);
            if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {
                var A = xyz[i] / 180 * PI$1;
                dx += cos$2(A) * weights[0];
                dy += sin$2(A) * weights[0];
            }
        }

        var alpha = first.alpha() * weights[0];
        colors.forEach(function (c,ci) {
            var xyz2 = c.get(mode);
            alpha += c.alpha() * weights[ci+1];
            for (var i=0; i<xyz.length; i++) {
                if (!isNaN(xyz2[i])) {
                    cnt[i] += weights[ci+1];
                    if (mode.charAt(i) === 'h') {
                        var A = xyz2[i] / 180 * PI$1;
                        dx += cos$2(A) * weights[ci+1];
                        dy += sin$2(A) * weights[ci+1];
                    } else {
                        xyz[i] += xyz2[i] * weights[ci+1];
                    }
                }
            }
        });

        for (var i$1=0; i$1<xyz.length; i$1++) {
            if (mode.charAt(i$1) === 'h') {
                var A$1 = atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1 * 180;
                while (A$1 < 0) { A$1 += 360; }
                while (A$1 >= 360) { A$1 -= 360; }
                xyz[i$1] = A$1;
            } else {
                xyz[i$1] = xyz[i$1]/cnt[i$1];
            }
        }
        alpha /= l;
        return (new Color$6(xyz, mode)).alpha(alpha > 0.99999 ? 1 : alpha, true);
    };


    var _average_lrgb = function (colors, weights) {
        var l = colors.length;
        var xyz = [0,0,0,0];
        for (var i=0; i < colors.length; i++) {
            var col = colors[i];
            var f = weights[i] / l;
            var rgb = col._rgb;
            xyz[0] += pow$4(rgb[0],2) * f;
            xyz[1] += pow$4(rgb[1],2) * f;
            xyz[2] += pow$4(rgb[2],2) * f;
            xyz[3] += rgb[3] * f;
        }
        xyz[0] = sqrt$1(xyz[0]);
        xyz[1] = sqrt$1(xyz[1]);
        xyz[2] = sqrt$1(xyz[2]);
        if (xyz[3] > 0.9999999) { xyz[3] = 1; }
        return new Color$6(clip_rgb$1(xyz));
    };

    // minimal multi-purpose interface

    // @requires utils color analyze

    var chroma$4 = chroma_1;
    var type$2 = utils.type;

    var pow$3 = Math.pow;

    var scale$2 = function(colors) {

        // constructor
        var _mode = 'rgb';
        var _nacol = chroma$4('#ccc');
        var _spread = 0;
        // const _fixed = false;
        var _domain = [0, 1];
        var _pos = [];
        var _padding = [0,0];
        var _classes = false;
        var _colors = [];
        var _out = false;
        var _min = 0;
        var _max = 1;
        var _correctLightness = false;
        var _colorCache = {};
        var _useCache = true;
        var _gamma = 1;

        // private methods

        var setColors = function(colors) {
            colors = colors || ['#fff', '#000'];
            if (colors && type$2(colors) === 'string' && chroma$4.brewer &&
                chroma$4.brewer[colors.toLowerCase()]) {
                colors = chroma$4.brewer[colors.toLowerCase()];
            }
            if (type$2(colors) === 'array') {
                // handle single color
                if (colors.length === 1) {
                    colors = [colors[0], colors[0]];
                }
                // make a copy of the colors
                colors = colors.slice(0);
                // convert to chroma classes
                for (var c=0; c<colors.length; c++) {
                    colors[c] = chroma$4(colors[c]);
                }
                // auto-fill color position
                _pos.length = 0;
                for (var c$1=0; c$1<colors.length; c$1++) {
                    _pos.push(c$1/(colors.length-1));
                }
            }
            resetCache();
            return _colors = colors;
        };

        var getClass = function(value) {
            if (_classes != null) {
                var n = _classes.length-1;
                var i = 0;
                while (i < n && value >= _classes[i]) {
                    i++;
                }
                return i-1;
            }
            return 0;
        };

        var tMapLightness = function (t) { return t; };
        var tMapDomain = function (t) { return t; };

        // const classifyValue = function(value) {
        //     let val = value;
        //     if (_classes.length > 2) {
        //         const n = _classes.length-1;
        //         const i = getClass(value);
        //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class
        //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class
        //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));
        //     }
        //     return val;
        // };

        var getColor = function(val, bypassMap) {
            var col, t;
            if (bypassMap == null) { bypassMap = false; }
            if (isNaN(val) || (val === null)) { return _nacol; }
            if (!bypassMap) {
                if (_classes && (_classes.length > 2)) {
                    // find the class
                    var c = getClass(val);
                    t = c / (_classes.length-2);
                } else if (_max !== _min) {
                    // just interpolate between min/max
                    t = (val - _min) / (_max - _min);
                } else {
                    t = 1;
                }
            } else {
                t = val;
            }

            // domain map
            t = tMapDomain(t);

            if (!bypassMap) {
                t = tMapLightness(t);  // lightness correction
            }

            if (_gamma !== 1) { t = pow$3(t, _gamma); }

            t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));

            t = Math.min(1, Math.max(0, t));

            var k = Math.floor(t * 10000);

            if (_useCache && _colorCache[k]) {
                col = _colorCache[k];
            } else {
                if (type$2(_colors) === 'array') {
                    //for i in [0.._pos.length-1]
                    for (var i=0; i<_pos.length; i++) {
                        var p = _pos[i];
                        if (t <= p) {
                            col = _colors[i];
                            break;
                        }
                        if ((t >= p) && (i === (_pos.length-1))) {
                            col = _colors[i];
                            break;
                        }
                        if (t > p && t < _pos[i+1]) {
                            t = (t-p)/(_pos[i+1]-p);
                            col = chroma$4.interpolate(_colors[i], _colors[i+1], t, _mode);
                            break;
                        }
                    }
                } else if (type$2(_colors) === 'function') {
                    col = _colors(t);
                }
                if (_useCache) { _colorCache[k] = col; }
            }
            return col;
        };

        var resetCache = function () { return _colorCache = {}; };

        setColors(colors);

        // public interface

        var f = function(v) {
            var c = chroma$4(getColor(v));
            if (_out && c[_out]) { return c[_out](); } else { return c; }
        };

        f.classes = function(classes) {
            if (classes != null) {
                if (type$2(classes) === 'array') {
                    _classes = classes;
                    _domain = [classes[0], classes[classes.length-1]];
                } else {
                    var d = chroma$4.analyze(_domain);
                    if (classes === 0) {
                        _classes = [d.min, d.max];
                    } else {
                        _classes = chroma$4.limits(d, 'e', classes);
                    }
                }
                return f;
            }
            return _classes;
        };


        f.domain = function(domain) {
            if (!arguments.length) {
                return _domain;
            }
            _min = domain[0];
            _max = domain[domain.length-1];
            _pos = [];
            var k = _colors.length;
            if ((domain.length === k) && (_min !== _max)) {
                // update positions
                for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {
                    var d = list[i];

                  _pos.push((d-_min) / (_max-_min));
                }
            } else {
                for (var c=0; c<k; c++) {
                    _pos.push(c/(k-1));
                }
                if (domain.length > 2) {
                    // set domain map
                    var tOut = domain.map(function (d,i) { return i/(domain.length-1); });
                    var tBreaks = domain.map(function (d) { return (d - _min) / (_max - _min); });
                    if (!tBreaks.every(function (val, i) { return tOut[i] === val; })) {
                        tMapDomain = function (t) {
                            if (t <= 0 || t >= 1) { return t; }
                            var i = 0;
                            while (t >= tBreaks[i+1]) { i++; }
                            var f = (t - tBreaks[i]) / (tBreaks[i+1] - tBreaks[i]);
                            var out = tOut[i] + f * (tOut[i+1] - tOut[i]);
                            return out;
                        };
                    }

                }
            }
            _domain = [_min, _max];
            return f;
        };

        f.mode = function(_m) {
            if (!arguments.length) {
                return _mode;
            }
            _mode = _m;
            resetCache();
            return f;
        };

        f.range = function(colors, _pos) {
            setColors(colors);
            return f;
        };

        f.out = function(_o) {
            _out = _o;
            return f;
        };

        f.spread = function(val) {
            if (!arguments.length) {
                return _spread;
            }
            _spread = val;
            return f;
        };

        f.correctLightness = function(v) {
            if (v == null) { v = true; }
            _correctLightness = v;
            resetCache();
            if (_correctLightness) {
                tMapLightness = function(t) {
                    var L0 = getColor(0, true).lab()[0];
                    var L1 = getColor(1, true).lab()[0];
                    var pol = L0 > L1;
                    var L_actual = getColor(t, true).lab()[0];
                    var L_ideal = L0 + ((L1 - L0) * t);
                    var L_diff = L_actual - L_ideal;
                    var t0 = 0;
                    var t1 = 1;
                    var max_iter = 20;
                    while ((Math.abs(L_diff) > 1e-2) && (max_iter-- > 0)) {
                        (function() {
                            if (pol) { L_diff *= -1; }
                            if (L_diff < 0) {
                                t0 = t;
                                t += (t1 - t) * 0.5;
                            } else {
                                t1 = t;
                                t += (t0 - t) * 0.5;
                            }
                            L_actual = getColor(t, true).lab()[0];
                            return L_diff = L_actual - L_ideal;
                        })();
                    }
                    return t;
                };
            } else {
                tMapLightness = function (t) { return t; };
            }
            return f;
        };

        f.padding = function(p) {
            if (p != null) {
                if (type$2(p) === 'number') {
                    p = [p,p];
                }
                _padding = p;
                return f;
            } else {
                return _padding;
            }
        };

        f.colors = function(numColors, out) {
            // If no arguments are given, return the original colors that were provided
            if (arguments.length < 2) { out = 'hex'; }
            var result = [];

            if (arguments.length === 0) {
                result = _colors.slice(0);

            } else if (numColors === 1) {
                result = [f(0.5)];

            } else if (numColors > 1) {
                var dm = _domain[0];
                var dd = _domain[1] - dm;
                result = __range__(0, numColors, false).map(function (i) { return f( dm + ((i/(numColors-1)) * dd) ); });

            } else { // returns all colors based on the defined classes
                colors = [];
                var samples = [];
                if (_classes && (_classes.length > 2)) {
                    for (var i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
                        samples.push((_classes[i-1]+_classes[i])*0.5);
                    }
                } else {
                    samples = _domain;
                }
                result = samples.map(function (v) { return f(v); });
            }

            if (chroma$4[out]) {
                result = result.map(function (c) { return c[out](); });
            }
            return result;
        };

        f.cache = function(c) {
            if (c != null) {
                _useCache = c;
                return f;
            } else {
                return _useCache;
            }
        };

        f.gamma = function(g) {
            if (g != null) {
                _gamma = g;
                return f;
            } else {
                return _gamma;
            }
        };

        f.nodata = function(d) {
            if (d != null) {
                _nacol = chroma$4(d);
                return f;
            } else {
                return _nacol;
            }
        };

        return f;
    };

    function __range__(left, right, inclusive) {
      var range = [];
      var ascending = left < right;
      var end = !inclusive ? right : ascending ? right + 1 : right - 1;
      for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
        range.push(i);
      }
      return range;
    }

    //
    // interpolates between a set of colors uzing a bezier spline
    //

    // @requires utils lab
    var Color$5 = Color_1;

    var scale$1 = scale$2;

    // nth row of the pascal triangle
    var binom_row = function(n) {
        var row = [1, 1];
        for (var i = 1; i < n; i++) {
            var newrow = [1];
            for (var j = 1; j <= row.length; j++) {
                newrow[j] = (row[j] || 0) + row[j - 1];
            }
            row = newrow;
        }
        return row;
    };

    var bezier = function(colors) {
        var assign, assign$1, assign$2;

        var I, lab0, lab1, lab2;
        colors = colors.map(function (c) { return new Color$5(c); });
        if (colors.length === 2) {
            // linear interpolation
            (assign = colors.map(function (c) { return c.lab(); }), lab0 = assign[0], lab1 = assign[1]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return lab0[i] + (t * (lab1[i] - lab0[i])); }));
                return new Color$5(lab, 'lab');
            };
        } else if (colors.length === 3) {
            // quadratic bezier interpolation
            (assign$1 = colors.map(function (c) { return c.lab(); }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t) * lab0[i]) + (2 * (1-t) * t * lab1[i]) + (t * t * lab2[i]); }));
                return new Color$5(lab, 'lab');
            };
        } else if (colors.length === 4) {
            // cubic bezier interpolation
            var lab3;
            (assign$2 = colors.map(function (c) { return c.lab(); }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3]);
            I = function(t) {
                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t)*(1-t) * lab0[i]) + (3 * (1-t) * (1-t) * t * lab1[i]) + (3 * (1-t) * t * t * lab2[i]) + (t*t*t * lab3[i]); }));
                return new Color$5(lab, 'lab');
            };
        } else if (colors.length >= 5) {
            // general case (degree n bezier)
            var labs, row, n;
            labs = colors.map(function (c) { return c.lab(); });
            n = colors.length - 1;
            row = binom_row(n);
            I = function (t) {
                var u = 1 - t;
                var lab = ([0, 1, 2].map(function (i) { return labs.reduce(function (sum, el, j) { return (sum + row[j] * Math.pow( u, (n - j) ) * Math.pow( t, j ) * el[i]); }, 0); }));
                return new Color$5(lab, 'lab');
            };
        } else {
            throw new RangeError("No point in running bezier with only one color.")
        }
        return I;
    };

    var bezier_1 = function (colors) {
        var f = bezier(colors);
        f.scale = function () { return scale$1(f); };
        return f;
    };

    /*
     * interpolates between a set of colors uzing a bezier spline
     * blend mode formulas taken from http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/
     */

    var chroma$3 = chroma_1;

    var blend = function (bottom, top, mode) {
        if (!blend[mode]) {
            throw new Error('unknown blend mode ' + mode);
        }
        return blend[mode](bottom, top);
    };

    var blend_f = function (f) { return function (bottom,top) {
            var c0 = chroma$3(top).rgb();
            var c1 = chroma$3(bottom).rgb();
            return chroma$3.rgb(f(c0, c1));
        }; };

    var each = function (f) { return function (c0, c1) {
            var out = [];
            out[0] = f(c0[0], c1[0]);
            out[1] = f(c0[1], c1[1]);
            out[2] = f(c0[2], c1[2]);
            return out;
        }; };

    var normal = function (a) { return a; };
    var multiply = function (a,b) { return a * b / 255; };
    var darken = function (a,b) { return a > b ? b : a; };
    var lighten = function (a,b) { return a > b ? a : b; };
    var screen = function (a,b) { return 255 * (1 - (1-a/255) * (1-b/255)); };
    var overlay = function (a,b) { return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255 ) * ( 1 - b / 255 )); };
    var burn = function (a,b) { return 255 * (1 - (1 - b / 255) / (a/255)); };
    var dodge = function (a,b) {
        if (a === 255) { return 255; }
        a = 255 * (b / 255) / (1 - a / 255);
        return a > 255 ? 255 : a
    };

    // # add = (a,b) ->
    // #     if (a + b > 255) then 255 else a + b

    blend.normal = blend_f(each(normal));
    blend.multiply = blend_f(each(multiply));
    blend.screen = blend_f(each(screen));
    blend.overlay = blend_f(each(overlay));
    blend.darken = blend_f(each(darken));
    blend.lighten = blend_f(each(lighten));
    blend.dodge = blend_f(each(dodge));
    blend.burn = blend_f(each(burn));
    // blend.add = blend_f(each(add));

    var blend_1 = blend;

    // cubehelix interpolation
    // based on D.A. Green "A colour scheme for the display of astronomical intensity images"
    // http://astron-soc.in/bulletin/11June/289392011.pdf

    var type$1 = utils.type;
    var clip_rgb = utils.clip_rgb;
    var TWOPI = utils.TWOPI;
    var pow$2 = Math.pow;
    var sin$1 = Math.sin;
    var cos$1 = Math.cos;
    var chroma$2 = chroma_1;

    var cubehelix = function(start, rotations, hue, gamma, lightness) {
        if ( start === void 0 ) start=300;
        if ( rotations === void 0 ) rotations=-1.5;
        if ( hue === void 0 ) hue=1;
        if ( gamma === void 0 ) gamma=1;
        if ( lightness === void 0 ) lightness=[0,1];

        var dh = 0, dl;
        if (type$1(lightness) === 'array') {
            dl = lightness[1] - lightness[0];
        } else {
            dl = 0;
            lightness = [lightness, lightness];
        }

        var f = function(fract) {
            var a = TWOPI * (((start+120)/360) + (rotations * fract));
            var l = pow$2(lightness[0] + (dl * fract), gamma);
            var h = dh !== 0 ? hue[0] + (fract * dh) : hue;
            var amp = (h * l * (1-l)) / 2;
            var cos_a = cos$1(a);
            var sin_a = sin$1(a);
            var r = l + (amp * ((-0.14861 * cos_a) + (1.78277* sin_a)));
            var g = l + (amp * ((-0.29227 * cos_a) - (0.90649* sin_a)));
            var b = l + (amp * (+1.97294 * cos_a));
            return chroma$2(clip_rgb([r*255,g*255,b*255,1]));
        };

        f.start = function(s) {
            if ((s == null)) { return start; }
            start = s;
            return f;
        };

        f.rotations = function(r) {
            if ((r == null)) { return rotations; }
            rotations = r;
            return f;
        };

        f.gamma = function(g) {
            if ((g == null)) { return gamma; }
            gamma = g;
            return f;
        };

        f.hue = function(h) {
            if ((h == null)) { return hue; }
            hue = h;
            if (type$1(hue) === 'array') {
                dh = hue[1] - hue[0];
                if (dh === 0) { hue = hue[1]; }
            } else {
                dh = 0;
            }
            return f;
        };

        f.lightness = function(h) {
            if ((h == null)) { return lightness; }
            if (type$1(h) === 'array') {
                lightness = h;
                dl = h[1] - h[0];
            } else {
                lightness = [h,h];
                dl = 0;
            }
            return f;
        };

        f.scale = function () { return chroma$2.scale(f); };

        f.hue(hue);

        return f;
    };

    var Color$4 = Color_1;
    var digits = '0123456789abcdef';

    var floor$1 = Math.floor;
    var random = Math.random;

    var random_1 = function () {
        var code = '#';
        for (var i=0; i<6; i++) {
            code += digits.charAt(floor$1(random() * 16));
        }
        return new Color$4(code, 'hex');
    };

    var type = type$p;
    var log = Math.log;
    var pow$1 = Math.pow;
    var floor = Math.floor;
    var abs$1 = Math.abs;


    var analyze = function (data, key) {
        if ( key === void 0 ) key=null;

        var r = {
            min: Number.MAX_VALUE,
            max: Number.MAX_VALUE*-1,
            sum: 0,
            values: [],
            count: 0
        };
        if (type(data) === 'object') {
            data = Object.values(data);
        }
        data.forEach(function (val) {
            if (key && type(val) === 'object') { val = val[key]; }
            if (val !== undefined && val !== null && !isNaN(val)) {
                r.values.push(val);
                r.sum += val;
                if (val < r.min) { r.min = val; }
                if (val > r.max) { r.max = val; }
                r.count += 1;
            }
        });

        r.domain = [r.min, r.max];

        r.limits = function (mode, num) { return limits(r, mode, num); };

        return r;
    };


    var limits = function (data, mode, num) {
        if ( mode === void 0 ) mode='equal';
        if ( num === void 0 ) num=7;

        if (type(data) == 'array') {
            data = analyze(data);
        }
        var min = data.min;
        var max = data.max;
        var values = data.values.sort(function (a,b) { return a-b; });

        if (num === 1) { return [min,max]; }

        var limits = [];

        if (mode.substr(0,1) === 'c') { // continuous
            limits.push(min);
            limits.push(max);
        }

        if (mode.substr(0,1) === 'e') { // equal interval
            limits.push(min);
            for (var i=1; i<num; i++) {
                limits.push(min+((i/num)*(max-min)));
            }
            limits.push(max);
        }

        else if (mode.substr(0,1) === 'l') { // log scale
            if (min <= 0) {
                throw new Error('Logarithmic scales are only possible for values > 0');
            }
            var min_log = Math.LOG10E * log(min);
            var max_log = Math.LOG10E * log(max);
            limits.push(min);
            for (var i$1=1; i$1<num; i$1++) {
                limits.push(pow$1(10, min_log + ((i$1/num) * (max_log - min_log))));
            }
            limits.push(max);
        }

        else if (mode.substr(0,1) === 'q') { // quantile scale
            limits.push(min);
            for (var i$2=1; i$2<num; i$2++) {
                var p = ((values.length-1) * i$2)/num;
                var pb = floor(p);
                if (pb === p) {
                    limits.push(values[pb]);
                } else { // p > pb
                    var pr = p - pb;
                    limits.push((values[pb]*(1-pr)) + (values[pb+1]*pr));
                }
            }
            limits.push(max);

        }

        else if (mode.substr(0,1) === 'k') { // k-means clustering
            /*
            implementation based on
            http://code.google.com/p/figue/source/browse/trunk/figue.js#336
            simplified for 1-d input values
            */
            var cluster;
            var n = values.length;
            var assignments = new Array(n);
            var clusterSizes = new Array(num);
            var repeat = true;
            var nb_iters = 0;
            var centroids = null;

            // get seed values
            centroids = [];
            centroids.push(min);
            for (var i$3=1; i$3<num; i$3++) {
                centroids.push(min + ((i$3/num) * (max-min)));
            }
            centroids.push(max);

            while (repeat) {
                // assignment step
                for (var j=0; j<num; j++) {
                    clusterSizes[j] = 0;
                }
                for (var i$4=0; i$4<n; i$4++) {
                    var value = values[i$4];
                    var mindist = Number.MAX_VALUE;
                    var best = (void 0);
                    for (var j$1=0; j$1<num; j$1++) {
                        var dist = abs$1(centroids[j$1]-value);
                        if (dist < mindist) {
                            mindist = dist;
                            best = j$1;
                        }
                        clusterSizes[best]++;
                        assignments[i$4] = best;
                    }
                }

                // update centroids step
                var newCentroids = new Array(num);
                for (var j$2=0; j$2<num; j$2++) {
                    newCentroids[j$2] = null;
                }
                for (var i$5=0; i$5<n; i$5++) {
                    cluster = assignments[i$5];
                    if (newCentroids[cluster] === null) {
                        newCentroids[cluster] = values[i$5];
                    } else {
                        newCentroids[cluster] += values[i$5];
                    }
                }
                for (var j$3=0; j$3<num; j$3++) {
                    newCentroids[j$3] *= 1/clusterSizes[j$3];
                }

                // check convergence
                repeat = false;
                for (var j$4=0; j$4<num; j$4++) {
                    if (newCentroids[j$4] !== centroids[j$4]) {
                        repeat = true;
                        break;
                    }
                }

                centroids = newCentroids;
                nb_iters++;

                if (nb_iters > 200) {
                    repeat = false;
                }
            }

            // finished k-means clustering
            // the next part is borrowed from gabrielflor.it
            var kClusters = {};
            for (var j$5=0; j$5<num; j$5++) {
                kClusters[j$5] = [];
            }
            for (var i$6=0; i$6<n; i$6++) {
                cluster = assignments[i$6];
                kClusters[cluster].push(values[i$6]);
            }
            var tmpKMeansBreaks = [];
            for (var j$6=0; j$6<num; j$6++) {
                tmpKMeansBreaks.push(kClusters[j$6][0]);
                tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length-1]);
            }
            tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a,b){ return a-b; });
            limits.push(tmpKMeansBreaks[0]);
            for (var i$7=1; i$7 < tmpKMeansBreaks.length; i$7+= 2) {
                var v = tmpKMeansBreaks[i$7];
                if (!isNaN(v) && (limits.indexOf(v) === -1)) {
                    limits.push(v);
                }
            }
        }
        return limits;
    };

    var analyze_1 = {analyze: analyze, limits: limits};

    var Color$3 = Color_1;


    var contrast = function (a, b) {
        // WCAG contrast ratio
        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
        a = new Color$3(a);
        b = new Color$3(b);
        var l1 = a.luminance();
        var l2 = b.luminance();
        return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
    };

    var Color$2 = Color_1;
    var sqrt = Math.sqrt;
    var pow = Math.pow;
    var min = Math.min;
    var max = Math.max;
    var atan2 = Math.atan2;
    var abs = Math.abs;
    var cos = Math.cos;
    var sin = Math.sin;
    var exp = Math.exp;
    var PI = Math.PI;

    var deltaE = function(a, b, Kl, Kc, Kh) {
        if ( Kl === void 0 ) Kl=1;
        if ( Kc === void 0 ) Kc=1;
        if ( Kh === void 0 ) Kh=1;

        // Delta E (CIE 2000)
        // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE2000.html
        var rad2deg = function(rad) {
            return 360 * rad / (2 * PI);
        };
        var deg2rad = function(deg) {
            return (2 * PI * deg) / 360;
        };
        a = new Color$2(a);
        b = new Color$2(b);
        var ref = Array.from(a.lab());
        var L1 = ref[0];
        var a1 = ref[1];
        var b1 = ref[2];
        var ref$1 = Array.from(b.lab());
        var L2 = ref$1[0];
        var a2 = ref$1[1];
        var b2 = ref$1[2];
        var avgL = (L1 + L2)/2;
        var C1 = sqrt(pow(a1, 2) + pow(b1, 2));
        var C2 = sqrt(pow(a2, 2) + pow(b2, 2));
        var avgC = (C1 + C2)/2;
        var G = 0.5*(1-sqrt(pow(avgC, 7)/(pow(avgC, 7) + pow(25, 7))));
        var a1p = a1*(1+G);
        var a2p = a2*(1+G);
        var C1p = sqrt(pow(a1p, 2) + pow(b1, 2));
        var C2p = sqrt(pow(a2p, 2) + pow(b2, 2));
        var avgCp = (C1p + C2p)/2;
        var arctan1 = rad2deg(atan2(b1, a1p));
        var arctan2 = rad2deg(atan2(b2, a2p));
        var h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;
        var h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;
        var avgHp = abs(h1p - h2p) > 180 ? (h1p + h2p + 360)/2 : (h1p + h2p)/2;
        var T = 1 - 0.17*cos(deg2rad(avgHp - 30)) + 0.24*cos(deg2rad(2*avgHp)) + 0.32*cos(deg2rad(3*avgHp + 6)) - 0.2*cos(deg2rad(4*avgHp - 63));
        var deltaHp = h2p - h1p;
        deltaHp = abs(deltaHp) <= 180 ? deltaHp : h2p <= h1p ? deltaHp + 360 : deltaHp - 360;
        deltaHp = 2*sqrt(C1p*C2p)*sin(deg2rad(deltaHp)/2);
        var deltaL = L2 - L1;
        var deltaCp = C2p - C1p;    
        var sl = 1 + (0.015*pow(avgL - 50, 2))/sqrt(20 + pow(avgL - 50, 2));
        var sc = 1 + 0.045*avgCp;
        var sh = 1 + 0.015*avgCp*T;
        var deltaTheta = 30*exp(-pow((avgHp - 275)/25, 2));
        var Rc = 2*sqrt(pow(avgCp, 7)/(pow(avgCp, 7) + pow(25, 7)));
        var Rt = -Rc*sin(2*deg2rad(deltaTheta));
        var result = sqrt(pow(deltaL/(Kl*sl), 2) + pow(deltaCp/(Kc*sc), 2) + pow(deltaHp/(Kh*sh), 2) + Rt*(deltaCp/(Kc*sc))*(deltaHp/(Kh*sh)));
        return max(0, min(100, result));
    };

    var Color$1 = Color_1;

    // simple Euclidean distance
    var distance = function(a, b, mode) {
        if ( mode === void 0 ) mode='lab';

        // Delta E (CIE 1976)
        // see http://www.brucelindbloom.com/index.html?Equations.html
        a = new Color$1(a);
        b = new Color$1(b);
        var l1 = a.get(mode);
        var l2 = b.get(mode);
        var sum_sq = 0;
        for (var i in l1) {
            var d = (l1[i] || 0) - (l2[i] || 0);
            sum_sq += d*d;
        }
        return Math.sqrt(sum_sq);
    };

    var Color = Color_1;

    var valid = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        try {
            new (Function.prototype.bind.apply( Color, [ null ].concat( args) ));
            return true;
        } catch (e) {
            return false;
        }
    };

    // some pre-defined color scales:
    var chroma$1 = chroma_1;

    var scale = scale$2;

    var scales = {
    	cool: function cool() { return scale([chroma$1.hsl(180,1,.9), chroma$1.hsl(250,.7,.4)]) },
    	hot: function hot() { return scale(['#000','#f00','#ff0','#fff']).mode('rgb') }
    };

    /**
        ColorBrewer colors for chroma.js

        Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The
        Pennsylvania State University.

        Licensed under the Apache License, Version 2.0 (the "License");
        you may not use this file except in compliance with the License.
        You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0

        Unless required by applicable law or agreed to in writing, software distributed
        under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
        CONDITIONS OF ANY KIND, either express or implied. See the License for the
        specific language governing permissions and limitations under the License.
    */

    var colorbrewer = {
        // sequential
        OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],
        PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],
        BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],
        Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],
        BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],
        YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],
        YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],
        Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
        RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],
        Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
        YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],
        Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
        GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],
        Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],
        YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],
        PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],
        Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
        PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],
        Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],

        // diverging

        Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
        RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
        PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
        PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
        RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
        RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],
        PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],

        // qualitative

        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],
        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],
    };

    // add lowercase aliases for case-insensitive matches
    for (var i = 0, list = Object.keys(colorbrewer); i < list.length; i += 1) {
        var key = list[i];

        colorbrewer[key.toLowerCase()] = colorbrewer[key];
    }

    var colorbrewer_1 = colorbrewer;

    var chroma = chroma_1;

    // feel free to comment out anything to rollup
    // a smaller chroma.js built

    // io --> convert colors

















    // operators --> modify existing Colors










    // interpolators












    // generators -- > create new colors
    chroma.average = average;
    chroma.bezier = bezier_1;
    chroma.blend = blend_1;
    chroma.cubehelix = cubehelix;
    chroma.mix = chroma.interpolate = mix$1;
    chroma.random = random_1;
    chroma.scale = scale$2;

    // other utility methods
    chroma.analyze = analyze_1.analyze;
    chroma.contrast = contrast;
    chroma.deltaE = deltaE;
    chroma.distance = distance;
    chroma.limits = analyze_1.limits;
    chroma.valid = valid;

    // scale
    chroma.scales = scales;

    // colors
    chroma.colors = w3cx11_1;
    chroma.brewer = colorbrewer_1;

    var chroma_js = chroma;

    return chroma_js;

}));
</script>
<script>
"use strict";
/* @license
Papa Parse
v5.0.2
https://github.com/mholt/PapaParse
License: MIT
*/

(function(root, factory)
{
	/* globals define */
	if (typeof define === 'function' && define.amd)
	{
		// AMD. Register as an anonymous module.
		define([], factory);
	}
	else if (typeof module === 'object' && typeof exports !== 'undefined')
	{
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.
		module.exports = factory();
	}
	else
	{
		// Browser globals (root is window)
		root.Papa = factory();
	}
	// in strict mode we cannot access arguments.callee, so we need a named reference to
	// stringify the factory method for the blob worker
	// eslint-disable-next-line func-name
}(this, function moduleFactory()
{
	'use strict';

	var global = (function() {
		// alternative method, similar to `Function('return this')()`
		// but without using `eval` (which is disabled when
		// using Content Security Policy).

		if (typeof self !== 'undefined') { return self; }
		if (typeof window !== 'undefined') { return window; }
		if (typeof global !== 'undefined') { return global; }

		// When running tests none of the above have been defined
		return {};
	})();


	function getWorkerBlob() {
		var URL = global.URL || global.webkitURL || null;
		var code = moduleFactory.toString();
		return Papa.BLOB_URL || (Papa.BLOB_URL = URL.createObjectURL(new Blob(['(', code, ')();'], {type: 'text/javascript'})));
	}

	var IS_WORKER = !global.document && !!global.postMessage,
		IS_PAPA_WORKER = IS_WORKER && /blob:/i.test((global.location || {}).protocol);
	var workers = {}, workerIdCounter = 0;

	var Papa = {};

	Papa.parse = CsvToJson;
	Papa.unparse = JsonToCsv;

	Papa.RECORD_SEP = String.fromCharCode(30);
	Papa.UNIT_SEP = String.fromCharCode(31);
	Papa.BYTE_ORDER_MARK = '\ufeff';
	Papa.BAD_DELIMITERS = ['\r', '\n', '"', Papa.BYTE_ORDER_MARK];
	Papa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;
	Papa.NODE_STREAM_INPUT = 1;

	// Configurable chunk sizes for local and remote files, respectively
	Papa.LocalChunkSize = 1024 * 1024 * 10;	// 10 MB
	Papa.RemoteChunkSize = 1024 * 1024 * 5;	// 5 MB
	Papa.DefaultDelimiter = ',';			// Used if not specified and detection fails

	// Exposed for testing and development only
	Papa.Parser = Parser;
	Papa.ParserHandle = ParserHandle;
	Papa.NetworkStreamer = NetworkStreamer;
	Papa.FileStreamer = FileStreamer;
	Papa.StringStreamer = StringStreamer;
	Papa.ReadableStreamStreamer = ReadableStreamStreamer;
	if (typeof PAPA_BROWSER_CONTEXT === 'undefined') {
		Papa.DuplexStreamStreamer = DuplexStreamStreamer;
	}

	if (global.jQuery)
	{
		var $ = global.jQuery;
		$.fn.parse = function(options)
		{
			var config = options.config || {};
			var queue = [];

			this.each(function(idx)
			{
				var supported = $(this).prop('tagName').toUpperCase() === 'INPUT'
								&& $(this).attr('type').toLowerCase() === 'file'
								&& global.FileReader;

				if (!supported || !this.files || this.files.length === 0)
					return true;	// continue to next input element

				for (var i = 0; i < this.files.length; i++)
				{
					queue.push({
						file: this.files[i],
						inputElem: this,
						instanceConfig: $.extend({}, config)
					});
				}
			});

			parseNextFile();	// begin parsing
			return this;		// maintains chainability


			function parseNextFile()
			{
				if (queue.length === 0)
				{
					if (isFunction(options.complete))
						options.complete();
					return;
				}

				var f = queue[0];

				if (isFunction(options.before))
				{
					var returned = options.before(f.file, f.inputElem);

					if (typeof returned === 'object')
					{
						if (returned.action === 'abort')
						{
							error('AbortError', f.file, f.inputElem, returned.reason);
							return;	// Aborts all queued files immediately
						}
						else if (returned.action === 'skip')
						{
							fileComplete();	// parse the next file in the queue, if any
							return;
						}
						else if (typeof returned.config === 'object')
							f.instanceConfig = $.extend(f.instanceConfig, returned.config);
					}
					else if (returned === 'skip')
					{
						fileComplete();	// parse the next file in the queue, if any
						return;
					}
				}

				// Wrap up the user's complete callback, if any, so that ours also gets executed
				var userCompleteFunc = f.instanceConfig.complete;
				f.instanceConfig.complete = function(results)
				{
					if (isFunction(userCompleteFunc))
						userCompleteFunc(results, f.file, f.inputElem);
					fileComplete();
				};

				Papa.parse(f.file, f.instanceConfig);
			}

			function error(name, file, elem, reason)
			{
				if (isFunction(options.error))
					options.error({name: name}, file, elem, reason);
			}

			function fileComplete()
			{
				queue.splice(0, 1);
				parseNextFile();
			}
		};
	}


	if (IS_PAPA_WORKER)
	{
		global.onmessage = workerThreadReceivedMessage;
	}




	function CsvToJson(_input, _config)
	{
		_config = _config || {};
		var dynamicTyping = _config.dynamicTyping || false;
		if (isFunction(dynamicTyping)) {
			_config.dynamicTypingFunction = dynamicTyping;
			// Will be filled on first row call
			dynamicTyping = {};
		}
		_config.dynamicTyping = dynamicTyping;

		_config.transform = isFunction(_config.transform) ? _config.transform : false;

		if (_config.worker && Papa.WORKERS_SUPPORTED)
		{
			var w = newWorker();

			w.userStep = _config.step;
			w.userChunk = _config.chunk;
			w.userComplete = _config.complete;
			w.userError = _config.error;

			_config.step = isFunction(_config.step);
			_config.chunk = isFunction(_config.chunk);
			_config.complete = isFunction(_config.complete);
			_config.error = isFunction(_config.error);
			delete _config.worker;	// prevent infinite loop

			w.postMessage({
				input: _input,
				config: _config,
				workerId: w.id
			});

			return;
		}

		var streamer = null;
		if (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === 'undefined')
		{
			// create a node Duplex stream for use
			// with .pipe
			streamer = new DuplexStreamStreamer(_config);
			return streamer.getStream();
		}
		else if (typeof _input === 'string')
		{
			if (_config.download)
				streamer = new NetworkStreamer(_config);
			else
				streamer = new StringStreamer(_config);
		}
		else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on))
		{
			streamer = new ReadableStreamStreamer(_config);
		}
		else if ((global.File && _input instanceof File) || _input instanceof Object)	// ...Safari. (see issue #106)
			streamer = new FileStreamer(_config);

		return streamer.stream(_input);
	}






	function JsonToCsv(_input, _config)
	{
		// Default configuration

		/** whether to surround every datum with quotes */
		var _quotes = false;

		/** whether to write headers */
		var _writeHeader = true;

		/** delimiting character(s) */
		var _delimiter = ',';

		/** newline character(s) */
		var _newline = '\r\n';

		/** quote character */
		var _quoteChar = '"';

		/** escaped quote character, either "" or <config.escapeChar>" */
		var _escapedQuote = _quoteChar + _quoteChar;

		/** whether to skip empty lines */
		var _skipEmptyLines = false;

		/** the columns (keys) we expect when we unparse objects */
		var _columns = null;

		unpackConfig();

		var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), 'g');

		if (typeof _input === 'string')
			_input = JSON.parse(_input);

		if (Array.isArray(_input))
		{
			if (!_input.length || Array.isArray(_input[0]))
				return serialize(null, _input, _skipEmptyLines);
			else if (typeof _input[0] === 'object')
				return serialize(_columns || objectKeys(_input[0]), _input, _skipEmptyLines);
		}
		else if (typeof _input === 'object')
		{
			if (typeof _input.data === 'string')
				_input.data = JSON.parse(_input.data);

			if (Array.isArray(_input.data))
			{
				if (!_input.fields)
					_input.fields =  _input.meta && _input.meta.fields;

				if (!_input.fields)
					_input.fields =  Array.isArray(_input.data[0])
						? _input.fields
						: objectKeys(_input.data[0]);

				if (!(Array.isArray(_input.data[0])) && typeof _input.data[0] !== 'object')
					_input.data = [_input.data];	// handles input like [1,2,3] or ['asdf']
			}

			return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);
		}

		// Default (any valid paths should return before this)
		throw new Error('Unable to serialize unrecognized input');


		function unpackConfig()
		{
			if (typeof _config !== 'object')
				return;

			if (typeof _config.delimiter === 'string'
                && !Papa.BAD_DELIMITERS.filter(function(value) { return _config.delimiter.indexOf(value) !== -1; }).length)
			{
				_delimiter = _config.delimiter;
			}

			if (typeof _config.quotes === 'boolean'
				|| Array.isArray(_config.quotes))
				_quotes = _config.quotes;

			if (typeof _config.skipEmptyLines === 'boolean'
				|| typeof _config.skipEmptyLines === 'string')
				_skipEmptyLines = _config.skipEmptyLines;

			if (typeof _config.newline === 'string')
				_newline = _config.newline;

			if (typeof _config.quoteChar === 'string')
				_quoteChar = _config.quoteChar;

			if (typeof _config.header === 'boolean')
				_writeHeader = _config.header;

			if (Array.isArray(_config.columns)) {

				if (_config.columns.length === 0) throw new Error('Option columns is empty');

				_columns = _config.columns;
			}

			if (_config.escapeChar !== undefined) {
				_escapedQuote = _config.escapeChar + _quoteChar;
			}
		}


		/** Turns an object's keys into an array */
		function objectKeys(obj)
		{
			if (typeof obj !== 'object')
				return [];
			var keys = [];
			for (var key in obj)
				keys.push(key);
			return keys;
		}

		/** The double for loop that iterates the data and writes out a CSV string including header row */
		function serialize(fields, data, skipEmptyLines)
		{
			var csv = '';

			if (typeof fields === 'string')
				fields = JSON.parse(fields);
			if (typeof data === 'string')
				data = JSON.parse(data);

			var hasHeader = Array.isArray(fields) && fields.length > 0;
			var dataKeyedByField = !(Array.isArray(data[0]));

			// If there a header row, write it first
			if (hasHeader && _writeHeader)
			{
				for (var i = 0; i < fields.length; i++)
				{
					if (i > 0)
						csv += _delimiter;
					csv += safe(fields[i], i);
				}
				if (data.length > 0)
					csv += _newline;
			}

			// Then write out the data
			for (var row = 0; row < data.length; row++)
			{
				var maxCol = hasHeader ? fields.length : data[row].length;

				var emptyLine = false;
				var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;
				if (skipEmptyLines && !hasHeader)
				{
					emptyLine = skipEmptyLines === 'greedy' ? data[row].join('').trim() === '' : data[row].length === 1 && data[row][0].length === 0;
				}
				if (skipEmptyLines === 'greedy' && hasHeader) {
					var line = [];
					for (var c = 0; c < maxCol; c++) {
						var cx = dataKeyedByField ? fields[c] : c;
						line.push(data[row][cx]);
					}
					emptyLine = line.join('').trim() === '';
				}
				if (!emptyLine)
				{
					for (var col = 0; col < maxCol; col++)
					{
						if (col > 0 && !nullLine)
							csv += _delimiter;
						var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
						csv += safe(data[row][colIdx], col);
					}
					if (row < data.length - 1 && (!skipEmptyLines || (maxCol > 0 && !nullLine)))
					{
						csv += _newline;
					}
				}
			}
			return csv;
		}

		/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */
		function safe(str, col)
		{
			if (typeof str === 'undefined' || str === null)
				return '';

			if (str.constructor === Date)
				return JSON.stringify(str).slice(1, 25);

			str = str.toString().replace(quoteCharRegex, _escapedQuote);

			var needsQuotes = (typeof _quotes === 'boolean' && _quotes)
							|| (Array.isArray(_quotes) && _quotes[col])
							|| hasAny(str, Papa.BAD_DELIMITERS)
							|| str.indexOf(_delimiter) > -1
							|| str.charAt(0) === ' '
							|| str.charAt(str.length - 1) === ' ';

			return needsQuotes ? _quoteChar + str + _quoteChar : str;
		}

		function hasAny(str, substrings)
		{
			for (var i = 0; i < substrings.length; i++)
				if (str.indexOf(substrings[i]) > -1)
					return true;
			return false;
		}
	}

	/** ChunkStreamer is the base prototype for various streamer implementations. */
	function ChunkStreamer(config)
	{
		this._handle = null;
		this._finished = false;
		this._completed = false;
		this._halted = false;
		this._input = null;
		this._baseIndex = 0;
		this._partialLine = '';
		this._rowCount = 0;
		this._start = 0;
		this._nextChunk = null;
		this.isFirstChunk = true;
		this._completeResults = {
			data: [],
			errors: [],
			meta: {}
		};
		replaceConfig.call(this, config);

		this.parseChunk = function(chunk, isFakeChunk)
		{
			// First chunk pre-processing
			if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))
			{
				var modifiedChunk = this._config.beforeFirstChunk(chunk);
				if (modifiedChunk !== undefined)
					chunk = modifiedChunk;
			}
			this.isFirstChunk = false;
			this._halted = false;

			// Rejoin the line we likely just split in two by chunking the file
			var aggregate = this._partialLine + chunk;
			this._partialLine = '';

			var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);

			if (this._handle.paused() || this._handle.aborted()) {
				this._halted = true;
				return;
			}

			var lastIndex = results.meta.cursor;

			if (!this._finished)
			{
				this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
				this._baseIndex = lastIndex;
			}

			if (results && results.data)
				this._rowCount += results.data.length;

			var finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);

			if (IS_PAPA_WORKER)
			{
				global.postMessage({
					results: results,
					workerId: Papa.WORKER_ID,
					finished: finishedIncludingPreview
				});
			}
			else if (isFunction(this._config.chunk) && !isFakeChunk)
			{
				this._config.chunk(results, this._handle);
				if (this._handle.paused() || this._handle.aborted()) {
					this._halted = true;
					return;
				}
				results = undefined;
				this._completeResults = undefined;
			}

			if (!this._config.step && !this._config.chunk) {
				this._completeResults.data = this._completeResults.data.concat(results.data);
				this._completeResults.errors = this._completeResults.errors.concat(results.errors);
				this._completeResults.meta = results.meta;
			}

			if (!this._completed && finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted)) {
				this._config.complete(this._completeResults, this._input);
				this._completed = true;
			}

			if (!finishedIncludingPreview && (!results || !results.meta.paused))
				this._nextChunk();

			return results;
		};

		this._sendError = function(error)
		{
			if (isFunction(this._config.error))
				this._config.error(error);
			else if (IS_PAPA_WORKER && this._config.error)
			{
				global.postMessage({
					workerId: Papa.WORKER_ID,
					error: error,
					finished: false
				});
			}
		};

		function replaceConfig(config)
		{
			// Deep-copy the config so we can edit it
			var configCopy = copy(config);
			configCopy.chunkSize = parseInt(configCopy.chunkSize);	// parseInt VERY important so we don't concatenate strings!
			if (!config.step && !config.chunk)
				configCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196
			this._handle = new ParserHandle(configCopy);
			this._handle.streamer = this;
			this._config = configCopy;	// persist the copy to the caller
		}
	}


	function NetworkStreamer(config)
	{
		config = config || {};
		if (!config.chunkSize)
			config.chunkSize = Papa.RemoteChunkSize;
		ChunkStreamer.call(this, config);

		var xhr;

		if (IS_WORKER)
		{
			this._nextChunk = function()
			{
				this._readChunk();
				this._chunkLoaded();
			};
		}
		else
		{
			this._nextChunk = function()
			{
				this._readChunk();
			};
		}

		this.stream = function(url)
		{
			this._input = url;
			this._nextChunk();	// Starts streaming
		};

		this._readChunk = function()
		{
			if (this._finished)
			{
				this._chunkLoaded();
				return;
			}

			xhr = new XMLHttpRequest();

			if (this._config.withCredentials)
			{
				xhr.withCredentials = this._config.withCredentials;
			}

			if (!IS_WORKER)
			{
				xhr.onload = bindFunction(this._chunkLoaded, this);
				xhr.onerror = bindFunction(this._chunkError, this);
			}

			xhr.open('GET', this._input, !IS_WORKER);
			// Headers can only be set when once the request state is OPENED
			if (this._config.downloadRequestHeaders)
			{
				var headers = this._config.downloadRequestHeaders;

				for (var headerName in headers)
				{
					xhr.setRequestHeader(headerName, headers[headerName]);
				}
			}

			if (this._config.chunkSize)
			{
				var end = this._start + this._config.chunkSize - 1;	// minus one because byte range is inclusive
				xhr.setRequestHeader('Range', 'bytes=' + this._start + '-' + end);
			}

			try {
				xhr.send();
			}
			catch (err) {
				this._chunkError(err.message);
			}

			if (IS_WORKER && xhr.status === 0)
				this._chunkError();
			else
				this._start += this._config.chunkSize;
		};

		this._chunkLoaded = function()
		{
			if (xhr.readyState !== 4)
				return;

			if (xhr.status < 200 || xhr.status >= 400)
			{
				this._chunkError();
				return;
			}

			this._finished = !this._config.chunkSize || this._start > getFileSize(xhr);
			this.parseChunk(xhr.responseText);
		};

		this._chunkError = function(errorMessage)
		{
			var errorText = xhr.statusText || errorMessage;
			this._sendError(new Error(errorText));
		};

		function getFileSize(xhr)
		{
			var contentRange = xhr.getResponseHeader('Content-Range');
			if (contentRange === null) { // no content range, then finish!
				return -1;
			}
			return parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));
		}
	}
	NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);
	NetworkStreamer.prototype.constructor = NetworkStreamer;


	function FileStreamer(config)
	{
		config = config || {};
		if (!config.chunkSize)
			config.chunkSize = Papa.LocalChunkSize;
		ChunkStreamer.call(this, config);

		var reader, slice;

		// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862
		// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76
		var usingAsyncReader = typeof FileReader !== 'undefined';	// Safari doesn't consider it a function - see issue #105

		this.stream = function(file)
		{
			this._input = file;
			slice = file.slice || file.webkitSlice || file.mozSlice;

			if (usingAsyncReader)
			{
				reader = new FileReader();		// Preferred method of reading files, even in workers
				reader.onload = bindFunction(this._chunkLoaded, this);
				reader.onerror = bindFunction(this._chunkError, this);
			}
			else
				reader = new FileReaderSync();	// Hack for running in a web worker in Firefox

			this._nextChunk();	// Starts streaming
		};

		this._nextChunk = function()
		{
			if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))
				this._readChunk();
		};

		this._readChunk = function()
		{
			var input = this._input;
			if (this._config.chunkSize)
			{
				var end = Math.min(this._start + this._config.chunkSize, this._input.size);
				input = slice.call(input, this._start, end);
			}
			var txt = reader.readAsText(input, this._config.encoding);
			if (!usingAsyncReader)
				this._chunkLoaded({ target: { result: txt } });	// mimic the async signature
		};

		this._chunkLoaded = function(event)
		{
			// Very important to increment start each time before handling results
			this._start += this._config.chunkSize;
			this._finished = !this._config.chunkSize || this._start >= this._input.size;
			this.parseChunk(event.target.result);
		};

		this._chunkError = function()
		{
			this._sendError(reader.error);
		};

	}
	FileStreamer.prototype = Object.create(ChunkStreamer.prototype);
	FileStreamer.prototype.constructor = FileStreamer;


	function StringStreamer(config)
	{
		config = config || {};
		ChunkStreamer.call(this, config);

		var remaining;
		this.stream = function(s)
		{
			remaining = s;
			return this._nextChunk();
		};
		this._nextChunk = function()
		{
			if (this._finished) return;
			var size = this._config.chunkSize;
			var chunk = size ? remaining.substr(0, size) : remaining;
			remaining = size ? remaining.substr(size) : '';
			this._finished = !remaining;
			return this.parseChunk(chunk);
		};
	}
	StringStreamer.prototype = Object.create(StringStreamer.prototype);
	StringStreamer.prototype.constructor = StringStreamer;


	function ReadableStreamStreamer(config)
	{
		config = config || {};

		ChunkStreamer.call(this, config);

		var queue = [];
		var parseOnData = true;
		var streamHasEnded = false;

		this.pause = function()
		{
			ChunkStreamer.prototype.pause.apply(this, arguments);
			this._input.pause();
		};

		this.resume = function()
		{
			ChunkStreamer.prototype.resume.apply(this, arguments);
			this._input.resume();
		};

		this.stream = function(stream)
		{
			this._input = stream;

			this._input.on('data', this._streamData);
			this._input.on('end', this._streamEnd);
			this._input.on('error', this._streamError);
		};

		this._checkIsFinished = function()
		{
			if (streamHasEnded && queue.length === 1) {
				this._finished = true;
			}
		};

		this._nextChunk = function()
		{
			this._checkIsFinished();
			if (queue.length)
			{
				this.parseChunk(queue.shift());
			}
			else
			{
				parseOnData = true;
			}
		};

		this._streamData = bindFunction(function(chunk)
		{
			try
			{
				queue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));

				if (parseOnData)
				{
					parseOnData = false;
					this._checkIsFinished();
					this.parseChunk(queue.shift());
				}
			}
			catch (error)
			{
				this._streamError(error);
			}
		}, this);

		this._streamError = bindFunction(function(error)
		{
			this._streamCleanUp();
			this._sendError(error);
		}, this);

		this._streamEnd = bindFunction(function()
		{
			this._streamCleanUp();
			streamHasEnded = true;
			this._streamData('');
		}, this);

		this._streamCleanUp = bindFunction(function()
		{
			this._input.removeListener('data', this._streamData);
			this._input.removeListener('end', this._streamEnd);
			this._input.removeListener('error', this._streamError);
		}, this);
	}
	ReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);
	ReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;


	function DuplexStreamStreamer(_config) {
		var Duplex = require('stream').Duplex;
		var config = copy(_config);
		var parseOnWrite = true;
		var writeStreamHasFinished = false;
		var parseCallbackQueue = [];
		var stream = null;

		this._onCsvData = function(results)
		{
			var data = results.data;
			if (!stream.push(data) && !this._handle.paused()) {
				// the writeable consumer buffer has filled up
				// so we need to pause until more items
				// can be processed
				this._handle.pause();
			}
		};

		this._onCsvComplete = function()
		{
			// node will finish the read stream when
			// null is pushed
			stream.push(null);
		};

		config.step = bindFunction(this._onCsvData, this);
		config.complete = bindFunction(this._onCsvComplete, this);
		ChunkStreamer.call(this, config);

		this._nextChunk = function()
		{
			if (writeStreamHasFinished && parseCallbackQueue.length === 1) {
				this._finished = true;
			}
			if (parseCallbackQueue.length) {
				parseCallbackQueue.shift()();
			} else {
				parseOnWrite = true;
			}
		};

		this._addToParseQueue = function(chunk, callback)
		{
			// add to queue so that we can indicate
			// completion via callback
			// node will automatically pause the incoming stream
			// when too many items have been added without their
			// callback being invoked
			parseCallbackQueue.push(bindFunction(function() {
				this.parseChunk(typeof chunk === 'string' ? chunk : chunk.toString(config.encoding));
				if (isFunction(callback)) {
					return callback();
				}
			}, this));
			if (parseOnWrite) {
				parseOnWrite = false;
				this._nextChunk();
			}
		};

		this._onRead = function()
		{
			if (this._handle.paused()) {
				// the writeable consumer can handle more data
				// so resume the chunk parsing
				this._handle.resume();
			}
		};

		this._onWrite = function(chunk, encoding, callback)
		{
			this._addToParseQueue(chunk, callback);
		};

		this._onWriteComplete = function()
		{
			writeStreamHasFinished = true;
			// have to write empty string
			// so parser knows its done
			this._addToParseQueue('');
		};

		this.getStream = function()
		{
			return stream;
		};
		stream = new Duplex({
			readableObjectMode: true,
			decodeStrings: false,
			read: bindFunction(this._onRead, this),
			write: bindFunction(this._onWrite, this)
		});
		stream.once('finish', bindFunction(this._onWriteComplete, this));
	}
	if (typeof PAPA_BROWSER_CONTEXT === 'undefined') {
		DuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);
		DuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;
	}


	// Use one ParserHandle per entire CSV file or string
	function ParserHandle(_config)
	{
		// One goal is to minimize the use of regular expressions...
		var MAX_FLOAT = Math.pow(2, 53);
		var MIN_FLOAT = -MAX_FLOAT;
		var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
		var ISO_DATE = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
		var self = this;
		var _stepCounter = 0;	// Number of times step was called (number of rows parsed)
		var _rowCounter = 0;	// Number of rows that have been parsed so far
		var _input;				// The input being parsed
		var _parser;			// The core parser being used
		var _paused = false;	// Whether we are paused or not
		var _aborted = false;	// Whether the parser has aborted or not
		var _delimiterError;	// Temporary state between delimiter detection and processing results
		var _fields = [];		// Fields are from the header row of the input, if there is one
		var _results = {		// The last results returned from the parser
			data: [],
			errors: [],
			meta: {}
		};

		if (isFunction(_config.step))
		{
			var userStep = _config.step;
			_config.step = function(results)
			{
				_results = results;

				if (needsHeaderRow())
					processResults();
				else	// only call user's step function after header row
				{
					processResults();

					// It's possbile that this line was empty and there's no row here after all
					if (_results.data.length === 0)
						return;

					_stepCounter += results.data.length;
					if (_config.preview && _stepCounter > _config.preview)
						_parser.abort();
					else
						userStep(_results, self);
				}
			};
		}

		/**
		 * Parses input. Most users won't need, and shouldn't mess with, the baseIndex
		 * and ignoreLastRow parameters. They are used by streamers (wrapper functions)
		 * when an input comes in multiple chunks, like from a file.
		 */
		this.parse = function(input, baseIndex, ignoreLastRow)
		{
			var quoteChar = _config.quoteChar || '"';
			if (!_config.newline)
				_config.newline = guessLineEndings(input, quoteChar);

			_delimiterError = false;
			if (!_config.delimiter)
			{
				var delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines, _config.comments, _config.delimitersToGuess);
				if (delimGuess.successful)
					_config.delimiter = delimGuess.bestDelimiter;
				else
				{
					_delimiterError = true;	// add error after parsing (otherwise it would be overwritten)
					_config.delimiter = Papa.DefaultDelimiter;
				}
				_results.meta.delimiter = _config.delimiter;
			}
			else if(isFunction(_config.delimiter))
			{
				_config.delimiter = _config.delimiter(input);
				_results.meta.delimiter = _config.delimiter;
			}

			var parserConfig = copy(_config);
			if (_config.preview && _config.header)
				parserConfig.preview++;	// to compensate for header row

			_input = input;
			_parser = new Parser(parserConfig);
			_results = _parser.parse(_input, baseIndex, ignoreLastRow);
			processResults();
			return _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });
		};

		this.paused = function()
		{
			return _paused;
		};

		this.pause = function()
		{
			_paused = true;
			_parser.abort();
			_input = _input.substr(_parser.getCharIndex());
		};

		this.resume = function()
		{
			if(self.streamer._halted) {
				_paused = false;
				self.streamer.parseChunk(_input, true);
			} else {
				// Bugfix: #636 In case the processing hasn't halted yet
				// wait for it to halt in order to resume
				setTimeout(this.resume, 3);
			}
		};

		this.aborted = function()
		{
			return _aborted;
		};

		this.abort = function()
		{
			_aborted = true;
			_parser.abort();
			_results.meta.aborted = true;
			if (isFunction(_config.complete))
				_config.complete(_results);
			_input = '';
		};

		function testEmptyLine(s) {
			return _config.skipEmptyLines === 'greedy' ? s.join('').trim() === '' : s.length === 1 && s[0].length === 0;
		}

		function testFloat(s) {
			if (FLOAT.test(s)) {
				var floatValue = parseFloat(s);
				if (floatValue > MIN_FLOAT && floatValue < MAX_FLOAT) {
					return true;
				}
			}
			return false;
		}

		function processResults()
		{
			if (_results && _delimiterError)
			{
				addError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \'' + Papa.DefaultDelimiter + '\'');
				_delimiterError = false;
			}

			if (_config.skipEmptyLines)
			{
				for (var i = 0; i < _results.data.length; i++)
					if (testEmptyLine(_results.data[i]))
						_results.data.splice(i--, 1);
			}

			if (needsHeaderRow())
				fillHeaderFields();

			return applyHeaderAndDynamicTypingAndTransformation();
		}

		function needsHeaderRow()
		{
			return _config.header && _fields.length === 0;
		}

		function fillHeaderFields()
		{
			if (!_results)
				return;

			function addHeder(header)
			{
				if (isFunction(_config.transformHeader))
					header = _config.transformHeader(header);

				_fields.push(header);
			}

			if (Array.isArray(_results.data[0]))
			{
				for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
					_results.data[i].forEach(addHeder);

				_results.data.splice(0, 1);
			}
			// if _results.data[0] is not an array, we are in a step where _results.data is the row.
			else
				_results.data.forEach(addHeder);
		}

		function shouldApplyDynamicTyping(field) {
			// Cache function values to avoid calling it for each row
			if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {
				_config.dynamicTyping[field] = _config.dynamicTypingFunction(field);
			}
			return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;
		}

		function parseDynamic(field, value)
		{
			if (shouldApplyDynamicTyping(field))
			{
				if (value === 'true' || value === 'TRUE')
					return true;
				else if (value === 'false' || value === 'FALSE')
					return false;
				else if (testFloat(value))
					return parseFloat(value);
				else if (ISO_DATE.test(value))
					return new Date(value);
				else
					return (value === '' ? null : value);
			}
			return value;
		}

		function applyHeaderAndDynamicTypingAndTransformation()
		{
			if (!_results || (!_config.header && !_config.dynamicTyping && !_config.transform))
				return _results;

			function processRow(rowSource, i)
			{
				var row = _config.header ? {} : [];

				var j;
				for (j = 0; j < rowSource.length; j++)
				{
					var field = j;
					var value = rowSource[j];

					if (_config.header)
						field = j >= _fields.length ? '__parsed_extra' : _fields[j];

					if (_config.transform)
						value = _config.transform(value,field);

					value = parseDynamic(field, value);

					if (field === '__parsed_extra')
					{
						row[field] = row[field] || [];
						row[field].push(value);
					}
					else
						row[field] = value;
				}


				if (_config.header)
				{
					if (j > _fields.length)
						addError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);
					else if (j < _fields.length)
						addError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);
				}

				return row;
			}

			var incrementBy = 1;
			if (!_results.data[0] || Array.isArray(_results.data[0]))
			{
				_results.data = _results.data.map(processRow);
				incrementBy = _results.data.length;
			}
			else
				_results.data = processRow(_results.data, 0);


			if (_config.header && _results.meta)
				_results.meta.fields = _fields;

			_rowCounter += incrementBy;
			return _results;
		}

		function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {
			var bestDelim, bestDelta, fieldCountPrevRow, maxFieldCount;

			delimitersToGuess = delimitersToGuess || [',', '\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];

			for (var i = 0; i < delimitersToGuess.length; i++) {
				var delim = delimitersToGuess[i];
				var delta = 0, avgFieldCount = 0, emptyLinesCount = 0;
				fieldCountPrevRow = undefined;

				var preview = new Parser({
					comments: comments,
					delimiter: delim,
					newline: newline,
					preview: 10
				}).parse(input);

				for (var j = 0; j < preview.data.length; j++) {
					if (skipEmptyLines && testEmptyLine(preview.data[j])) {
						emptyLinesCount++;
						continue;
					}
					var fieldCount = preview.data[j].length;
					avgFieldCount += fieldCount;

					if (typeof fieldCountPrevRow === 'undefined') {
						fieldCountPrevRow = fieldCount;
						continue;
					}
					else if (fieldCount > 0) {
						delta += Math.abs(fieldCount - fieldCountPrevRow);
						fieldCountPrevRow = fieldCount;
					}
				}

				if (preview.data.length > 0)
					avgFieldCount /= (preview.data.length - emptyLinesCount);

				if ((typeof bestDelta === 'undefined' || delta <= bestDelta)
					&& (typeof maxFieldCount === 'undefined' || avgFieldCount > maxFieldCount) && avgFieldCount > 1.99) {
					bestDelta = delta;
					bestDelim = delim;
					maxFieldCount = avgFieldCount;
				}
			}

			_config.delimiter = bestDelim;

			return {
				successful: !!bestDelim,
				bestDelimiter: bestDelim
			};
		}

		function guessLineEndings(input, quoteChar)
		{
			input = input.substr(0, 1024 * 1024);	// max length 1 MB
			// Replace all the text inside quotes
			var re = new RegExp(escapeRegExp(quoteChar) + '([^]*?)' + escapeRegExp(quoteChar), 'gm');
			input = input.replace(re, '');

			var r = input.split('\r');

			var n = input.split('\n');

			var nAppearsFirst = (n.length > 1 && n[0].length < r[0].length);

			if (r.length === 1 || nAppearsFirst)
				return '\n';

			var numWithN = 0;
			for (var i = 0; i < r.length; i++)
			{
				if (r[i][0] === '\n')
					numWithN++;
			}

			return numWithN >= r.length / 2 ? '\r\n' : '\r';
		}

		function addError(type, code, msg, row)
		{
			_results.errors.push({
				type: type,
				code: code,
				message: msg,
				row: row
			});
		}
	}

	/** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */
	function escapeRegExp(string)
	{
		return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
	}

	/** The core parser implements speedy and correct CSV parsing */
	function Parser(config)
	{
		// Unpack the config object
		config = config || {};
		var delim = config.delimiter;
		var newline = config.newline;
		var comments = config.comments;
		var step = config.step;
		var preview = config.preview;
		var fastMode = config.fastMode;
		var quoteChar;
		/** Allows for no quoteChar by setting quoteChar to undefined in config */
		if (config.quoteChar === undefined) {
			quoteChar = '"';
		} else {
			quoteChar = config.quoteChar;
		}
		var escapeChar = quoteChar;
		if (config.escapeChar !== undefined) {
			escapeChar = config.escapeChar;
		}

		// Delimiter must be valid
		if (typeof delim !== 'string'
			|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)
			delim = ',';

		// Comment character must be valid
		if (comments === delim)
			throw new Error('Comment character same as delimiter');
		else if (comments === true)
			comments = '#';
		else if (typeof comments !== 'string'
			|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)
			comments = false;

		// Newline must be valid: \r, \n, or \r\n
		if (newline !== '\n' && newline !== '\r' && newline !== '\r\n')
			newline = '\n';

		// We're gonna need these at the Parser scope
		var cursor = 0;
		var aborted = false;

		this.parse = function(input, baseIndex, ignoreLastRow)
		{
			// For some reason, in Chrome, this speeds things up (!?)
			if (typeof input !== 'string')
				throw new Error('Input must be a string');

			// We don't need to compute some of these every time parse() is called,
			// but having them in a more local scope seems to perform better
			var inputLen = input.length,
				delimLen = delim.length,
				newlineLen = newline.length,
				commentsLen = comments.length;
			var stepIsFunction = isFunction(step);

			// Establish starting state
			cursor = 0;
			var data = [], errors = [], row = [], lastCursor = 0;

			if (!input)
				return returnable();

			if (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1))
			{
				var rows = input.split(newline);
				for (var i = 0; i < rows.length; i++)
				{
					row = rows[i];
					cursor += row.length;
					if (i !== rows.length - 1)
						cursor += newline.length;
					else if (ignoreLastRow)
						return returnable();
					if (comments && row.substr(0, commentsLen) === comments)
						continue;
					if (stepIsFunction)
					{
						data = [];
						pushRow(row.split(delim));
						doStep();
						if (aborted)
							return returnable();
					}
					else
						pushRow(row.split(delim));
					if (preview && i >= preview)
					{
						data = data.slice(0, preview);
						return returnable(true);
					}
				}
				return returnable();
			}

			var nextDelim = input.indexOf(delim, cursor);
			var nextNewline = input.indexOf(newline, cursor);
			var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), 'g');
			var quoteSearch = input.indexOf(quoteChar, cursor);

			// Parser loop
			for (;;)
			{
				// Field has opening quote
				if (input[cursor] === quoteChar)
				{
					// Start our search for the closing quote where the cursor is
					quoteSearch = cursor;

					// Skip the opening quote
					cursor++;

					for (;;)
					{
						// Find closing quote
						quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);

						//No other quotes are found - no other delimiters
						if (quoteSearch === -1)
						{
							if (!ignoreLastRow) {
								// No closing quote... what a pity
								errors.push({
									type: 'Quotes',
									code: 'MissingQuotes',
									message: 'Quoted field unterminated',
									row: data.length,	// row has yet to be inserted
									index: cursor
								});
							}
							return finish();
						}

						// Closing quote at EOF
						if (quoteSearch === inputLen - 1)
						{
							var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);
							return finish(value);
						}

						// If this quote is escaped, it's part of the data; skip it
						// If the quote character is the escape character, then check if the next character is the escape character
						if (quoteChar === escapeChar &&  input[quoteSearch + 1] === escapeChar)
						{
							quoteSearch++;
							continue;
						}

						// If the quote character is not the escape character, then check if the previous character was the escape character
						if (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar)
						{
							continue;
						}

						// Check up to nextDelim or nextNewline, whichever is closest
						var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);
						var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);

						// Closing quote followed by delimiter or 'unnecessary spaces + delimiter'
						if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim)
						{
							row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
							cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;

							// If char after following delimiter is not quoteChar, we find next quote char position
							if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen] !== quoteChar)
							{
								quoteSearch = input.indexOf(quoteChar, cursor);
							}
							nextDelim = input.indexOf(delim, cursor);
							nextNewline = input.indexOf(newline, cursor);
							break;
						}

						var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);

						// Closing quote followed by newline or 'unnecessary spaces + newLine'
						if (input.substr(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, newlineLen) === newline)
						{
							row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
							saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);
							nextDelim = input.indexOf(delim, cursor);	// because we may have skipped the nextDelim in the quoted field
							quoteSearch = input.indexOf(quoteChar, cursor);	// we search for first quote in next line

							if (stepIsFunction)
							{
								doStep();
								if (aborted)
									return returnable();
							}

							if (preview && data.length >= preview)
								return returnable(true);

							break;
						}


						// Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string
						errors.push({
							type: 'Quotes',
							code: 'InvalidQuotes',
							message: 'Trailing quote on quoted field is malformed',
							row: data.length,	// row has yet to be inserted
							index: cursor
						});

						quoteSearch++;
						continue;

					}

					continue;
				}

				// Comment found at start of new line
				if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments)
				{
					if (nextNewline === -1)	// Comment ends at EOF
						return returnable();
					cursor = nextNewline + newlineLen;
					nextNewline = input.indexOf(newline, cursor);
					nextDelim = input.indexOf(delim, cursor);
					continue;
				}

				// Next delimiter comes before next newline, so we've reached end of field
				if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))
				{
					// we check, if we have quotes, because delimiter char may be part of field enclosed in quotes
					if (quoteSearch !== -1) {
						// we have quotes, so we try to find the next delimiter not enclosed in quotes and also next starting quote char
						var nextDelimObj = getNextUnqotedDelimiter(nextDelim, quoteSearch, nextNewline);

						// if we have next delimiter char which is not enclosed in quotes
						if (nextDelimObj && typeof nextDelimObj.nextDelim !== 'undefined') {
							nextDelim = nextDelimObj.nextDelim;
							quoteSearch = nextDelimObj.quoteSearch;
							row.push(input.substring(cursor, nextDelim));
							cursor = nextDelim + delimLen;
							// we look for next delimiter char
							nextDelim = input.indexOf(delim, cursor);
							continue;
						}
					} else {
						row.push(input.substring(cursor, nextDelim));
						cursor = nextDelim + delimLen;
						nextDelim = input.indexOf(delim, cursor);
						continue;
					}
				}

				// End of row
				if (nextNewline !== -1)
				{
					row.push(input.substring(cursor, nextNewline));
					saveRow(nextNewline + newlineLen);

					if (stepIsFunction)
					{
						doStep();
						if (aborted)
							return returnable();
					}

					if (preview && data.length >= preview)
						return returnable(true);

					continue;
				}

				break;
			}


			return finish();


			function pushRow(row)
			{
				data.push(row);
				lastCursor = cursor;
			}

			/**
             * checks if there are extra spaces after closing quote and given index without any text
             * if Yes, returns the number of spaces
             */
			function extraSpaces(index) {
				var spaceLength = 0;
				if (index !== -1) {
					var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);
					if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {
						spaceLength = textBetweenClosingQuoteAndIndex.length;
					}
				}
				return spaceLength;
			}

			/**
			 * Appends the remaining input from cursor to the end into
			 * row, saves the row, calls step, and returns the results.
			 */
			function finish(value)
			{
				if (ignoreLastRow)
					return returnable();
				if (typeof value === 'undefined')
					value = input.substr(cursor);
				row.push(value);
				cursor = inputLen;	// important in case parsing is paused
				pushRow(row);
				if (stepIsFunction)
					doStep();
				return returnable();
			}

			/**
			 * Appends the current row to the results. It sets the cursor
			 * to newCursor and finds the nextNewline. The caller should
			 * take care to execute user's step function and check for
			 * preview and end parsing if necessary.
			 */
			function saveRow(newCursor)
			{
				cursor = newCursor;
				pushRow(row);
				row = [];
				nextNewline = input.indexOf(newline, cursor);
			}

			/** Returns an object with the results, errors, and meta. */
			function returnable(stopped, step)
			{
				var isStep = step || false;
				return {
					data: isStep ? data[0]  : data,
					errors: errors,
					meta: {
						delimiter: delim,
						linebreak: newline,
						aborted: aborted,
						truncated: !!stopped,
						cursor: lastCursor + (baseIndex || 0)
					}
				};
			}

			/** Executes the user's step function and resets data & errors. */
			function doStep()
			{
				step(returnable(undefined, true));
				data = [];
				errors = [];
			}

			/** Gets the delimiter character, which is not inside the quoted field */
			function getNextUnqotedDelimiter(nextDelim, quoteSearch, newLine) {
				var result = {
					nextDelim: undefined,
					quoteSearch: undefined
				};
				// get the next closing quote character
				var nextQuoteSearch = input.indexOf(quoteChar, quoteSearch + 1);

				// if next delimiter is part of a field enclosed in quotes
				if (nextDelim > quoteSearch && nextDelim < nextQuoteSearch && (nextQuoteSearch < newLine || newLine === -1)) {
					// get the next delimiter character after this one
					var nextNextDelim = input.indexOf(delim, nextQuoteSearch);

					// if there is no next delimiter, return default result
					if (nextNextDelim === -1) {
						return result;
					}
					// find the next opening quote char position
					if (nextNextDelim > nextQuoteSearch) {
						nextQuoteSearch = input.indexOf(quoteChar, nextQuoteSearch + 1);
					}
					// try to get the next delimiter position
					result = getNextUnqotedDelimiter(nextNextDelim, nextQuoteSearch, newLine);
				} else {
					result = {
						nextDelim: nextDelim,
						quoteSearch: quoteSearch
					};
				}

				return result;
			}
		};

		/** Sets the abort flag */
		this.abort = function()
		{
			aborted = true;
		};

		/** Gets the cursor position */
		this.getCharIndex = function()
		{
			return cursor;
		};
	}


	function newWorker()
	{
		if (!Papa.WORKERS_SUPPORTED)
			return false;

		var workerUrl = getWorkerBlob();
		var w = new global.Worker(workerUrl);
		w.onmessage = mainThreadReceivedMessage;
		w.id = workerIdCounter++;
		workers[w.id] = w;
		return w;
	}

	/** Callback when main thread receives a message */
	function mainThreadReceivedMessage(e)
	{
		var msg = e.data;
		var worker = workers[msg.workerId];
		var aborted = false;

		if (msg.error)
			worker.userError(msg.error, msg.file);
		else if (msg.results && msg.results.data)
		{
			var abort = function() {
				aborted = true;
				completeWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });
			};

			var handle = {
				abort: abort,
				pause: notImplemented,
				resume: notImplemented
			};

			if (isFunction(worker.userStep))
			{
				for (var i = 0; i < msg.results.data.length; i++)
				{
					worker.userStep({
						data: msg.results.data[i],
						errors: msg.results.errors,
						meta: msg.results.meta
					}, handle);
					if (aborted)
						break;
				}
				delete msg.results;	// free memory ASAP
			}
			else if (isFunction(worker.userChunk))
			{
				worker.userChunk(msg.results, handle, msg.file);
				delete msg.results;
			}
		}

		if (msg.finished && !aborted)
			completeWorker(msg.workerId, msg.results);
	}

	function completeWorker(workerId, results) {
		var worker = workers[workerId];
		if (isFunction(worker.userComplete))
			worker.userComplete(results);
		worker.terminate();
		delete workers[workerId];
	}

	function notImplemented() {
		throw new Error('Not implemented.');
	}

	/** Callback when worker thread receives a message */
	function workerThreadReceivedMessage(e)
	{
		var msg = e.data;

		if (typeof Papa.WORKER_ID === 'undefined' && msg)
			Papa.WORKER_ID = msg.workerId;

		if (typeof msg.input === 'string')
		{
			global.postMessage({
				workerId: Papa.WORKER_ID,
				results: Papa.parse(msg.input, msg.config),
				finished: true
			});
		}
		else if ((global.File && msg.input instanceof File) || msg.input instanceof Object)	// thank you, Safari (see issue #106)
		{
			var results = Papa.parse(msg.input, msg.config);
			if (results)
				global.postMessage({
					workerId: Papa.WORKER_ID,
					results: results,
					finished: true
				});
		}
	}

	/** Makes a deep copy of an array or object (mostly) */
	function copy(obj)
	{
		if (typeof obj !== 'object' || obj === null)
			return obj;
		var cpy = Array.isArray(obj) ? [] : {};
		for (var key in obj)
			cpy[key] = copy(obj[key]);
		return cpy;
	}

	function bindFunction(f, self)
	{
		return function() { f.apply(self, arguments); };
	}

	function isFunction(func)
	{
		return typeof func === 'function';
	}

	return Papa;
}));
</script>
<script>
"use strict";

class TestModal {
    #controller;    // - ControllerInterface instance
    #modal;         // - A single Modal instance
    #observables;   // - An array of ObservableInterface instances

    /**
     * @param {Array} observables - an array of ObservableInterface instances
     * @param {FeatureController} controller - a ControllerInterface instance
     * @returns {undefined}
     */
    constructor(observables, controller) {
        if (!(observables instanceof Array)) {
            throw TypeError('"observables" argumnet must be an Array.');
        }
        if (!(controller instanceof FeatureController)) {
            throw Error('"controller" argument must be instanceof FeatureController');
        }
        this.#controller = controller;
        this.#modal = null;
        this.#observables = observables;
        this.renderContent();
    }

    /**
     * - A render a static, read-only table for arbitrary GeoJSON objects. Does not support editing data in any way. See featureEditModal.js for
     *   examples of how to edit data in a table
     */
    renderContent() {
        const modal = new Modal();
        modal.addStyleClasses(['featureEditModal'], 'divElement');
        let count = 0;
        for (const [key, val] of Object.entries(this.#observables[0].getProperties('meta'))) {
            const keySpan = document.createElement('span');
            keySpan.textContent = key;
            keySpan.dataset.propertyKey = key;
            keySpan.dataset.propertyNamespace = 'meta';
            const valueSpan = document.createElement('span');

            // check for fema secific columns    
        
            if(keySpan.textContent === 'TRACT'){
                keySpan.textContent = 'Census Tract';
                keySpan.dataset.propertyKey = 'tract';
                keySpan.dataset.propertyNamespace = 'treeProps';

                modal.insertTHeadRow([null, 'Census Tract', val.toString()], 'prepend');
                continue;
            }
            if (keySpan.textContent === 'SOVI_SCORE') {
                keySpan.textContent = 'Social Vulnerability Score'
            }
            if (keySpan.textContent === 'SOVI_RATNG') {
                keySpan.textContent = 'Social Vulnerability Rating'
            }
            valueSpan.textContent = val;
            modal.insertTBodyRow([null, keySpan, valueSpan]);
        }
        modal.addStyleClasses(['centeredTable', 'plainTable'], 'tableElement');
        


        // - Add buttons for regular features
            if (!this.#observables.some(ob => ob.isConfigurationObject())) {
                modal.insertElement(this.#getZoomDiv(), 'prepend'); 
            }



        modal.addStyleClasses(['verticalFlex', 'centerMainAxisFlex', 'centerCrossAxisFlex'], 'containerElement');
        if (this.#modal === null){
            this.#modal = modal;
        }
        if (document.body.contains(this.#modal.divElement)) {
            this.#modal.divElement.replaceWith(modal.divElement);
            this.#modal = modal;
        }
        // - Example of how to get to underlying data
        
    }


    // ****************************
    // ** ModalInterface methods **
    // ****************************

    getDOMElement() {
        return this.#modal.divElement;
    }


    /**
     * - Validate the just-inputed value for a value text input
     * @param {string} propertyKey
     * @param {string} inputValue
     * @returns {boolean} whether the propertyKey and value are valid from a domain perspective
     */
    #valueTextInputIsValid(propertyKey, inputValue) {
        if (typeof propertyKey !== 'string') {
            throw TypeError('"propertyKey" argument must be typeof string.');
        }
        if (typeof inputValue !== 'string') {
            throw TypeError('"inputValue" argument must be typeof string.');
        }
        // - I am no longer always converting to lowercase because names are case-sensitive and therefore other properties should be too
        switch (propertyKey) {
            case 'type':
                inputValue = inputValue.toLowerCase();
                if (inputValue === 'parentchild') {
                    alert('The "type" property may not have a value of "parentChild".');
                    return false;
                }
                return true;
            case 'treeKey':
                alert('The "treeKey" property cannot be changed.');
                return false;
            case 'name':
                if (this.#observables.length > 1) {
                    alert('The "name" property cannot be edited for multiple objects simultaneously.');
                    return false;
                } else {
                    if (inputValue.trim() === '') {
                        alert('The "name" property cannot be blank.');
                        return false;
                    }
                    if (this.#controller.observableGraph.getObservables(ob => ob.hasProperty('name') && ob.getProperty('name') === inputValue).length > 0) {
                        alert(`The "name" property must be unique for all objects. The name "${inputValue}" is already used by another object.`);
                        return false;
                    }
                }
                return true;
            case 'from':
            case 'to':
                // - Test. It works
                //[...this.#modal.divElement.getElementsByTagName('tr')].forEach(tr => {
                //    [...tr.getElementsByTagName('span')].forEach(span => {
                //        if (span.textContent === propertyKey) {
                //            tr.getElementsByTagName('input')[0].classList.add('invalid');
                //        }
                //    });
                //});
                // - Test
                if (!this.#observables.every(ob => ob.isLine())) {
                    alert(`The value of the "${propertyKey}" property cannot be edited for non-line objects. Ensure your search includes only line objects.`);
                    return false;
                }
                if (!this.#toFromParentObjectIsValid(propertyKey, inputValue)) {
                    return false;
                }
                if (propertyKey === 'from' && this.#observables.some(ob => ob.getProperty('to') === inputValue)) {
                    if (this.#observables.length === 1) {
                        alert(`This line already has the value "${inputValue}" for the property "to". Lines may not begin and end on the same object.`);
                    } else {
                        alert(`One or more objects already has the value "${inputValue}" for the property "to". Lines may not begin and end on the same object.`);
                    }
                    return false;
                }
                if (propertyKey === 'to' && this.#observables.some(ob => ob.getProperty('from') === inputValue)) {
                    if (this.#observables.length === 1) {
                        alert(`This line already has the value "${inputValue}" for the property "from". Lines may not begin and end on the same object.`);
                    } else {
                        alert(`One or more objects already has the value "${inputValue}" for the property "from". Lines may not begin and end on the same object.`);
                    }
                    return false;
                }
                return true;
            case 'parent':
                if (!this.#observables.every(ob => ob.isChild())) {
                    alert(`The value of the "${propertyKey}" property cannot be edited for non-child objects. Ensure your search includes only child objects.`);
                    return false;
                }
                return this.#toFromParentObjectIsValid(propertyKey, inputValue);
            case 'latitude':
            case 'longitude':
                if (this.#observables.some(ob => ob.isConfigurationObject())) {
                    if (this.#observables.length === 1) {
                        alert(`This object is a configuration object. The property "${propertyKey}" cannot be set for configuration objects because they aren't shown on the map.`);
                    } else {
                        alert(`One or more objects are configuration objects. The property "${propertyKey}" cannot be set for configuration objects because they aren't shown on the map.`);
                    }
                    return false;
                }
                if (isNaN(+inputValue)) {
                    alert(`The value "${inputValue}" is not a valid number. A value for the "${propertyKey}" property must be a valid number.`);
                    return false;
                }
                return true;
            default:
                return true;
        }
    }
        /**
     * @param {string} propertyKey
     * @param {string} inputValue
     * @returns {boolean}
     */
        #toFromParentObjectIsValid(propertyKey, inputValue) {
            let observableKey;
            try {
                if(this.#observables.some(ob => ob.isComponentFeature())) {
                    // - Components and non-components will never be together in an array of observables
                    observableKey = this.#controller.observableGraph.getKeyForComponent(inputValue);
                } else {
                    observableKey = this.#controller.observableGraph.getKey(inputValue, this.#observables[0].getProperty('treeKey', 'meta'));
                    // - This is commented out because it's fine if different objects in the search selection will return different keys. If there are
                    //   different keys for the same name, the FeatureGraph should just return the correct key for each object. Actually it's not. What if a
                    //   configuration object and a non-configuration object share a name? I could write logic that decides whether returning multiple keys is
                    //   okay (e.g. do both keys point to non-configuration objects?) but that would be annoying. Just return false if there are multiple keys
                    if (this.#observables.some(ob => this.#controller.observableGraph.getKey(inputValue, ob.getProperty('treeKey', 'meta')) !== observableKey)) {
                        alert(`The value of the "${propertyKey}" property cannot be set to "${inputValue}" because multiple objects have that value for their
                            "name" property. Either ensure that value for the "${propertyKey}" property is a unique name, or change the value of the
                            "name" property of other object(s) to ensure the name is unique.`);
                        return false;
                    }
                }
            } catch {
                alert(`No object has the value "${inputValue}" for the "name" property. Ensure that the value for the "${propertyKey}" property matches an existing name.`);
                return false;
            }
            if (observableKey.startsWith('parentChild:')) {
                alert(`The value "${inputValue}" is the name of a parent-child line. Parent-child line names cannot be used as a value for the "${propertyKey}" property.`);
                return false;
            }
            const observable = this.#controller.observableGraph.getObservable(observableKey);
            if (observable.isConfigurationObject()) {
                alert(`The value "${inputValue}" is the name of a configuration object. Configuration object names cannot be used as a value for the "${propertyKey}" property.`);
                return false;
            }
            // - Components are not in the graph, so the observable cannot be a component feature
            return true;
        }

    /**
     * @returns {HTMLDivElement}
     */
    #getZoomDiv(){
        const btn = this.#getWideButton();
        btn.appendChild(getPinSvg());
        const span = document.createElement('span');
        span.textContent = 'Zoom';
        btn.appendChild(span);
        btn.addEventListener('click', zoom.bind(null, this.#observables));
        const div = this.#getWideButtonDiv();
        div.appendChild(btn);
        return div;
    }
        /**
     * @returns {HTMLButtonElement}
     */
        #getWideButton() {
            const btn = document.createElement('button');
            btn.classList.add('horizontalFlex');
            btn.classList.add('centerMainAxisFlex');
            btn.classList.add('centerCrossAxisFlex');
            btn.classList.add('fullWidth');
            return btn;
        }
    
        /**
         * @returns {HTMLDivElement}
         */
        #getWideButtonDiv() {
            const div = document.createElement('div');
            div.classList.add('horizontalFlex');
            div.classList.add('centerMainAxisFlex');
            div.classList.add('centerCrossAxisFlex');
            div.classList.add('halfWidth');
            return div;
        }
}

function getPinSvg() {
    const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.setAttribute('width', '22px');
    svg.setAttribute('height', '22px');
    svg.setAttribute('viewBox', '0 0 24 24');
    svg.setAttribute('fill', 'none');
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', '12');
    circle.setAttribute('cy', '10');
    circle.setAttribute('r', '3');
    circle.setAttribute('stroke', '#FFFFFF');
    circle.setAttribute('stroke-width', '1.5');
    circle.setAttribute('stroke-width', '1.5');
    circle.setAttribute('stroke-linecap', 'round');
    circle.setAttribute('stroke-linejoin', 'round');
    svg.appendChild(circle);
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', "M19 9.75C19 15.375 12 21 12 21C12 21 5 15.375 5 9.75C5 6.02208 8.13401 3 12 3C15.866 3 19 6.02208 19 9.75Z");
    path.setAttribute('stroke', '#FFFFFF');
    path.setAttribute('stroke-width', '1.5');
    path.setAttribute('stroke-width', '1.5');
    path.setAttribute('stroke-linecap', 'round');
    path.setAttribute('stroke-linejoin', 'round');
    svg.appendChild(path);
    return svg;
}
/**
 * - There's no need to create a function that returns a function if I use Function.prototype.bind() propertly
 * @param {Array} observables - an array of ObservableInterface instances
 * @returns {undefined}
 */
function zoom(observables) {
    if (!(observables instanceof Array)) {
        throw TypeError('"observables" argument must be instanceof Array.');
    }
    if (observables.length === 1) {
        const observable = observables[0];
        const layer = Object.values(observable.getObservers().filter(ob => ob instanceof LeafletLayer)[0].getLayer()._layers)[0];
        if (observable.isNode()) {
            const [lon, lat] = structuredClone(observable.getCoordinates());
            // - The max zoom level without losing the map is 19
            LeafletLayer.map.flyTo([lat, lon], 19, {duration: .3});
            if (!layer.isPopupOpen()) {
                layer.openPopup();
            }
        } else if (observable.isLine()) {
            const [[lon1, lat1], [lon2, lat2]] = observable.getCoordinates();
            LeafletLayer.map.flyToBounds([[lat1, lon1], [lat2, lon2]], {duration: .3});
            if (!layer.isPopupOpen()) {
                layer.openPopup();
            }
        } else {
            let coordinates;
            if (observable.isPolygon()) {
                coordinates = observable.getCoordinates().flat(1);
            } else if (observable.isMultiPolygon()) {
                coordinates = observable.getCoordinates().flat(2);
            } else {
                return;
            }
            const lons = [];
            const lats = [];
            coordinates.forEach(ary => { lons.push(ary[0]); lats.push(ary[1]); });
            LeafletLayer.map.flyToBounds([
                [Math.min.apply(null, lats), Math.min.apply(null, lons)],
                [Math.max.apply(null, lats), Math.max.apply(null, lons)]],
                {duration: .3});
            if (!layer.isPopupOpen()) {
                layer.openPopup();
            }
        }
    } else {
        const lons = [];
        const lats = [];
        observables.forEach(ob => {
            if (ob.isNode()) {
                const [lon, lat] = structuredClone(ob.getCoordinates());
                lons.push(lon);
                lats.push(lat);
            } else if (ob.isLine()) {
                const [[lon1, lat1], [lon2, lat2]] = structuredClone(ob.getCoordinates());
                lons.push(...[lon1, lon2]);
                lats.push(...[lat1, lat2]);
            }
        });
        LeafletLayer.map.flyToBounds([
            [Math.min.apply(null, lons), Math.min.apply(null, lats)],
            [Math.max.apply(null, lons), Math.max.apply(null, lats)],
        ]);
    }
}

</script>
<script>
"use strict";

function main() {
    const features = gFeatureCollection.features.map(f => new Feature(f));
    const featureGraph = new FeatureGraph();
    // - Insert nodes
    features.filter(f => !f.isLine()).forEach(f => featureGraph.insertObservable(f));
    // - Insert lines. Lines can be parents, so they must be inserted before parent-child lines
    features.filter(f => f.isLine()).forEach(f => featureGraph.insertObservable(f));
    // - Create and insert parent-child lines
    features.filter(f => f.isChild()).forEach(f => {
        const parentKey = featureGraph.getKey(f.getProperty('parent'), f.getProperty('treeKey', 'meta'));
        const childKey = f.getProperty('treeKey', 'meta');
        const parentChildLineFeature = featureGraph.getParentChildLineFeature(parentKey, childKey);
        featureGraph.insertObservable(parentChildLineFeature);
    });
    const controller = new FeatureController(featureGraph);
    const nav = new Nav();
    setupNav(controller, nav);
    const topTab = new TopTab();
    setupMap(controller, nav);
    createSearchModal(controller, nav, topTab);
    setupControls(controller);
    const modalInsert = document.getElementById('modalInsert');
    modalInsert.addEventListener('click', hideModalInsert);
    createHelpMenu();
    createEditMenu(controller, nav, topTab);
    if (gIsOnline && gShowFileMenu) {
        createFileMenu(controller);
    }
    addMenuEventHandlers();
}

/**
 * @param {FeatureController} controller - a FeatureController instance
 * @param {Nav} nav - a Nav instance
 * @returns {undefined}
 */
function setupNav(controller, nav) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('The "controller" argument must be instanceof FeatureController.');
    }
    if (!(nav instanceof Nav)) {
        throw TypeError('The "nav" argument must be instanceof Nav.');
    }
    const header = document.getElementsByTagName('header')[0];
    if (gIsOnline) {
        nav.topNav.setHomepageName(`"${gThisFeederName}" from ${gThisModelName}`);
    } else {
        nav.topNav.setHomepageName('');
    }
    header.prepend(nav.topNavNavElement);
    const main = document.getElementsByTagName('main')[0];
    main.prepend(nav.sideNavArticleElement);
    main.prepend(nav.sideNavDivElement);
    main.prepend(nav.sideNavNavElement);
}

function setupMap(controller, nav) {
    if (!(controller instanceof FeatureController)) {
        throw Error('The "controller" argument must be instanceof controller.');
    }
    if (!(nav instanceof Nav)) {
        throw TypeError('The "nav" argument must be instanceof Nav.');
    }
    const div = document.createElement('div');
    div.id = 'map';
    nav.sideNavArticleElement.prepend(div);
    const maxZoom = 32;
    var esri_satellite_layer = L.esri.basemapLayer('Imagery', {
        maxZoom: maxZoom
    });
    const mapbox_layer = L.mapboxGL({
        attribution: "",
        // - Odd behavior: maxboxGL will let the user keep zooming in past maxZoom, but the tiles won't change. No other layers do this
        maxZoom: maxZoom,
        style: 'https://api.maptiler.com/maps/basic/style.json?key=WOwRKyy0L6AwPBuM4Ggj'
    });
    const esri_topography_layer = L.esri.basemapLayer('Streets', {
        maxZoom: maxZoom
    });
    const blank_layer = L.tileLayer('', {
        maxZoom: maxZoom
    });
    LeafletLayer.map = L.map('map', {
        // - This zoom level sensibly displays all circuits to start, even the ones with weird one-off players that skew where the center is
        zoom: 14,
        // - Provide the layers that the map should start with
        layers: [esri_satellite_layer, LeafletLayer.parentChildLineLayers, LeafletLayer.lineLayers, LeafletLayer.nodeLayers],
        // - Better performance for large datasets
        renderer: L.canvas(),
        // - Disable box zoom shortcut because we use the shift key for multiselection
        boxZoom: false
    });
    // - Whenever there is a mouseup event on the map, it's possible that a marker was being dragged. To prevent the marker from "sticking" to the
    //   cursor, just turn off the active trackCursor function
    LeafletLayer.map.on('mouseup', (e) => {
        if (LeafletLayer.trackCursor !== null) {
            LeafletLayer.map.off('mousemove', LeafletLayer.trackCursor);
        }
    });
    // - Prevent all leaflet popup "x" buttons from triggering a "mouseup" event on the map
    LeafletLayer.map.on('popupopen', (e) => {
        for (const btn of [...document.getElementsByClassName('leaflet-popup-close-button')]) {
            btn.addEventListener('mouseup', (e) => {
                e.stopPropagation();
            });
        }
    });
    // - This stops mouseup events from propagating from this pane to the map because otherwise clicking on a popup modal will highlight objects if
    //   multiselection is enabled
    L.DomEvent.on(LeafletLayer.map.getPane('popupPane'), 'mouseup', (e) => {
        e.stopPropagation();
    });
    const baseMaps = {
        'Satellite': esri_satellite_layer,
        'Streets': mapbox_layer,
        'Topo': esri_topography_layer,
        'Blank': blank_layer
    };
    // - overlayMaps is still needed for GeoJSON layers
    const overlayMaps = {}
    LeafletLayer.control = L.control.layers(baseMaps, overlayMaps, {
        position: 'topleft',
        collapsed: false,
    });
    LeafletLayer.control.addTo(LeafletLayer.map);
    // - I have to add the cluster control before LeafletLayer instances are created. I have no choice
    const clusterControl = new ClusterControlClass(controller);
    LeafletLayer.map.addControl(clusterControl);
    LeafletLayer.clusterControl = clusterControl;
    // - Create layers for all visible objects
    controller.observableGraph.getObservables().forEach(ob => {
        if (!ob.isConfigurationObject()) {
            // - Here, the first observer is added to every visible feature
            LeafletLayer.createAndGroupLayer(ob, controller);
        }
    });
    LeafletLayer.map.fitBounds(LeafletLayer.nodeLayers.getBounds());
    // - Disable the following annoying default Leaflet keyboard shortcuts:
    //  - TODO: do a better job and stop the event(s) from propagating in text inputs instead
    document.getElementById('map').onkeydown = function(e) {
        if ([
            '-',    // disable zoom-out for "-" key
            '_',    // disable mega zoom-out for "_" key
            '=',    // disable zoom-in for "=" key
            '+',    // disable mega zoom-in for "+" key
        ].includes(e.key)) {
            e.stopPropagation();
        }
    };
}

/**
 * @param {FeatureController} controller - a FeatureController instance
 * @param {Nav} nav - a Nav instance
 * @param {TopTab} topTab - a TopTap instance
 * @returns {undefined}
 */
function createSearchModal(controller, nav, topTab) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('The "controller" argument must be instanceof FeatureController.');
    }
    if (!(nav instanceof Nav)) {
        throw TypeError('The "nav" argument must be instanceof Nav.');
    }
    if (!(topTab instanceof TopTab)) {
        throw TypeError('The "topTab" argument must be instanceof TopTab.');
    }
    nav.sideNavNavElement.appendChild(topTab.divElement); 
    // - Add tab for searching existing features
    const searchTab = document.createElement('div');
    topTab.addTab('Search Objects', searchTab);
    topTab.selectTab(topTab.getTab('Search Objects').tab);
    let searchModal = new SearchModal(controller);
    // - add static reference
    SearchModal.searchModal = searchModal;
    searchTab.appendChild(searchModal.getDOMElement());
    let searchResultsDiv = document.createElement('div');
    searchTab.appendChild(searchResultsDiv);
    searchResultsDiv.appendChild(searchModal.getConfigSearchResultsDiv());
    searchResultsDiv.appendChild(searchModal.getNodeSearchResultsDiv());
    searchResultsDiv.appendChild(searchModal.getLineSearchResultsDiv());
    // - Add tab for adding components
    const componentTab = document.createElement('div');
    topTab.addTab('Add New Objects', componentTab);
    let components = gComponentsCollection.features.filter(f => f.properties.componentType === 'gridlabd');
    const omdFeature = controller.observableGraph.getObservable('omd');
    if (omdFeature.hasProperty('syntax', 'meta')) {
        if (omdFeature.getProperty('syntax', 'meta') === 'DSS') {
            components = gComponentsCollection.features.filter(f => f.properties.componentType === 'opendss');
        }
    }
    components = components.map(f => {
        const feature = new Feature(f);
        if (feature.hasProperty('name') && feature.getProperty('name').toString().toLowerCase() === 'null') {
            feature.setProperty('name', 'new');
        }
        return feature;
    });
    searchModal = new SearchModal(controller, components);
    // - Add static reference
    SearchModal.componentModal = searchModal;
    componentTab.appendChild(searchModal.getDOMElement());
    searchResultsDiv = document.createElement('div');
    componentTab.appendChild(searchResultsDiv);
    searchResultsDiv.appendChild(searchModal.getConfigSearchResultsDiv()); 
    searchResultsDiv.appendChild(searchModal.getNodeSearchResultsDiv()); 
    searchResultsDiv.appendChild(searchModal.getLineSearchResultsDiv()); 
    // - Add legend insert
    const legendInsert = document.createElement('div');
    legendInsert.id = 'legendInsert';
    document.getElementsByTagName('main')[0].appendChild(legendInsert);
    // - Add multiselect insert
    const multiselectInsert = document.createElement('div');
    multiselectInsert.id = 'multiselectInsert';
    document.getElementsByTagName('main')[0].appendChild(multiselectInsert);
}

/**
 * - Set up the controls in the top left hand corner of the screen
 */
function setupControls(controller) {
    if (!(controller instanceof FeatureController)) {
        throw Error('The "controller" argument must be instanceof controller.');
    }
    addCustomRadioControl(controller);
    addZoomControl(controller);
    addMultiselectControl(controller);
    addRuler();
    addGeocoding();
    // - Prevent mouse events from propagating from controls to the map
    for (const div of [...document.getElementsByClassName('leaflet-control')]) {
        L.DomEvent.on(div, 'mousedown', function (e) {
            L.DomEvent.stopPropagation(e);
        });
        L.DomEvent.on(div, 'mouseup', function (e) {
            L.DomEvent.stopPropagation(e);
        });
        L.DomEvent.on(div, 'click', function (e) {
            L.DomEvent.stopPropagation(e);
        });
    }
}

function addCustomRadioControl(controller) {
    if (!(controller instanceof FeatureController)) {
        throw Error('The "controller" argument must be instanceof controller.');
    }
    // - Create div for separator line
    let div = document.createElement('div');
    div.classList.add('leaflet-control-layers-separator');
    document.querySelector('section.leaflet-control-layers-list').append(div);
    // - Create div for custom radio buttons
    div = document.createElement('div');
    document.querySelector('section.leaflet-control-layers-list').append(div);
    // - Create circuit radio button
    let label = document.createElement('label');
    div.append(label);
    let outerSpan = document.createElement('span');
    label.append(outerSpan);
    let radio = document.createElement('input');
    radio.type = 'radio';
    radio.name = 'circuitDisplay'
    radio.checked = true;
    radio.value = 'displayCircuit';
    radio.addEventListener('change', function() {
        LeafletLayer.resetLayerGroups(controller);
    });
    outerSpan.append(radio);
    let innerSpan = document.createElement('span');
    innerSpan.textContent = 'Display full circuit';
    outerSpan.append(innerSpan);
    // - Create search results radio button
    label = document.createElement('label');
    div.append(label);
    outerSpan = document.createElement('span');
    label.append(outerSpan);
    radio = document.createElement('input');
    radio.type = 'radio';
    radio.name = 'circuitDisplay';
    radio.value = 'displaySearch';
    radio.addEventListener('change', function() {
        SearchModal.searchModal.filterLayerGroups();
    });
    outerSpan.append(radio);
    innerSpan = document.createElement('span');
    innerSpan.textContent = 'Display search results'
    outerSpan.append(innerSpan);
}

function addZoomControl(controller) {
    if (!(controller instanceof FeatureController)) {
        throw Error('The "controller" argument must be instanceof controller.');
    }
    const zoomControl = new ZoomControlClass(controller);
    LeafletLayer.map.addControl(zoomControl);
}

function addMultiselectControl(controller) {
    if (!(controller instanceof FeatureController)) {
        throw Error('The "controller" argument must be instanceof controller.');
    }
    const multiselectControl = new MultiselectControlClass(controller);
    LeafletLayer.map.addControl(multiselectControl);
}

function addRuler() {
    var options = {
        position: 'topleft',
        lengthUnit: {
            display: 'm',
            decimal: 3,
            factor: 1000,
            label: 'Distance (m):'
          },
          angleUnit: {
            display: '&deg;',
            decimal: 3,
            factor: null,
            label: 'Angle:'
          }
      };
    L.control.ruler(options).addTo(LeafletLayer.map);
}

function addGeocoding() {
    const provider = new GeoSearch.OpenStreetMapProvider();
    const search = new GeoSearch.GeoSearchControl({
        provider: provider,
        position: 'topleft',
        updateMap: false // - don't update the map because we don't like the default zoom level
    });
    // - Custom zoom behavior
    LeafletLayer.map.on('geosearch/showlocation', function(e) {
        // - The max zoom level without losing the map is 19
        LeafletLayer.map.flyTo([e.location.y, e.location.x], 19, {duration: .3});
    });
    LeafletLayer.map.addControl(search);
}

function createHelpMenu() {
    const div = document.createElement('div');
    div.style.fontSize = '13px';
    div.style.height = '39px';
    div.style.width = '55px';
    div.style.color = 'white';
    const innerDiv = document.createElement('div');
    div.appendChild(innerDiv);
    innerDiv.style.display = 'flex';
    innerDiv.style.alignItems = 'center';
    innerDiv.style.height = '100%';
    const anchor = document.createElement('a');
    anchor.style.color = 'white'
    anchor.href = 'https://github.com/dpinney/omf/wiki/Tools-~-gridEdit';
    anchor.textContent = 'Help';
    anchor.target = '_blank';
    innerDiv.appendChild(anchor);
    document.getElementById('menuInsert').appendChild(div);
}

/**
 * @param {FeatureController} controller - a FeatureController instance
 * @param {Nav} nav - a Nav instance
 * @param {TopTab} topTab - a TopTab instance
 * @returns {undefined}
 */
function createEditMenu(controller, nav, topTab) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    if (!(nav instanceof Nav)) {
        throw TypeError('"nav" argument must be instanceof Nav.');
    }
    if (!(topTab instanceof TopTab)) {
        throw TypeError('"topTab" argument must be instanceof TopTab.');
    }
    const dropdownDiv = new DropdownDiv();
    dropdownDiv.divElement.id = 'editMenu';
    dropdownDiv.addStyleClasses(['menu'], 'divElement');
    dropdownDiv.setButton('Edit', true);
    document.getElementById('menuInsert').appendChild(dropdownDiv.divElement);
    dropdownDiv.insertElement(getSearchDiv(nav, topTab));
    dropdownDiv.insertElement(getAddComponentsDiv(nav, topTab));
    if (gIsOnline) {
        dropdownDiv.insertElement(getAmiDiv(controller));
        dropdownDiv.insertElement(getAnonymizationDiv(controller));
    }
    dropdownDiv.insertElement(getAttachmentsDiv(controller));
    dropdownDiv.insertElement(getRawDataDiv(controller));
    if (gIsOnline) {
        dropdownDiv.insertElement(getClimateDiv(controller));
        dropdownDiv.insertElement(getScadaDiv(controller));
    }
    dropdownDiv.insertElement(getColorDiv(controller));
    dropdownDiv.insertElement(getGeojsonDiv(controller));
}

/**
 * @returns {undefined}
 */
function addMenuEventHandlers() {
    // - Add event listeners to only allow either the file or edit menu to be open
    const fileMenu = document.getElementById('fileMenu');
    let fileButton = null;
    if (fileMenu !== null) {
        fileButton = fileMenu.getElementsByTagName('button')[0];
        fileButton.addEventListener('click', function() {
            if (this.classList.contains('expanded')) {
                if (editButton !== null && editButton.classList.contains('expanded')) {
                    editButton.click();
                }
            }
        });
    }
    const editMenu = document.getElementById('editMenu');
    let editButton = null;
    if (editMenu !== null) {
        editButton = editMenu.getElementsByTagName('button')[0];
        editButton.addEventListener('click', function() {
            if (this.classList.contains('expanded')) {
                if (fileButton !== null && fileButton.classList.contains('expanded')) {
                    fileButton.click();
                }
            }
        });
    }
    // - Save before rendering the interface to remove any previous error files, but only in "online mode"
    if (gIsOnline) {
        document.getElementById('saveDiv').click();
    }
}

/**
 * @param {FeatureController} controller - a FeatureController instance
 * @returns {undefined}
 */
function createFileMenu(controller) {
    if (!(controller instanceof FeatureController)) {
        throw TypeError('"controller" argument must be instanceof FeatureController.');
    }
    const dropdownDiv = new DropdownDiv();
    dropdownDiv.divElement.id = 'fileMenu';
    dropdownDiv.addStyleClasses(['menu'], 'divElement');
    dropdownDiv.setButton('File', true);
    document.getElementById('menuInsert').appendChild(dropdownDiv.divElement);
    dropdownDiv.insertElement(getSaveDiv(controller));
    dropdownDiv.insertElement(getRenameDiv(controller));
    dropdownDiv.insertElement(getLoadFeederDiv(controller));
    dropdownDiv.insertElement(getBlankFeederDiv(controller));
    dropdownDiv.insertElement(getWindmilDiv(controller));
    dropdownDiv.insertElement(getGridlabdDiv(controller));
    dropdownDiv.insertElement(getCymdistDiv(controller));
    dropdownDiv.insertElement(getOpendssDiv(controller));
}

/**
 * @returns {undefined}
 */
function hideModalInsert() {
    const modalInsert = document.getElementById('modalInsert');
    modalInsert.classList.remove('visible');
}

(function loadInterface() {
    const modalInsert = document.createElement('div');
    modalInsert.id = 'modalInsert';
    if (gIsOnline) {
        modalInsert.classList.add('visible');
        modalInsert.replaceChildren(getLoadingModal().divElement);
    }
    document.getElementsByTagName('main')[0].appendChild(modalInsert);
    setTimeout(() => main(), 1);
})();
</script>

  </body>
</html>