<!DOCTYPE html>
<html>
<head>
	<title>MicrogridUP &raquo; New</title>
	<link rel="stylesheet" href="/static/js/components/modal.css">
	<link rel="stylesheet" href="/static/js/components/circuitBuilder/circuitBuilder.css">
	<link rel="stylesheet" href="/static/js/components/reoptParameters/view.css">
	<script src="/static/js/libraries/graphology-library.js"></script>
	<script src="/static/js/libraries/graphology.js"></script>
	<script src="/static/js/libraries/papaparse.js"></script>
	<script src="https://kit.fontawesome.com/92028f16c4.js" crossorigin="anonymous"></script>
	<style type="text/css">
		:root {
			--topNavHeight: 64px;
		}
		body {
			margin-top: 0px;
			margin-left:0;
			padding:0;
			border:0;
			font-family:sans-serif;
		}
		h3, h5, p {
			margin-bottom:7px;
			margin-left: 5px;
		}
		.chunk, .desc {
			display: inline-block;
			background-color: lightgray;
			padding: 6px;
			border-radius: 4px;
			margin: 4px 2px 4px 2px;
		}
		/* Only style inputs in chunks, not inputs in tables */
		.chunk > input:last-child, .chunk > select:last-child {
			margin-left: .5rem;
		}
		#stepThree {
			margin-left: 5px;
		}
		form {
			/* width: 100%; */
			margin-left: 5px;
		}
		button, input[type='submit'], label.fileButton {
			width:auto;
			padding: 9px;
			margin-left: 5px;
			margin-right:5px;
			margin-top: 5px;
			font-size:small;
			background:seagreen;
			-webkit-border-radius: 5px;
			-moz-border-radius: 5px;
			border-radius: 5px;
			border: none;
			color: white;
			cursor:pointer;
		}
		button:hover, input[type='submit']:hover, label.fileButton:hover {
			background: mediumseagreen;
		}
		/* Style for the disabled button state */
		button[disabled], input[type='submit'][disabled], label.fileButton[disabled] {
			background: rgba(46, 139, 86, 0.561);
			color: rgba(255, 255, 255, 0.725); 
			cursor: default;
		}
		textarea {
			font-size: 12pt;
			margin-left: 5px;
			display: inline-block;
		}
		.advanced {
			display: inline-block;
			max-width: 50%;
			min-width: 500px;
		}
		.step {
		  max-width: 1000;
		  display: block;
		  margin: 0 auto;
		}
		.tooltip {
			border-bottom: 1px dotted #000000; 
			color: #000000;
			outline: none;
			cursor: help; 
			text-decoration: none;
			position: relative;
		}
		.tooltip span {
			margin-left: -999em;
			position: absolute;
			display: inline-block;
		}
		.tooltip:hover span {
			border-radius: 5px 5px; 
			-moz-border-radius: 5px; 
			-webkit-border-radius: 5px; 
			box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.1); 
			-webkit-box-shadow: 5px 5px rgba(0, 0, 0, 0.1); 
			-moz-box-shadow: 5px 5px rgba(0, 0, 0, 0.1);
			font-family: Calibri, Tahoma, Geneva, sans-serif;
			position: absolute; 
			left: 0.5em; 
			top: 1.5em; 
			z-index: 99;
			margin-left: 0; 
			width: 200px;
		}
		.classic {
			background: #A9A9A9; 
			color: white; 
			padding: 5px 5px;
		}
		a {text-decoration: none; color: black;}
		a:hover {text-decoration: underline;}
		.partitionDescription {
            display: none;
        }
        .partitionDescription.active {
            display: block;
        }
		#loading-background {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			z-index: 9998;
			background-color: rgba(0, 0, 0, 0.5);
			display: none;
		}
		#loading-indicator {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			z-index: 9999;
			background-color: white;
			padding: 20px;
			padding-left: 1rem;
			border-radius: 10px;
			text-align: center;
			display: none;
		}
		#loading-indicator span {
			display: block;
			font-size: 2rem;
			animation: fadeInOut 2s linear infinite forwards;
		}
		@keyframes fadeInOut {
			0%,100% { opacity: 1; }
			50% { opacity: 0; }
		}
        header {
            height: var(--topNavHeight);
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 1;
        }
        header span {
            color: white;
        }
        main {
            height: calc(100% - var(--topNavHeight));
            {% if not iframe_mode %}
            padding: var(--topNavHeight) 0px 0px 0px;
            {% endif %}
        }
        span.span--sectionTitle {
            font-family: sans-serif;
            font-size: 2rem;
        }
        div > span.span--sectionTitle:nth-child(2) {
            padding-left: .5rem;
        }
        /* TOP NAV */
        nav.js-nav--topNav {
            background: black;
            display: flex;
            height: 100%;
        }
        /* TOP NAV ANCHORS */
        nav.js-nav--topNav a {
            text-decoration: none;
        }
        /* TOP NAV BUTTONS */
        nav.js-nav--topNav button {
            border: 0;
            background-color: transparent;
            cursor: pointer;
            padding: 14px;
            width: var(--topNavHeight);
        }
        nav.js-nav--topNav button:hover {
            background-color: gray;
            transition: background-color 0.2s ease-out;
        }
        /* TOP NAV SPANS */
        nav.js-nav--topNav div {
            align-items: center;
            display: flex;
        }
        /* TOP NAV SVGS */
        nav.js-nav--topNav svg {
            fill: white;
        }

		fieldset {
			border: none;
		}
		#partitionsPreviewDiv iframe, #oldPartitionPreview {
			width: 1000px;
			height: 750px;
			border: 1px solid #ccc;
		}
		.partitionDescription {
			max-width: 1000px;
		}
	</style>
</head>
<body>
    {% if not iframe_mode %}
    <header>
        <nav class="js-nav--topNav">
            <div>
                <a href="/">
                    <span class="span--sectionTitle" style="padding-left: 1rem;">MicrogridUp &raquo; {% if editing %}Edit Project{% else %}New{% endif %}</span>
                </a>
            </div>
            <div style="padding-right: 1rem; margin-left: auto;">
                <a href="/doc" target="_blank">
                    <svg width="32px" height="32px" viewBox="1 5 22 10">
                        <path fill-rule="evenodd" clip-rule="evenodd" d="M12 19.5C16.1421 19.5 19.5 16.1421 19.5 12C19.5 7.85786 16.1421 4.5 12
                        4.5C7.85786 4.5 4.5 7.85786 4.5 12C4.5 16.1421 7.85786 19.5 12 19.5ZM12 21C16.9706 21 21 16.9706 21 12C21 7.02944 16.9706 3 12
                        3C7.02944 3 3 7.02944 3 12C3 16.9706 7.02944 21 12 21ZM12.75 15V16.5H11.25V15H12.75ZM10.5 10.4318C10.5 9.66263 11.1497 9 12
                        9C12.8503 9 13.5 9.66263 13.5 10.4318C13.5 10.739 13.3151 11.1031 12.9076 11.5159C12.5126 11.9161 12.0104 12.2593 11.5928
                        12.5292L11.25 12.7509V14.25H12.75V13.5623C13.1312 13.303 13.5828 12.9671 13.9752 12.5696C14.4818 12.0564 15 11.3296 15
                        10.4318C15 8.79103 13.6349 7.5 12 7.5C10.3651 7.5 9 8.79103 9 10.4318H10.5Z" fill="#FFFFFF" stroke="#FFFFFF" stroke-width=".5"/>
                    </svg>
                    <span class="span--sectionTitle">Help</span>
                </a>
            </div>
        </nav>
    </header>
    {% endif %}
    <main>
        <!--<div style="height:40px; width:100%; background:black; line-height:40px; padding-left:10px;">
            <p style="color:white; margin:0px"><a style="color:white; text-decoration:none" href="/"><b>MicrogridUP</b></a> &raquo; New</p>
        </div>-->
        <div id='introInfo' class='step'>
            <h3>Step 1: Input project information</h3>
            <form id="modelInfoForm" enctype="multipart/form-data">
                <h5>Site and Energy Provider</h5>
                <div id='MODEL_DIR'></div>
                <div id='QSTS_STEPS'></div>
                <br>
                <div class="chunk">
                    <label class="tooltip" for="DESCRIPTION">Description<span class="classic">Include an optional description of the project. Max 140 characters.</span></label>
                    <textarea id="DESCRIPTION" name="DESCRIPTION" rows="1" cols="30">{{in_data.DESCRIPTION}}</textarea>
                    <p id="characterCount" style="display:inline">0 / 140</p>
                </div>
                <div>
                    <i class="fa fa-plus-square"></i>
                    <a href="javascript:void(0)" class="toggle show">Optional inputs</a>
                    <div style="display:none">
                        <div id="energyCost"></div>
                        <div id="wholesaleCost"></div>
                        <div id="demandCost"></div>
                        <div id="solarCanCurtail"></div>
                        <div id="solarCanExport"></div>
                        <div id="urdbLabelSwitch"></div>
                        <div id="urdbLabel"></div>
                    </div>
                </div>
                <h5>Load Profile</h5>
                <div class="chunk">
                    {% if in_data.get('LOAD_CSV') %}
                        <label class="tooltip" for="LOAD_CSV_NAME">Load Data (.csv)<span class="classic">Please upload a .csv file representing the hourly load shape. See Appendix A in the help for formatting details.</span></label>
						{% set load_path_as_list = in_data.get('LOAD_CSV').split('/') %}
                        <input type="text" name="LOAD_CSV_NAME" value="{{ load_path_as_list[-1] }}" class="file-input" readonly>
                        <button type="button" class="remove-btn">Remove File</button>
                    {% else %}
                        <div id='csvLoadParserInsert'></div>
                    {% endif %}
                </div>
                <div id="analysisYears"></div>
                <div>
                    <i class="fa fa-plus-square"></i>
                    <a href="javascript:void(0)" class="toggle show">Optional inputs</a>
                    <div style="display:none">
                        <div id="year"></div>
                    </div>
                </div>
                <h5>Resilience</h5>
                <div class="chunk">
                    <div id='outageLocationInputInsert'></div>
                </div>
                <div id="outageDuration"></div>
				<div class="chunk">
                    {% if in_data.get('OUTAGE_CSV') %}
                        <label class="tooltip" for="HISTORICAL_OUTAGES">Historical Outage Data (.csv)<span class="classic">Please upload a .csv file representing historical outages. See Appendix A in the help for formatting details.</span></label>
						{% set outages_path_as_list = in_data.get('OUTAGE_CSV').split('/') %}
                        <input type="text" name="HISTORICAL_OUTAGES" value="{{ outages_path_as_list[-1] }}" class="file-input" readonly>
                        <button type="button" class="remove-btn">Remove File</button>
                    {% else %}
                        <label class="tooltip" for="HISTORICAL_OUTAGES">Historical Outage Data (.csv)<span class="classic">Please upload a .csv file representing historical outages. See Appendix A in the help for formatting details.</span></label>
                        <input type="file" name="HISTORICAL_OUTAGES" class="file-input" accept=".csv">
                        <button type="button" class="remove-btn">Remove File</button>
                    {% endif %}
                </div>
                <div>
                    <i class="fa fa-plus-square"></i>
                    <a href="javascript:void(0)" class="toggle show">Optional inputs</a>
                    <div style="display:none;">
                        <div id='maxRuntimeSeconds'></div>
                    </div>
                </div>
                <h5>Financial</h5>
                <div id="value_of_lost_load"></div>
                <div id="singlePhaseRelayCost"></div>
                <div id="threePhaseRelayCost"></div>
                <div>
                    <i class="fa fa-plus-square"></i>
                    <a href="javascript:void(0)" class="toggle show">Optional inputs</a>
                    <div style="display:none">
                        <div id="omCostEscalator"></div>
                        <div id='discountRate'></div>
                    </div>
                </div>
            </form>

            <h3>Step 2: Specify existing circuit</h3>
            <p>Please select your circuit creation method:</p>
			<input type="radio" id="wizard" name="circuit" value="Creator" />
            <label for="wizard">Build circuit manually</label><br>
            <input type="radio" id="upload" name="circuit" value="Upload" />
            <label for="upload">Upload circuit from file</label><br>

			<div id="circuitCreator" class="desc">
                <div id='latitude'></div>
                <div id='longitude'></div>
			</div>
            <div id="circuitUpload" class="desc" style="margin-top:10px">
                <div class="chunk">
                    <form id="upload-file" method="post" enctype="multipart/form-data">
                        {% if in_data.get('BASE_DSS') %}
                            <fieldset>
                                <label for="BASE_DSS_NAME">Circuit Definition (.dss)</label>
								{% set dss_path_as_list = in_data.get('BASE_DSS').split('/') %}
                                <input id="circuitPostCreation" type="text" name="BASE_DSS_NAME" value="{{ dss_path_as_list[-1] }}" class="file-input" readonly />
                            </fieldset>
                            <fieldset>
                                <button id="upload-file-btn" type="button" hidden>Upload</button>
                                <button id="remove-circuit-button" type="button" class="remove-btn">Remove File</button>
                            </fieldset>
                        {% else %}
                            <fieldset>
                                <label for="BASE_DSS_NAME">Circuit Definition (.dss)</label>
                                <input name="BASE_DSS_NAME" type="file" class="file-input" accept=".dss">
                            </fieldset>
                            <fieldset>
                                <button id="upload-file-btn" type="button">Upload</button>
                                <button type="button" class="remove-btn">Remove File</button>
                            </fieldset>
                        {% endif %}
                    </form>
                </div>
            </div>

            <div id="critLoads">
            </div>

        </div>

        <div id="partitionPreviewerContainer" class="step">
            <h3>Step 3: Partition circuit into microgrids</h3>
            <div id="stepThree" class="chunk">
                <label class="tooltip" for="MG_DEF_METHOD">Microgrid Definition Method<span class="classic">Select a method by which the circuit should be partitioned into microgrids.</span></label>
                <select id="partitionMethod" name="MG_DEF_METHOD" style="margin-right:6px" disabled>
                    <option value="" disabled selected>Select method</option>
                    <!-- <option value="lukes" {% if in_data.MG_DEF_METHOD == 'lukes' %}selected{% endif %}>Lukes</option> -->
                    <option value="branch" {% if in_data.MG_DEF_METHOD == 'branch' %}selected{% endif %}>Branch</option>
                    <option value="bottomUp" {% if in_data.MG_DEF_METHOD == 'bottom-up' %}selected{% endif %}>Bottom-Up</option>
                    <option value="criticalLoads" {% if in_data.MG_DEF_METHOD == 'critical_loads' %}selected{% endif %}>Critical Loads</option>
					<option value="loadGrouping" {% if in_data.MG_DEF_METHOD == 'loadGrouping' %}selected{% endif %}>Load Grouping</option>
                    <option value="manual" {% if in_data.MG_DEF_METHOD == 'manual' %}selected{% endif %}>Manual</option>
                </select></br>
				<div id="lukesDescription" class="partitionDescription">
					<p>Use Lukes' "Efficient Algorithm for the Partitioning of Trees" (1974) to divide circuit into microgrids.</p>
				</div>
				<div id="branchDescription" class="partitionDescription">
					<p>Divide circuit into microgrids at the first bus from which there are multiple feeders.</p>
					<!-- <p>Divide circuit into microgrids at branch points.</p> Uncomment and remove this sentence when transitioning to new_nx_group_branch(). -->
				</div>
				<div id="bottomUpDescription" class="partitionDescription">
					<p>Form microgrids at the ends of each feeder and add elements upstream of each element to the same microgrid, merging with neighboring microgrids, until there are the desired number of microgrids.</p>
				</div>
				<div id="criticalLoadsDescription" class="partitionDescription">
					<p>Form a microgrid for each critical load and add elements upstream of each critical load to the same microgrid, merging with neighboring microgrids, until there are the desired number of microgrids.</p>
				</div>				
				<div id="loadGroupingDescription" class="partitionDescription">
					<p>Assign each load to a specific microgrid and optionally input the generation bus and switch for each microgrid.</p>
				</div>
				<div id="loadGroupingDescriptionUsedWizard" class="partitionDescription">
					<p>Assign each load to a specific microgrid. Generation buses and switches will be selected automatically.</p>
				</div>
				<div id="manualDescription" class="partitionDescription">
					<p>Assign each load to a specific microgrid. Input the existing generation objects for each microgrid and optionally input generation bus and switches for each microgrid.</p>
				</div>
				<div id="manualDescriptionUsedWizard" class="partitionDescription">
					<p>Assign each load to a specific microgrid and input the existing generation objects for each microgrid. Generation buses and switches will be selected automatically.</p>
				</div>
                <form id="partitionManuallyForm" style="display: none;">
                    <label for="mgQuantity">How many microgrids?</label>
                    <input id="mgQuantity" type="text" autocomplete="off" placeholder="# of microgrids" />
                    <button id="makeManuallyPartitioningContainerButton" type="button">Go</button><br>
                </form>
                <form id="minQuantMgsForm" style="display: none;">
                    <label for="mingQuantMgs">At least how many microgrids?</label>
                    <input id="minQuantMgs" type="text" autocomplete="off" placeholder="Min # of microgrids" />
                </form>
				<form id="branchForm" style="display: none;"> <!-- new_nx_group_branch. -->
                    <label for="branchForm">How many microgrids?</label>
                    <input id="mgQuantBranch" type="text" autocomplete="off" placeholder="# of microgrids" />
                </form>
                <div id="manualPartitioningContainer" class="chunk" style="display: none;"></div>
                <button id="previewPartitionsButton" type="button" disabled>Preview partitions</button>
                <div id="partitionsPreviewDiv"></div>
            </div>
        </div>

        <div id='techSelect' class='step'>
            <h3>Step 4: Select technologies to be used in microgrids</h3>
            <form id="techParamForm" enctype="multipart/form-data">
                <div id='solar'></div>
                <div id='battery'></div>
                <div id='fossil'></div>
                <div id='wind'></div>
                <div id="solarDiv" style="display:none">
                    <h5>Solar</h5>
                    <div id='solarCost'></div>
                    <div id="solarMax"></div>
                    <div id="solarMin"></div>
                    <div id='solarMacrsOptionYears'></div>
                    <div id='solarItcPercent'></div>
                </div>
                <div id="batteryDiv" style="display:none">
                    <h5>Battery</h5>
                    <div id='batteryCapacityCost'></div>
                    <div id='batteryCapacityMax'></div>
                    <div id='batteryCapacityMin'></div>
                    <div id='batteryPowerCost'></div>
                    <div id="batteryPowerMax"></div>
                    <div id="batteryPowerMin"></div>
                    <div id='batteryMacrsOptionYears'></div>
                    <div id="batteryItcPercent"></div>
                    <div id="batteryPowerCostReplace"></div>
                    <div id='batteryCapacityCostReplace'></div>
                    <div id="batteryPowerReplaceYear"></div>
                    <div id='batteryCapacityReplaceYear'></div>
                </div>
                <div id=fossilDiv style="display:none">
                    <h5>Fossil</h5>
                    <div id='dieselGenCost'></div>
                    <div id='dieselMax'></div>
                    <div id='dieselMin'></div>
                    <div id='fuelAvailable'></div>
                    <div id='minGenLoading'></div>
                    <div id='dieselFuelCostGal'></div>
                    <div id='dieselCO2Factor'></div>
                    <div id='dieselOMCostKw'></div>
                    <div id='dieselOMCostKwh'></div>
                    <div id='dieselOnlyRunsDuringOutage'></div>
                    <div id='dieselMacrsOptionYears'></div>
                </div>
                <div id="windDiv" style="display:none">
                    <h5>Wind</h5>
                    <div id='windCost'></div>
                    <div id='windMax'></div>
                    <div id='windMin'></div>
                    <div id='windMacrsOptionYears'></div>
                    <div id='windItcPercent'></div>
                </div>
                <h3>Step 5 (Optional): Override technology parameters per-microgrid</h3>
                <div id="reoptParametersMVC" class="chunk"></div>
                <br>
            </form>
            <button id="submitEverything" type="submit">Run Project</button>
        </div>
        <div id="loading-background"></div>
        <div id="loading-indicator">
            <span>Loading...</span>
        </div>
    </main>

	<script>
	/** Custom error class for detecting cycles.*/
	class CycleDetectedError extends Error {
		constructor(error, message, status) {
			super(error);
			this.name = 'CycleDetectedError';
			this.message = message;
			this.status = status;
		}
	}

	/** Check if a .file-input (can be a file input or read-only text input) has a value and show/hide the associated Remove File button. */
	function toggleRemoveButton(chunk) {
		const fileInput = chunk.querySelector('input.file-input');
		const removeBtn = chunk.querySelector('button.remove-btn');
		if (fileInput) {
			const uploadedFile = fileInput.getAttribute('data-uploaded');
			const isNoneValue = uploadedFile === 'None';
			if (fileInput.value || (uploadedFile && !isNoneValue) || (uploadedFile && fileInput.getAttribute('type') === 'text')) {
				// Show the Remove File button if there is a file input value or uploadedFile is not 'None'. Also show the Remove File button if there is a non-empty uploadedFile value and the file input is a read-only text input.
				removeBtn.style.display = 'inline-block';
			} else {
				removeBtn.style.display = 'none';
				// Modify the behavior when the Remove File button is clicked for pre-Jinja'd file uploads (read-only text input).
				if (fileInput.getAttribute('type') === 'text') {
					if (fileInput.getAttribute('name') === 'LOAD_CSV_NAME') {
						const nameAttribute = 'LOAD_CSV';
						chunk.replaceChildren(window.csvLoadParser.modal.divElement);
						const removeBtn = chunk.querySelector('button.remove-btn');
						removeBtn.style.display = 'none';
					} else {
						const oldNameAttribute = fileInput.getAttribute('name');
						const nameAttribute = oldNameAttribute;
						const fileType = oldNameAttribute === 'BASE_DSS_NAME' ? '.dss' : '.csv';
						// Replace the read-only text input with a new file input.
						const newFileInput = document.createElement('input');
						newFileInput.setAttribute('type', 'file');
						newFileInput.classList.add('file-input');
						newFileInput.setAttribute('name', nameAttribute);
						newFileInput.setAttribute('accept', fileType);
						fileInput.replaceWith(newFileInput);
						// Set up the new file input for further functionality
						newFileInput.addEventListener('change', function () {
							toggleRemoveButton(chunk);
						});
						toggleRemoveButton(chunk);
						// Show the upload button if user wants to upload new circuit
						document.getElementById('upload-file-btn').style.display = 'inline-block';
					}
				}
			}
		}
	}

	/** Limit description text. */
	function limitTextareaCharacters() {
		const textarea = document.getElementById('DESCRIPTION');
		const characterCount = document.getElementById('characterCount');
		let text = textarea.value;
		// Trim the text if it exceeds the character limit.
		if (text.length > 140) {
			textarea.value = text.substr(0, 140);
			text = textarea.value;
		}
		characterCount.textContent = text.length + " / 140";
	}

	/** Meant to emulate jQuery slideUp method. */
	function slideUp(element, duration = 500) {
		element.style.transition = `height ${duration}ms ease-in-out`;
		element.style.height = element.offsetHeight + 'px';
		element.offsetHeight; // Force reflow
		element.style.height = 0;
		element.style.overflow = 'hidden';
		setTimeout(() => {
			element.style.display = 'none';
			element.style.height = '';
			element.style.overflow = '';
			element.style.transition = '';
		}, duration);
	}

	/** Meant to emulate jQuery slideDown method. */
	function slideDown(element, duration = 500) {
		element.style.display = 'block';
		element.style.height = 0;
		element.style.overflow = 'hidden';
		element.style.transition = `height ${duration}ms ease-in-out`;
		setTimeout(() => {
			element.style.height = element.scrollHeight + 'px';
			element.offsetHeight; // Force reflow

			setTimeout(() => {
				element.style.height = '';
				element.style.overflow = '';
				element.style.transition = '';
			}, duration);
		}, 0);
	}

	/** Toggle technology checkboxes. */
	function toggleDivVisibility(checkboxId, divId) {
		// - TODO: use actual checkboxes again
		const checkbox = document.getElementById(checkboxId);
		const div = document.getElementById(divId);
		if (checkbox.checked) {
			slideDown(div);
		} else {
			slideUp(div);
		}
	}

	function slideToggle(element, duration = 500) {
		if (window.getComputedStyle(element).display === 'none') {
			slideDown(element, duration);
		} else {
			slideUp(element, duration);
		}
	}

	/** Populate critical load selection div if editing an existing circuit. */
	async function getLoadsFromExistingFile(MODEL_DIR, criticalLoads) {
		try {
			const response = await fetch('/getLoadsFromExistingFile', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify({ MODEL_DIR: MODEL_DIR })
			});
			const responseJson = await response.json();
			if (!response.ok) {
				throw new Error(responseJson.message);
			}
			window.circuitIsSpecified = true;
			const loads = responseJson.loads;
			const critLoadsContainer = document.getElementById('critLoads');
			const manualPartitioningContainer = document.getElementById('manualPartitioningContainer');
			// Clear contents of critLoads and manualPartitioningContainer.
			critLoadsContainer.innerHTML = '';
			manualPartitioningContainer.innerHTML = '';
			// Instructions for critLoads.
			const critLoadsParagraph = document.createElement('p');
			critLoadsParagraph.textContent = 'Please select all critical loads:';
			critLoadsContainer.appendChild(critLoadsParagraph);
			// Hide manualPartitioningContainer.
			manualPartitioningContainer.style.display = 'none';
			// Create a form to house checkboxes.
			const criticalLoadsSelect = document.createElement('form');
			criticalLoadsSelect.id = 'criticalLoadsSelect';
			criticalLoadsSelect.classList.add('chunk');
			critLoadsContainer.appendChild(criticalLoadsSelect);
			// Create a div to house load assignment dropdown menus.
			const loadAssignmentContainer = document.createElement('div');
			loadAssignmentContainer.id = 'loadAssignmentContainer';
			manualPartitioningContainer.appendChild(loadAssignmentContainer);
			// Create checkboxes and labels for each load.
			for (let i = 0; i < loads.length; i++) {
				const checkbox = document.createElement('input');
				checkbox.type = 'checkbox';
				if (criticalLoads.includes(loads[i])) {
					checkbox.checked = true;
				}
				const label = document.createElement('label');
				label.style.display = 'inline-block';
				label.style.paddingRight = '5px';
				label.appendChild(checkbox);
				label.appendChild(document.createTextNode(loads[i]));
				criticalLoadsSelect.appendChild(label);
				// Add a dropdown to loadAssignmentContainer.
				const dropdownLabel = document.createElement('label');
				dropdownLabel.style.display = 'inline-block';
				dropdownLabel.style.paddingRight = '8px';
				const dropdown = document.createElement('select');
				dropdown.dataset.loadId = loads[i];
				dropdown.style.marginRight = '3px';
				dropdownLabel.appendChild(dropdown);
				dropdownLabel.appendChild(document.createTextNode(loads[i]));
				loadAssignmentContainer.appendChild(dropdownLabel);
			}
			// Handle case where there are no loads.
			if (loads.length === 0) {
				const noLoadsMessage1 = document.createElement('p');
				noLoadsMessage1.textContent = 'No loads to select from.';
				criticalLoadsSelect.appendChild(noLoadsMessage1);
				
				const noLoadsMessage2 = document.createElement('p');
				noLoadsMessage2.textContent = 'No loads to assign to microgrids.';
				manualPartitioningContainer.appendChild(noLoadsMessage2);
			}
			// Make directory uneditable.
			const modelDirInput = document.querySelector('input[name="MODEL_DIR"]');
			if (modelDirInput) {
				modelDirInput.readOnly = true;
			}
		} catch (error) {
			alert(error);
		}
	}

	/** Show previously selected partitions on edit flow. */
	async function showOldPartitions(MODEL_DIR, MICROGRIDS, CRITICAL_LOADS) {
		document.getElementById('stepThree').style.display = 'none';
		const oldPartitionsDiv = document.createElement('div');
		oldPartitionsDiv.id = 'oldPartitionDiv';
		oldPartitionsDiv.classList.add('chunk');
		// Grab a NetworkX diagram of current partition layout.
		const data = {
			MODEL_DIR: MODEL_DIR,
			MICROGRIDS: MICROGRIDS,
			CRITICAL_LOADS: CRITICAL_LOADS
		};
		document.body.style.cursor = 'progress';
		try {
			const response = await fetch('/previewOldPartitions', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify(data)
			});
			const responseJson = await response.json();
			document.body.style.cursor = 'default';
			if (response.ok) {
				const iframe = document.createElement('iframe');
				iframe.id = 'oldPartitionPreview';
				iframe.src = responseJson.map_url;
				oldPartitionsDiv.prepend(iframe);
				window.createReoptParametersMVC(responseJson.MICROGRIDS);
				{% if iframe_mode %}
				window.disableInputs();
				{% endif %}
			} else {
				throw new Error(responseJson.message);
			}
		} catch (error) {
			document.body.style.cursor = 'default';
			alert(error);
		}
		document.getElementById('partitionPreviewerContainer').appendChild(oldPartitionsDiv);
		const partitionButtonContainer = document.createElement('div');
		const partitionButton = document.createElement('button');
		partitionButton.textContent = 'Partition circuit differently';
		partitionButtonContainer.appendChild(partitionButton);
		oldPartitionsDiv.appendChild(partitionButtonContainer);
		partitionButton.addEventListener('click', function() {
			document.getElementById('stepThree').style.display = 'block';
			oldPartitionsDiv.style.display = 'none';
			document.getElementById('previewPartitionsButton').disabled = false;
			document.getElementById('partitionMethod').disabled = false;
		});
	}

	/** Check to see if uploaded circuit contains cycles when user clicks 'Go' during manual. */
	async function has_cycle() {
		const modelDir = document.querySelector('input[name="MODEL_DIR"]').value; // modelDir is safe to send over HTTP (unlike full path to uploads folder contained in window.filename). Full path is constructed in backend.
		const dssPath = document.getElementById('circuitPostCreation');
		let dssPathIndicator;
		if (dssPath == undefined) {
			dssPathIndicator = 'DIRECT TO UPLOADS FOLDER';
		} else {
			dssPathIndicator = dssPath.value;
		}

		try {
			const response = await fetch('/has_cycles', {
				method: 'POST',
				body: JSON.stringify({
					MODEL_DIR: modelDir, 
					DSS_PATH_INDICATOR: dssPathIndicator
				}),
				headers: {
					'Content-type': 'application/json; charset=UTF-8'
				}
			})
			if (!response.ok) {
				const errorData = await response.json();
				if (response.status == 422 & errorData.error == 'CycleDetectedError') {
					throw new CycleDetectedError(errorData.error, errorData.message, response.status);
				} else {
					throw new Error(errorData.message);	
				}
			}
			const data = await response.json();
			return false;
		} catch(error) {
			return error;
		}
	}

	function makeMgNameInput(idx) {
		const mgNameLabel = document.createElement('label');
		mgNameLabel.setAttribute('for', `mg${idx}Name`);
		mgNameLabel.innerHTML = `Mg${idx} Name `;
		const mgNameInput = document.createElement('input');
		mgNameInput.id = `mg${idx}Name`;
		mgNameInput.type = 'text';
		mgNameInput.placeholder = 'Optional';
		mgNameInput.dataset.mgId = `mg${idx}`;
		mgNameInput.addEventListener('input', function() { // Real time input filtering.
			let value = mgNameInput.value;
			value = value.toLowerCase(); // Convert to lowercase.
			value = value.replace(/[^a-z0-9-]/g, ''); // Remove any character that is not alphanumeric or dash.
			value = value.replace(/\s/g, ''); // Remove spaces.
			mgNameInput.value = value;
		});
		partitioningTextInputContainer.append(mgNameLabel, mgNameInput);
	}

	function makeGenObsExistingInput(idx) {
		const partitioningTextInputContainer = document.getElementById('partitioningTextInput');
		const label = document.createElement('label');
		label.setAttribute('for', `mg${idx}GenObsExisting`);
		label.className = 'tooltip';
		label.innerHTML = ` Mg${idx} Existing Generation Objects <span class="classic">Input names of existing generation objects separated by commas.</span>`;
		const input = document.createElement('input');
		input.id = `mg${idx}GenObsExisting`;
		input.type = 'text';
		input.dataset.mgId = `mg${idx}`;
		partitioningTextInputContainer.append(label, input);
	}

	function makePartitioningTextInputInput(idx) {
		const partitioningTextInputContainer = document.getElementById('partitioningTextInput');
		const genBusLabel = document.createElement('label');
		genBusLabel.setAttribute('for', `mg${idx}GenBus`);
		genBusLabel.innerHTML = ` Mg${idx} Gen Bus `;
		const genBusInput = document.createElement('input');
		genBusInput.id = `mg${idx}GenBus`;
		genBusInput.type = 'text';
		genBusInput.placeholder = 'Optional';
		genBusInput.dataset.mgId = `mg${idx}`;
		const switchLabel = document.createElement('label');
		switchLabel.setAttribute('for', `mg${idx}Switch`);
		switchLabel.innerHTML = ` Mg${idx} Switch `;
		const switchInput = document.createElement('input');
		switchInput.id = `mg${idx}Switch`;
		switchInput.type = 'text';
		switchInput.placeholder = 'Optional';
		switchInput.dataset.mgId = `mg${idx}`;
		partitioningTextInputContainer.append(genBusLabel, genBusInput, switchLabel, switchInput);
	}

	function attachManualPartitioningEventHandler() {
		// Manual partitioning dynamic dropdown creation. 
		document.getElementById('makeManuallyPartitioningContainerButton').addEventListener('click', async function() {
			if (window.circuitIsSpecified === false) {
				alert('Please complete step 2.')
				return
			}
			const selectedPartitioningMethod = document.getElementById('partitionMethod').value;
			if (selectedPartitioningMethod == 'loadGrouping') { // loadGrouping relies on networkx and networkx breaks when the circuit has a cycle.
				const cycleDetected = await has_cycle(); 
				if (cycleDetected) {
					if (cycleDetected instanceof CycleDetectedError) { 
						alert(`${cycleDetected}. Please remove cycle from circuit or choose a different partitioning method.`);
					} else {
						alert(cycleDetected);
					}
					return
				}
			}
			if (document.getElementById('mgQuantity').value == undefined) {
				alert('Please input a number.')
				return
			}
			// Manual grouping GUI includes inputs for gen_bus and switch.
			const numMgs = document.getElementById('mgQuantity').value;
			// TODO: throw an error if user inputs 0.
			// TODO: throw an error if user inputs non-numeric text.
			const mgs = {};
			for (let i = 0; i < numMgs; i++) {
				mgs[`mg${i}`] = {};
			}
			window.createReoptParametersMVC(mgs);
			const usedUpload = window.circuitModel.getElements().length == 0;
			const manualPartitioningContainer = document.getElementById('manualPartitioningContainer');
			let existingPartitioningTextInputContainer = document.getElementById('partitioningTextInput');
			if (existingPartitioningTextInputContainer) {
				existingPartitioningTextInputContainer.remove(); // Clear existing #partitioningTextInput if it exists already.
			}
			partitioningTextInputContainer = document.createElement('div');
			partitioningTextInputContainer.id = 'partitioningTextInput';
			manualPartitioningContainer.prepend(partitioningTextInputContainer);
			for (let idx = 0; idx < numMgs; idx++) {
				// Regardless of partitioning method (manual vs loadGrouping) and circuit origin (wizard vs upload), we provide optional inputs for naming microgrids. 
				makeMgNameInput(idx);
				if (selectedPartitioningMethod === 'manual') { // If the user selected manual partitioning, we should always provide genObsExisting input. If the user uploaded their circuit, we should also provide inputs for switch and genBus. If the user used the wizard, switch and genBus are preselected.
					makeGenObsExistingInput(idx); // manual + wizard = genObsExisting
					if (usedUpload) {
						makePartitioningTextInputInput(idx); // manual + upload = genObsExisting + partitioningTextInput
					}
				} else if (selectedPartitioningMethod === 'loadGrouping' && usedUpload) { // If the user selected loadGrouping partitioning, we do not provide genObsExisting input because networkx will find existing generation. We provide switch and genBus input only if the user uploaded their circuit because, as with manual paritioning, wizard circuits come with preselected switch and genBus.
					makePartitioningTextInputInput(idx);
				}
				partitioningTextInputContainer.append(document.createElement('br'));
			}
			const selects = document.querySelectorAll('#manualPartitioningContainer label select');
			selects.forEach(select => {
				select.innerHTML = ''; 			
				const noneOption = document.createElement('option');
				noneOption.value = 'None';
				noneOption.textContent = 'None';
				noneOption.dataset.mgId = 'None';
				select.appendChild(noneOption);
				for (let idx = 0; idx < numMgs; idx++) {
					const option = document.createElement('option');
					option.value = `Mg${idx}`;
					option.textContent = `Mg${idx}`;
					option.dataset.mgId = `mg${idx}`;
					select.appendChild(option);
				}
			});
			manualPartitioningContainer.style.display = 'block';
		})
		// Also call above function if user presses enter.
		document.getElementById('mgQuantity').addEventListener('keypress', function(e) {
			if (e.key === 'Enter' || e.which === 13) {
				e.preventDefault();
				document.getElementById('makeManuallyPartitioningContainerButton').click();
			}
		});
	}

	function attachPartitioningSelectEventHandler() {
		// Hide/show manual partitioning div. 
		document.getElementById('partitionMethod').addEventListener('change', function() {
			// Show appropriate description in body of partition block.
			const selectedPartitioningMethod = this.value;
			const partitionDescriptions = document.querySelectorAll('.partitionDescription');
            partitionDescriptions.forEach(function(partitionDescription) {
                partitionDescription.classList.remove('active');
            });
			let selectedPartitioningMethodDescription;
			const partitioningMethods = ['branch', 'bottomUp', 'criticalLoads', 'loadGrouping', 'manual'];
			if ((selectedPartitioningMethod == 'loadGrouping' && window.circuitModel.getElements().length > 0) || (selectedPartitioningMethod == 'manual' && window.circuitModel.getElements().length > 0)) { // loadGrouping/manual partitioning description should be slightly different when the wizard is used since gen_bus and switch inputs aren't shown.
				selectedPartitioningMethodDescription = selectedPartitioningMethod + 'Description' + 'UsedWizard';	
				document.getElementById(selectedPartitioningMethodDescription).classList.add('active');
			} else if (partitioningMethods.includes(selectedPartitioningMethod)) {
				selectedPartitioningMethodDescription = selectedPartitioningMethod + 'Description';
				document.getElementById(selectedPartitioningMethodDescription).classList.add('active');
			} else if (selectedPartitioningMethod == '') {} // Show no description because no partition method has been selected yet.

			document.getElementById('minQuantMgs').value = ''; // Clear input from bottomUp and criticalLoads partitioning.
			document.getElementById('mgQuantBranch').value = ''; // Clear input from branch partitioning. // new_nx_group_branch.
			if (selectedPartitioningMethod === 'loadGrouping' || selectedPartitioningMethod === 'manual') {
				document.getElementById('manualPartitioningContainer').style.display = 'none';
				document.getElementById('partitionManuallyForm').style.display = 'block';
				document.getElementById('makeManuallyPartitioningContainerButton').style.display = 'inline-block';
				document.getElementById('previewPartitionsButton').style.display = 'none';
				document.getElementById('minQuantMgsForm').style.display = 'none';
				document.getElementById('branchForm').style.display = 'none'; // new_nx_group_branch.
				document.getElementById('partitionsPreviewDiv').innerHTML = '';
			} else {
				document.getElementById('partitionManuallyForm').style.display = 'none';
				document.getElementById('minQuantMgsForm').style.display = 'none';
				document.getElementById('branchForm').style.display = 'none'; // new_nx_group_branch.
				document.getElementById('manualPartitioningContainer').style.display = 'none';
				document.getElementById('previewPartitionsButton').style.display = 'block';
			}
			if (selectedPartitioningMethod === 'bottomUp' || selectedPartitioningMethod === 'criticalLoads') {
				document.getElementById('minQuantMgsForm').style.display = 'block';
				document.getElementById('makeManuallyPartitioningContainerButton').style.display = 'none';
			}
			// Uncomment when transitioning to new_nx_group_branch.
			// if (selectedPartitioningMethod === 'branch') {
			//     document.getElementById('branchForm').style.display = 'block';
			//     document.getElementById('makeManuallyPartitioningContainerButton').style.display = 'none';
			// }

		})
	}

	/** Grab partitioning preview. */
	async function attachPartitionButtonEventHandler() {
		document.getElementById('previewPartitionsButton').addEventListener('click', async function() {
			if (window.circuitIsSpecified === false) {
				alert('Please complete step 2.');
				return;
			}
			// Get critical loads, if any.
			const critLoads = [];
			document.querySelectorAll('#criticalLoadsSelect label').forEach(function(label) {
	            if (label.querySelector('input').checked) {
					const element = label.textContent.trim();
					critLoads.push(element);
				}
			});
			// Get partitioning method.
			const method = document.querySelector('#partitionMethod option:checked').value;
			if (method === "") {
				alert('Please ensure you have chosen a partition method.');
				return;
			}
			// Get mgQuantity, if applicable. 
			const mgQuantity = document.getElementById('minQuantMgs').value || document.getElementById('mgQuantBranch').value || 0; // new_nx_group_branch.
			document.body.style.cursor = 'progress';
			try {
				const response = await fetch('previewPartitions', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify({
						critLoads: critLoads,
						fileName: window.filename,
						method: method,
						mgQuantity: mgQuantity,
						modelDir: "{{in_data['MODEL_DIR']}}"
					})
				});
				const responseJson = await response.json();
				document.body.style.cursor = 'default';
				if (response.ok) {
					if (responseJson === 'Invalid partitioning method') {
						alert('Selected partitioning method produced invalid results. Please choose a different partitioning method.');
					} else {
						// Create iframe. 
						const iframe = document.createElement('iframe');
						iframe.id = 'previewIframe';
						iframe.src = responseJson.map_url;
						const previewDiv = document.getElementById('partitionsPreviewDiv');
						previewDiv.innerHTML = '';
						previewDiv.appendChild(iframe);
						window.createReoptParametersMVC(responseJson.MICROGRIDS);
					}
				} else {
					throw new Error(responseJson.message);
				}
			} catch (error) {
				document.body.style.cursor = 'default';
				alert(error);
			}
		});
		// Also call above function if user presses enter.
		document.getElementById('minQuantMgs').addEventListener('keypress', function(e) {
			if (e.which === 13) {
				e.preventDefault();
				document.getElementById('previewPartitionsButton').click();
			}
		});
		document.getElementById('mgQuantBranch').addEventListener('keypress', function(e) { // new_nx_group_branch.
			if (e.which === 13) {
				e.preventDefault();
				document.getElementById('previewPartitionsButton').click();
			}
		});
	}


	function highlightIncorrectFields(form) {
		var inputs = form.querySelectorAll("input");
		for (var i = 0; i < inputs.length; i++) {
			var input = inputs[i];
			if (!input.checkValidity()) {
				input.style.border = "1px solid red";
			}
		}
	}

	/** Submit everything. */
	async function submitEverything() {
		// Do not proceed if no circuit is specified.
		if (window.filename === '') {
			alert('Please submit a circuit.')
			return 
		}
		// Do not proceed if no loads are specified.
		const loadCsvElement = document.querySelector('[name="LOAD_CSV"]');
		const loadCsvNameElement = document.querySelector('[name="LOAD_CSV_NAME"]');
		if ((!loadCsvElement || !loadCsvElement.value) && (!loadCsvNameElement || !loadCsvNameElement.value)) {
			alert('Please specify load data.');
			return;
		}
		// Do not proceed if no partition method is specified.
		const partitionMethodValue = document.querySelector("#partitionMethod option:checked").value;
		const oldPartitionDiv = document.getElementById('oldPartitionDiv');
		if (partitionMethodValue === '' && (!oldPartitionDiv || oldPartitionDiv.offsetParent === null)) {
			alert('Please specify a partitioning method.')
			return 
		}
		// Do not proceed if the partitions haven't been previewed
		if (window.reoptParametersModel === undefined) {
			alert('Please preview your microgrid partitions.');
			return;
		}
		var form1 = new FormData(document.getElementById("modelInfoForm"));
		var form2 = new FormData(document.getElementById("techParamForm"));
		for (var pair of form2.entries()) {
			form1.append(pair[0], pair[1]);
		}
		// Specify circuit location.
		const dssPath = document.getElementById('circuitPostCreation');
		if (dssPath == undefined) {
			form1.append('DSS_PATH','Direct to uploads folder.');
		} else {
			form1.append('DSS_PATH',dssPath.value);
		}
		// Specify outages path if reused.
		const outages_path = document.getElementsByName('HISTORICAL_OUTAGES')[0].value;
		if (outages_path == '' || outages_path.includes('fakepath')) {
			form1.append('OUTAGES_PATH','Check files');
		} else {
			form1.append('OUTAGES_PATH',outages_path);
		}
		// Append CRITICAL_LOADS.
		const critLoads = [];
		document.querySelectorAll('#criticalLoadsSelect label').forEach(label => {
			const input = label.querySelector('input');
			if (input && input.checked) {
				critLoads.push(label.textContent.trim());
			}
		});
		form1.append('CRITICAL_LOADS',JSON.stringify(critLoads));
		// Append MG_DEF_METHOD. 
		const selectedPartitioningMethod = document.getElementById('partitionMethod').value;
		form1.append('MG_DEF_METHOD',selectedPartitioningMethod);
		// Do not proceed if loadGrouping/manual is selected and no partitions are created.
		const manualPartitioningContainer = document.getElementById('manualPartitioningContainer');
		const isManualPartitioningContainerVisible = manualPartitioningContainer && manualPartitioningContainer.offsetParent !== null;
		if ((selectedPartitioningMethod === 'loadGrouping' && !isManualPartitioningContainerVisible) || (selectedPartitioningMethod === 'manual' && !isManualPartitioningContainerVisible)) {
			alert('Please enter a number of microgrids and press Go.')
			return
		};
		// If loadGrouping or manual is selected, append a 'PARTITION_PARAMS' value.
		let PARTITION_PARAMS = {
			ids: new Set(),
			pairings: {},
			gen_obs_existing: {},
			gen_bus: {},
			switch: {},
			mg_name: {}
		};
		if ((selectedPartitioningMethod == 'loadGrouping') || (selectedPartitioningMethod == 'manual')) {
			// Add all load->microgrid assignments to PARTITION_PARAMS.pairings object.
			// Add all mg ids that user has assigned loads to to PARTITION_PARAMS.ids set.
			const loadAssignmentContainerSelects = document.querySelectorAll('#loadAssignmentContainer select');
			loadAssignmentContainerSelects.forEach(select => {
				const loadId = select.dataset.loadId;
				const selectedOption = select.options[select.selectedIndex];
				const selectedMicrogridId = selectedOption.dataset.mgId;
				PARTITION_PARAMS.pairings[selectedMicrogridId] = PARTITION_PARAMS.pairings[selectedMicrogridId] || [];
				PARTITION_PARAMS.pairings[selectedMicrogridId].push(loadId);
				PARTITION_PARAMS.ids.add(selectedMicrogridId);
			});
			// Do not proceed if no loads are in microgrids.
			if (Object.keys(PARTITION_PARAMS.pairings).length === 1 && PARTITION_PARAMS.pairings.None) {
            	alert('At least one load should be placed in a microgrid. Please return to step 3.');
            	return;
        	}
			// Add all text inputs to PARTITION_PARAMS object.
			const mgNames = new Set();
			const partitioningTextInputInputs = document.querySelectorAll('#partitioningTextInput input');
			let hasDuplicates = false;
			partitioningTextInputInputs.forEach(input => {
				const id = input.id;
				const val = input.value.trim();
				const mgId = input.dataset.mgId;
				if (id.includes('Name')) {
					if (val !== "") {
						const isValid = /^[a-z0-9-]+$/.test(val);
						if (!isValid) {
							alert(`Invalid microgrid name: ${val}. Please use only lowercase alphanumeric characters or dashes.`);
							return;
						}
						if (mgNames.has(val)) {
							alert(`Duplicate microgrid name: ${val}. Please provide unique names.`);
							hasDuplicates = true;
							return;
						}
					}
					mgNames.add(val);
					PARTITION_PARAMS.mg_name[mgId] = val;
				} else if (id.includes('GenObsExisting')) {
					PARTITION_PARAMS.gen_obs_existing[mgId] = val;
				} else if (id.includes('GenBus')) {
					PARTITION_PARAMS.gen_bus[mgId] = val;
				} else if (id.includes('Switch')) {
					PARTITION_PARAMS.switch[mgId] = val;
				}
			});
		} else if ((document.getElementById('circuitPostCreation')) && (selectedPartitioningMethod == '')) {
			PARTITION_PARAMS = JSON.parse('{{ in_data.MICROGRIDS | tojson | safe }}');
		}
		form1.append('PARTITION_PARAMS',JSON.stringify(PARTITION_PARAMS));
		// Append mgQuantity. 
		const mgQuantity = document.getElementById('minQuantMgs').value || document.getElementById('mgQuantBranch').value || 0; // new_nx_group_branch.
		form1.append('mgQuantity',mgQuantity);

		// Append microgrid parameter overrides
		const mgParameterOverrides = window.reoptParametersModel.getExportData();
		// Workaround to give mgParameterOverrides keys custom mg names.
		// Workaround to ensure mgParameterOverrides keys update if user changes mg names on edit flow.
		if (selectedPartitioningMethod === 'loadGrouping' || selectedPartitioningMethod === 'manual') {
			PARTITION_PARAMS.ids.forEach(id => {
				if (id !== 'None') {
					const mg_name = PARTITION_PARAMS.mg_name[id];
					if (mg_name !== '') {
						// Create new key in mgParameterOverrides, copy old value, delete old key.
						mgParameterOverrides[mg_name] = mgParameterOverrides[id];
						delete mgParameterOverrides[id];
					}
				}
			});
		}
		form1.append('mgParameterOverrides', JSON.stringify(mgParameterOverrides));

		// - Append data to get single phase load count and three phase load count per load
		const existingJsCircuitModel = JSON.parse('{{ in_data.get("jsCircuitModel", "") | tojson | safe }}');
		if (window.circuitModel.getElements().length > 0) {
			for (const element of window.circuitModel.getElements(element => element.getProperty('type') === 'load')) {
				element.setProperty('loadProfile', undefined);
			}
			// - The user has created a new circuit model, so use that
			form1.append('jsCircuitModel', JSON.stringify(window.circuitModel.getElements().map(e => JSON.stringify(e.getProperties('props')))))
		} else {
			// - The user has not created a new circuit model
			const input = document.getElementById('circuitPostCreation');
			if (existingJsCircuitModel !== '' && input !== null && input.value == 'circuit.dss') {
				// - If there is an existing circuit model (i.e. this is an "edit" run), AND the user didn't click "Remove File", use the existing
				//   circuit model
				form1.append('jsCircuitModel', JSON.stringify(existingJsCircuitModel.map(e => JSON.stringify(e))));
			} else {
				// - If there is no existing circuit model (i.e. the user is using an uploaded DSS file), do not add the "jsCircuitModel" key to the
				//   form
			}
		}

		// Show loading indicator.
		document.getElementById('loading-background').style.display = 'block';
		document.getElementById('loading-indicator').style.display = 'block';
		const modelDir = document.querySelector('input[name="MODEL_DIR"]').value;
		try {
			const response = await fetch('/run', {
				method: 'POST',
				body: form1
			});
			if (response.redirected) {
				setTimeout(function () {
					window.location.href = `/load/${modelDir}`;
				}, 5000); // Delay relocation so files are created first.
			} else if (!response.ok) {
				const responseJson = await response.json();
				throw new Error(responseJson.message);
			}
		} catch (error) {
			// Hide loading indicator if server fails.
			document.getElementById('loading-background').style.display = 'none';
			document.getElementById('loading-indicator').style.display = 'none';
			alert(error);
		}
	}

	window.circuitIsSpecified = false;
	window.filename = '';
	window.onEditFlow = false;

	document.addEventListener('DOMContentLoaded', function() {
		// Clone partitioning div for resetting.
		const stepThreeClone = document.getElementById('stepThree').cloneNode(true);
		// Attach event handlers for partitioning, dropdown creation, and partition button behavior.
		attachPartitioningSelectEventHandler();
		attachManualPartitioningEventHandler();
		attachPartitionButtonEventHandler();

		// Add Remove File buttons for previously uploaded inputs.
		const chunks = document.querySelectorAll('.chunk');
		chunks.forEach(function(chunk) {
			toggleRemoveButton(chunk);
		});

		// Add click event listeners to the Remove File buttons.
		document.addEventListener('click', function(event) {
			if (event.target.matches('button.remove-btn')) {
				const chunk = event.target.closest('.chunk');
				const fileInput = chunk.querySelector('input.file-input');
				// Clear the file input value and hide the Remove File button.
				fileInput.value = '';
				event.target.style.display = 'none';
				toggleRemoveButton(chunk);

				// Special behavior if the user removes the circuit.
				if (event.target.id === 'remove-circuit-button') {
					document.getElementById('wizard').disabled = false;
					// Clear critical loads select and reset partitioning.
					document.getElementById('critLoads').innerHTML = '';
					document.getElementById('stepThree').style.display = 'block';
					document.getElementById('oldPartitionDiv').style.display = 'none';
					document.getElementById('previewPartitionsButton').disabled = false;
					document.getElementById('partitionMethod').disabled = false;
					// Reset previous partitioning.
					document.getElementById('stepThree').replaceWith(stepThreeClone);
					// Reattach partitioning, dropdown creation, and partition button event handler.
					attachPartitioningSelectEventHandler();
					attachManualPartitioningEventHandler();
					attachPartitionButtonEventHandler();
				}
			}
		});

		// Function to check if a .file-input has a value and show/hide the associated Remove button after a new file is selected.
		document.addEventListener('change', function(event) {
			if (event.target.matches('input.file-input')) {
				const chunk = event.target.closest('.chunk');
				toggleRemoveButton(chunk);
			}
		});

		// Limit characters in description textarea.
		document.getElementById('DESCRIPTION').addEventListener('input', limitTextareaCharacters);
		
		// Enable technology toggling.
		toggleDivVisibility('solar', 'solarDiv');
		toggleDivVisibility('battery', 'batteryDiv');
		toggleDivVisibility('fossil', 'fossilDiv');
		toggleDivVisibility('wind', 'windDiv');
		document.getElementById('solar').addEventListener('change', function() {
			toggleDivVisibility('solar', 'solarDiv');
		});
		document.getElementById('battery').addEventListener('change', function() {
			toggleDivVisibility('battery', 'batteryDiv');
		});
		document.getElementById('fossil').addEventListener('change', function() {
			toggleDivVisibility('fossil', 'fossilDiv');
		});
		document.getElementById('wind').addEventListener('change', function() {
			toggleDivVisibility('wind', 'windDiv');
		});

		// Enable circuit definition method choice.
		document.querySelectorAll('div.desc').forEach(function(desc) {
			desc.style.display = 'none';
		});
		document.querySelectorAll('input[type="radio"][name="circuit"]').forEach(function(input) {
			input.checked = false;
		});
		document.querySelectorAll('input[name="circuit"]').forEach(function(input) {
			input.addEventListener('click', function() {
				const test = input.value;
				document.querySelectorAll('div.desc').forEach(function(desc) {
					desc.style.display = 'none';
				});
				document.getElementById('circuit' + test).style.display = 'block';
				if (test === 'Creator') {
					const circuitElements = [
						{
							name: 'substation_1',
							namespace: 'element',
							type: 'substation',
							basekv: 2.4
						},
						{
							name: 'feeder_1',
							namespace: 'element',
							type: 'feeder',
							parent: 'element.substation_1',
						},
						{
							name: 'solar_1',
							namespace: 'element',
							type: 'solar',
							parent: 'element.feeder_1',
							kw: 440
						},
						{
							name: 'wind_1',
							namespace: 'element',
							type: 'wind',
							parent: 'element.feeder_1',
							kw: 200
						},
						{
							name: 'fossil_1',
							namespace: 'element',
							type: 'fossil',
							parent: 'element.feeder_1',
							kw: 265
						},
						{
							name: 'battery_1',
							namespace: 'element',
							type: 'battery',
							parent: 'element.feeder_1',
							kwh: 307,
							kw: 79
						}
					].map(element => new window.CircuitElement(element));
					for (const e of circuitElements) {
						window.circuitModel.addElement(e);
						// - The CircuitTableView is already a graph observer, so it will become an observer of every new element that is added
						// - The CircuitUserControlsView is already a graph observer, so it will become an observer of every new element that is added
						// - The OutageLocationInputview is already a graph observer, so it will become an observer of every new element that is added
					}
					window.outageLocationInputView.updateInput();
				} else {
					for (const e of window.circuitModel.getElements((e) => e.getProperty('type') === 'substation')) {
						window.circuitModel.removeElement(e.fullName);
					}
					window.outageLocationInputView.setValue("{{','.join(in_data.FAULTED_LINES)}}");
				}
			});
		});
		// If user clicked edit, show used circuit.
		if (document.getElementById('circuitPostCreation')) {
			document.getElementById('circuitUpload').style.display = 'block';
			document.getElementById('upload').checked = true;
			document.getElementById('wizard').disabled = true;
			window.circuitIsSpecified = true;
			window.filename = document.getElementById('circuitPostCreation').value;
			const MODEL_DIR = document.getElementsByName('MODEL_DIR')[0].value;
			window.onEditFlow = true;
			// Get allDataInputs.json params from Jinja as variables in the script.
			const inData = JSON.parse('{{ in_data | tojson | safe }}');
			const CRITICAL_LOADS = inData['CRITICAL_LOADS'];
			const MICROGRIDS = inData['MICROGRIDS'];
			// Also populate critical load selection div.
			getLoadsFromExistingFile(MODEL_DIR, CRITICAL_LOADS);
			// Also populate partitioning preview div from original run.
			showOldPartitions(MODEL_DIR, MICROGRIDS, CRITICAL_LOADS);
		}

		// Add tooltip handler to partitioning dropdown.
		document.getElementById('partitionMethod').addEventListener('change', function(event) {
			const options = this.querySelectorAll('option');
			options.forEach(option => {
				option.classList.remove('active');
			});
			const selectedOption = this.querySelector('option:checked');
			if (selectedOption) {
				selectedOption.classList.add('active');
			}
		});

		// Upload DSS circuit. Get loads.
		document.getElementById('upload-file-btn').addEventListener('click', async function() {
			const modelDir = document.querySelector('input[name="MODEL_DIR"]').value;
			// Do not proceed if model has no name.
			if (modelDir === '') {
				alert('Please specify a project name.')
				return 
			}
			// Do not proceed if input contains capital letters.
			const pattern = new RegExp('[A-Z]');
			if (pattern.test(modelDir)) {
				alert('Project names must be entirely lowercase. Please return to Step 1 and provide Project Name with lowercase input.')
				return
			}
			const formElement = document.getElementById('upload-file');
			const formData = new FormData(formElement);
			formData.append('MODEL_DIR', modelDir);
			// Recognize if we're on the edit flow. If we are not, backend should search data/projects for modelDir and return error if it already exists.
			formData.append('onEditFlow',window.onEditFlow);
			try {
				const response = await fetch('/uploadDss', {
					method: 'POST',
					body: formData
				});
				const responseJson = await response.json();
				if (!response.ok) {
					throw new Error(responseJson.message);
				}
				// Enable partition selector.
				document.getElementById('previewPartitionsButton').disabled = false;
				document.getElementById('partitionMethod').disabled = false;
				window.circuitIsSpecified = true;
				const loads = responseJson.loads;
				// Clear critLoads.
				const critLoadsContainer = document.getElementById('critLoads');
				critLoadsContainer.innerHTML = '';
				// Instructions for critLoads.
				const critLoadsParagraph = document.createElement('p');
				critLoadsParagraph.textContent = 'Please select all critical loads:';
				critLoadsContainer.appendChild(critLoadsParagraph);
				// Clear previous content and add loads to manualpartitioningcontainer (shown if user chooses manual partitioning).
				const manualPartitioningContainer = document.getElementById('manualPartitioningContainer');
				manualPartitioningContainer.innerHTML = '';
				manualPartitioningContainer.style.display = 'none';
				// Form element for checkboxes.
				const criticalLoadsSelect = document.createElement('form');
				criticalLoadsSelect.id = 'criticalLoadsSelect';
				criticalLoadsSelect.classList.add('chunk');
				critLoadsContainer.appendChild(criticalLoadsSelect);
				// Create a div to house load assignment dropdown menus.
				const loadAssignmentContainer = document.createElement('div');
				loadAssignmentContainer.id = 'loadAssignmentContainer';
				manualPartitioningContainer.appendChild(loadAssignmentContainer);
				// Create checkboxes and labels for each load.
				for (let i = 0; i < loads.length; i++) {
					const label = document.createElement('label');
					label.style.display = 'inline-block';
					label.style.paddingRight = '5px';
					const checkbox = document.createElement('input');
					checkbox.type = 'checkbox';
					label.appendChild(checkbox);
					label.appendChild(document.createTextNode(loads[i]));
					criticalLoadsSelect.appendChild(label);
					// Add a dropdown to loadAssignmentContainer.
					const dropdownLabel = document.createElement('label');
					dropdownLabel.style.display = 'inline-block';
					dropdownLabel.style.paddingRight = '8px';
					const dropdown = document.createElement('select');
					dropdown.style.marginRight = '3px';
					dropdown.dataset.loadId = loads[i];
					dropdownLabel.appendChild(dropdown);
					dropdownLabel.appendChild(document.createTextNode(loads[i]));
					loadAssignmentContainer.appendChild(dropdownLabel);
				}
				// Handle the case where there are no loads.
				if (loads.length === 0) {
					const noLoadsMessage1 = document.createElement('p');
					noLoadsMessage1.textContent = 'No loads to select from.';
					criticalLoadsSelect.appendChild(noLoadsMessage1);

					const noLoadsMessage2 = document.createElement('p');
					noLoadsMessage2.textContent = 'No loads to assign to microgrids.';
					manualPartitioningContainer.appendChild(noLoadsMessage2);
				}
				window.filename = responseJson.filename; // Set filename.
				const modelDirInput = document.querySelector('input[name="MODEL_DIR"]');
				if (modelDirInput) {
					modelDirInput.readOnly = true; // Make the directory input uneditable.
				}
				document.getElementById('partitionMethod').dispatchEvent(new Event('change')); // Manually trigger dropdown select menu change to potentially refresh partition method descriptions (manual partitioning description differs dependent on wizard vs upload).
			} catch (error) {
				alert(error);
			}
		});

		// Show/hide optional inputs.
		document.querySelectorAll('.toggle').forEach(toggle => {
			toggle.addEventListener('click', function() {
				if (this.classList.contains('show')) {
					// Replace the text
					this.textContent = 'Show fewer inputs';
					// Replace the icon
					const icon = this.previousElementSibling;
					if (icon && icon.tagName.toLowerCase() === 'i') {
						icon.classList.remove('fa-plus-square');
						icon.classList.add('fa-minus-square');
					}
					this.classList.remove('show');
					this.classList.add('hide');
				} else {
					// Replace the text
					this.textContent = 'Optional inputs';
					// Replace the icon
					const icon = this.previousElementSibling;
					if (icon && icon.tagName.toLowerCase() === 'i') {
						icon.classList.remove('fa-minus-square');
						icon.classList.add('fa-plus-square');
					}
					this.classList.remove('hide');
					this.classList.add('show');
				}
				const nextDiv = this.nextElementSibling;
				if (nextDiv && nextDiv.tagName.toLowerCase() === 'div') {
					slideToggle(nextDiv, 500);
				}
			});
		});

		// Validate forms.
		document.getElementById('submitEverything').addEventListener('click', function() {
			if (document.getElementsByClassName('caution').length > 0) {
				alert('Please correct any erroneous inputs with a highlighted error message before submitting your data.');
			} else {
				submitEverything();
			}
		});
	});
	</script>
	<script type='module'>
	import { CircuitElement, CircuitModel, CircuitController, CircuitTableView, CircuitUserControlsView, CsvLoadParser, OutageLocationInputView } from '/static/js/components/circuitBuilder/circuitBuilder.js';
	import { REoptParametersModel, REoptParameters, REoptIntParameter, REoptFloatParameter, REoptStringParameter } from '/static/js/components/reoptParameters/model.js';
	import { REoptParametersController } from '/static/js/components/reoptParameters/controller.js';
	import { REoptParametersView, REoptInputView } from '/static/js/components/reoptParameters/view.js';

	// - CircuitBuilder
	window.CircuitElement = CircuitElement;
	const circuitModel = new CircuitModel();
	window.circuitModel = circuitModel;
	const circuitController = new CircuitController(circuitModel);
	const outageLocationInputView = new OutageLocationInputView(circuitController);
	window.outageLocationInputView = outageLocationInputView;
	circuitModel.addObserver(outageLocationInputView);
	const view = new CircuitTableView(circuitController);
	circuitModel.addObserver(view);
	const csvLoadParser = new CsvLoadParser();
	const controls = new CircuitUserControlsView(circuitController, csvLoadParser);
	csvLoadParser.addObserver(controls);
	circuitModel.addObserver(controls);
	// - The modal div elements must be appended to the DOM before elements are added to the model in order for the modals to update propertly
	document.getElementById('outageLocationInputInsert').append(outageLocationInputView.modal.divElement);
	document.getElementById('circuitCreator').append(view.modal.divElement);
	document.getElementById('circuitCreator').append(controls.modal.divElement);
	outageLocationInputView.setValue("{{','.join(in_data.FAULTED_LINES)}}");
	const csvLoadParserInsert = document.getElementById('csvLoadParserInsert');
	if (csvLoadParserInsert !== null) {
		csvLoadParserInsert.replaceWith(csvLoadParser.modal.divElement);
	} else {
		window.csvLoadParser = csvLoadParser;
	}
	// - Create microgrid-specific REopt parameters widget
	const reoptParametersModel = new REoptParametersModel();
	const reoptParametersController = new REoptParametersController(reoptParametersModel);
	const reoptParametersView = new REoptParametersView(reoptParametersController)
	document.getElementById('reoptParametersMVC').replaceChildren(reoptParametersView.modal.divElement);

	window.createReoptParametersMVC = function(MG_MINES) {
		// - Remove event listener from previous model if it exists
		if (window.reoptParametersModel === undefined) {
			// - If "Remove File" is clicked, then microgrid parameter overrides should be cleared. Don't delete or replace the model, just clear it
			const btn = document.getElementById('remove-circuit-button');
			if (btn !== null) {
				btn.addEventListener('click', function() {
					window.reoptParametersModel.reset();
					window.reoptParametersView.renderContent();
				});
			}
		}
		for (const [mgName, mg] of Object.entries(MG_MINES)) {
			// - If the user clicks "Preview partitions" multiple times, each time should reset any existing parameter overrides first
			if (reoptParametersModel.hasReoptParametersInstance(mgName)) {
				reoptParametersModel.removeReoptParametersInstance(mgName);
			}
			reoptParametersModel.addReoptParametersInstance(mgName);
			// - If this is an edit run, it's possible that there are existing overrides that should populate the widget
			if (Object.hasOwn(mg, 'parameter_overrides')) {
				for (const [paramName, value] of Object.entries(mg['parameter_overrides'])) {
					if (paramName !== 'reopt_inputs') {
						const reoptParameter = reoptParametersModel.getReoptParametersInstance(mgName).reoptParameters.filter(parameter => parameter.alias === paramName)[0];
						reoptParameter.value = value;
					} else {
						for (const [paramName, value] of Object.entries(mg['parameter_overrides']['reopt_inputs'])) {
							const reoptParameter = reoptParametersModel.getReoptParametersInstance(mgName).reoptParameters.filter(parameter => parameter.alias === paramName)[0];
							reoptParameter.value = value;
						}
					}
				}
			}
		}
		// - Need to re-render the view so that the microgrids show up in the select
		reoptParametersView.renderContent();
		window.reoptParametersModel = reoptParametersModel;
		window.reoptParametersView = reoptParametersView;
	}
	// - Create the validation model
	const in_data = JSON.parse('{{ in_data | tojson | safe }}');
	const reoptValidationModel = new REoptParametersModel();
	reoptValidationModel.addReoptParametersInstance('validationMg');
	const validationMg = reoptValidationModel.getReoptParametersInstance('validationMg')
	// - I only add these parameters to the validation model because users shouldn't be able to override these on a per-microgrid basis
	validationMg.addReoptParameter(
		'MicrogridUp:outageDuration',
		new REoptIntParameter(
			'Outage Duration (hours)',
			'MicrogridUp:outageDuration',
			'outageDuration',
			'Please enter a number 1-8760 to specify the duration of the added major outage in hours.',
			8760,
			1));
	validationMg.addReoptParameter(
		'MicrogridUp:maxRuntimeSeconds',
		// - This is a Microgridup-specific variable that is added to the actual ElectricUtility:outage_start_time_step parameter to set the
		//   ElectricUtility:outage_end_time_step parameter in our back-end
		new REoptIntParameter(
			'Maximum REopt Run-time (seconds)',
			'MicrogridUp:maxRuntimeSeconds',
			'maxRuntimeSeconds',
			'Please enter a number 30-86400. A greater maximum REopt run-time could result in more precise REopt results. A maximum REopt run-time that is too short could result in an error.',
			86400,
			30));
	validationMg.addReoptParameter(
		'MicrogridUp:QSTS_STEPS',
		new REoptIntParameter(
			'Interconn. Time Steps (hours)',
			'MicrogridUp:QSTS_STEPS',
			'QSTS_STEPS',
			'Defines the length of the interconnection analysis in hours.',
			480,
			0));
	validationMg.addReoptParameter(
		'MicrogridUp:latitude',
		// - REopt does have a Site:latitude property, but we treat latitude as separate from other REopt inputs from a input perspective
		new REoptFloatParameter(
			'Latitude',
			'MicrogridUp:latitude',
			'latitude',
			'Specify the latitude of the load/grid as a decimal.',
			90,
			-90));
	validationMg.addReoptParameter(
		'MicrogridUp:longitude',
		// - REopt does have a Site:longitude property, but we treat latitude as separate from other REopt inputs from a input perspective
		new REoptFloatParameter(
			'Longitude',
			'MicrogridUp:longitude',
			'longitude',
			'Specify the longitude of the load/grid as a decimal.',
			180,
			-180));
	validationMg.addReoptParameter(
		'MicrogridUp:MODEL_DIR',
		new REoptStringParameter(
			'Project Name',
			'MicrogridUp:MODEL_DIR',
			'MODEL_DIR',
			'A project name must be unique and can only include (1) lowercase alphanumeric characters, (2) "-", and (3) "_". ',
			/^[a-z0-9\-_]+$/));
	const reoptValidationController = new REoptParametersController(reoptValidationModel);
	// - Get the actual parameter values from allInputData.json and use them to set the values of the dynamically inputs
	const parameters = Object.entries(in_data.REOPT_INPUTS);
	parameters.push(
		['singlePhaseRelayCost', in_data.singlePhaseRelayCost],
		['threePhaseRelayCost', in_data.threePhaseRelayCost],
		['QSTS_STEPS', in_data.QSTS_STEPS],
		['latitude', 39.7817],
		['longitude', -89.6501],
        ['MODEL_DIR', in_data.MODEL_DIR])
	for (const [key, value] of parameters) {
		const reoptParameter = reoptValidationModel.getReoptParametersInstance('validationMg').reoptParameters.filter(parameter => parameter.alias === key)[0];
		reoptParameter.value = value;
		const reoptInputView = new REoptInputView(reoptValidationController, `validationMg:${reoptParameter.parameterName}`);
		const replacementDiv = document.getElementById(reoptParameter.alias);
		replacementDiv.replaceWith(reoptInputView.modal.divElement);
	}
	{% if iframe_mode %}
	window.disableInputs = function() {
		[...document.getElementsByTagName('input')].forEach(input => {
			input.disabled = true;
		});
		[...document.getElementsByTagName('button')].forEach(button => {
			button.disabled = true;
		});
		[...document.getElementsByTagName('select')].forEach(select => {
			select.disabled = true;
		});
		[...document.getElementsByTagName('textarea')].forEach(textArea => {
			textArea.disabled = true;
		});
	};
	window.disableInputs();
	{% endif %}
	</script>
</body>
</html>